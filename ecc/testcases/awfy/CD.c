// Generated by Oberon+ IDE (Mono) 0.9.106 on 2024-07-13T01:26:30

#include "CD.h"

void CD$Vector3D$init$(struct CD$Vector3D* inst){
    inst->class$ = &CD$Vector3D$class$;
}
void CD$CollisionDetector$handleNewFrame$ForEachInterface$init$(struct CD$CollisionDetector$handleNewFrame$ForEachInterface* inst){
    inst->class$ = &CD$CollisionDetector$handleNewFrame$ForEachInterface$class$;
}
void CD$CollisionDetector$init$(struct CD$CollisionDetector* inst){
    inst->class$ = &CD$CollisionDetector$class$;
}
void CD$Simulator$init$(struct CD$Simulator* inst){
    inst->class$ = &CD$Simulator$class$;
}
void CD$reduceCollisionSet$ForEachInterface$init$(struct CD$reduceCollisionSet$ForEachInterface* inst){
    inst->class$ = &CD$reduceCollisionSet$ForEachInterface$class$;
}
void CD$CD$init$(struct CD$CD* inst){
    inst->class$ = &CD$CD$class$;
}
void CD$Vector2D$init$(struct CD$Vector2D* inst){
    inst->class$ = &CD$Vector2D$class$;
}
void CD$CallSign$init$(struct CD$CallSign* inst){
    inst->class$ = &CD$CallSign$class$;
}
void CD$Motion$init$(struct CD$Motion* inst){
    inst->class$ = &CD$Motion$class$;
    CD$CallSign$init$(&inst->callsign);
    CD$Vector3D$init$(&inst->posOne);
    CD$Vector3D$init$(&inst->posTwo);
}
void CD$Aircraft$init$(struct CD$Aircraft* inst){
    inst->class$ = &CD$Aircraft$class$;
    CD$CallSign$init$(&inst->callsign);
    CD$Vector3D$init$(&inst->position);
}
void CD$Collision$init$(struct CD$Collision* inst){
    inst->class$ = &CD$Collision$class$;
    CD$CallSign$init$(&inst->aircraftA);
    CD$CallSign$init$(&inst->aircraftB);
    CD$Vector3D$init$(&inst->position);
}
struct CD$Vector2D CD$horizontal;
struct CD$Vector2D CD$vertical;
struct CD$CD * CD$create() {
    struct CD$CD * c;
    struct CD$CD * $t0;
    c = 0;
    $t0 = OBX$Alloc(sizeof(struct CD$CD));
    memset($t0,0,sizeof(struct CD$CD));
    c = $t0;
    CD$CD$init$($t0);
    return c;
}

struct Benchmark$Result * CD$CD$benchmark(void* this) {
    struct CD$CD* this$ = this;
    assert(0);
    return 0;
}

uint8_t CD$CD$verifyResult(void* this, struct Benchmark$Result * result) {
    struct CD$CD* this$ = this;
    assert(0);
    return 0;
}

int32_t CD$benchmark2(int32_t numAircrafts) {
    struct CD$Simulator * simulator;
    struct CD$CollisionDetector * detector;
    int32_t actualCollisions;
    int32_t i;
    double time;
    struct som$Vector$326bd6ec32$Vector * collisions;
    void* $t0;
    struct som$Vector$326bd6ec32$Vector * (* $t1)(void*, struct som$Vector$c235aac6c4$Vector *);
    void* $t2;
    struct som$Vector$c235aac6c4$Vector * (* $t3)(void*, double);
    int32_t (* $t4)(void*);
    simulator = 0;
    detector = 0;
    actualCollisions = 0;
    i = 0;
    time = 0;
    collisions = 0;
    simulator = CD$createSimulator(numAircrafts);
    detector = CD$createCD();
    actualCollisions = 0;
    i = 0;
    while(1) {
        if( (i <= (200 - 1)) ) {
            time = ((double)i / 1.0000000e+01);
            collisions = ($t1 = ((struct CD$CollisionDetector *)($t0 = &(*detector)))->class$->handleNewFrame, $t1($t0, ($t3 = ((struct CD$Simulator *)($t2 = &(*simulator)))->class$->simulate, $t3($t2, time))));
            actualCollisions = (actualCollisions + ($t4 = ((struct som$Vector$326bd6ec32$Vector *)($t0 = &(*collisions)))->class$->getSize, $t4($t0)));
            i = (i + 1);
        } else {
            break;
        }
    }
    return actualCollisions;
}

uint8_t CD$CD$innerBenchmarkLoop(void* this, int32_t innerIterations) {
    struct CD$CD* this$ = this;
    if( (innerIterations < 2) ) {
        innerIterations = 2;
    } 
    return CD$verifyResult2(CD$benchmark2(innerIterations), innerIterations);
}

uint8_t CD$verifyResult2(int32_t actualCollisions, int32_t numAircrafts) {
    if( (numAircrafts == 1000) ) {
        return (actualCollisions == 14484);
    } 
    if( (numAircrafts == 500) ) {
        return (actualCollisions == 14484);
    } 
    if( (numAircrafts == 250) ) {
        return (actualCollisions == 10830);
    } 
    if( (numAircrafts == 200) ) {
        return (actualCollisions == 8655);
    } 
    if( (numAircrafts == 100) ) {
        return (actualCollisions == 4305);
    } 
    if( (numAircrafts == 10) ) {
        return (actualCollisions == 390);
    } 
    if( (numAircrafts == 2) ) {
        return (actualCollisions == 42);
    } 
    Out$String((const struct OBX$Array$1){28,0,OBX$FromUtf("No verification result for ",28,0)});
    Out$Int(numAircrafts, 0);
    Out$String((const struct OBX$Array$1){7,0,OBX$FromUtf(" found",7,0)});
    Out$Ln();
    Out$String((const struct OBX$Array$1){12,0,OBX$FromUtf("Result is: ",12,0)});
    Out$Int(actualCollisions, 0);
    Out$Ln();
    return 0;
}

struct CD$Vector2D CD$Vector2D$plus(void* this, struct CD$Vector2D * other) {
    struct CD$Vector2D* this$ = this;
    struct CD$Vector2D res;
    memset(&res,0,sizeof(res));
    CD$Vector2D$init$(&res);
    res.x = ((*this$).x + (*other).x);
    res.y = ((*this$).y + (*other).y);
    return res;
}

struct CD$Vector2D CD$Vector2D$minus(void* this, struct CD$Vector2D * other) {
    struct CD$Vector2D* this$ = this;
    struct CD$Vector2D res;
    memset(&res,0,sizeof(res));
    CD$Vector2D$init$(&res);
    res.x = ((*this$).x - (*other).x);
    res.y = ((*this$).y - (*other).y);
    return res;
}

int32_t CD$compareVector2D(struct CD$Vector2D * lhs, struct CD$Vector2D * rhs) {
    int32_t result;
    result = 0;
    result = CD$compareNumbers((*lhs).x, (*rhs).x);
    if( (result != 0) ) {
        return result;
    } 
    return CD$compareNumbers((*lhs).y, (*rhs).y);
}

int32_t CD$compareNumbers(double a, double b) {
    if( (a == b) ) {
        return 0;
    } 
    if( (a < b) ) {
        return (-1);
    } 
    if( (a > b) ) {
        return 1;
    } 
    if( (a == a) ) {
        return 1;
    } 
    return (-1);
}

struct CD$Vector3D CD$Vector3D$plus(void* this, struct CD$Vector3D * other) {
    struct CD$Vector3D* this$ = this;
    struct CD$Vector3D res;
    memset(&res,0,sizeof(res));
    CD$Vector3D$init$(&res);
    res.x = ((*this$).x + (*other).x);
    res.y = ((*this$).y + (*other).y);
    res.z = ((*this$).z + (*other).z);
    return res;
}

struct CD$Vector3D CD$Vector3D$minus(void* this, struct CD$Vector3D * other) {
    struct CD$Vector3D* this$ = this;
    struct CD$Vector3D res;
    memset(&res,0,sizeof(res));
    CD$Vector3D$init$(&res);
    res.x = ((*this$).x - (*other).x);
    res.y = ((*this$).y - (*other).y);
    res.z = ((*this$).z - (*other).z);
    return res;
}

struct CD$Vector3D CD$Vector3D$times(void* this, double amount) {
    struct CD$Vector3D* this$ = this;
    struct CD$Vector3D res;
    memset(&res,0,sizeof(res));
    CD$Vector3D$init$(&res);
    res.x = ((*this$).x * amount);
    res.y = ((*this$).y * amount);
    res.z = ((*this$).z * amount);
    return res;
}

double CD$Vector3D$dot(void* this, struct CD$Vector3D * other) {
    struct CD$Vector3D* this$ = this;
    return ((((*this$).x * (*other).x) + ((*this$).y * (*other).y)) + ((*this$).z * (*other).z));
}

double CD$Vector3D$squaredMagnitude(void* this) {
    struct CD$Vector3D* this$ = this;
    void* $t0;
    double (* $t1)(void*, struct CD$Vector3D *);
    return ($t1 = ((struct CD$Vector3D *)($t0 = &(*this$)))->class$->dot, $t1($t0, &(*this$)));
}

double CD$Vector3D$magnitude(void* this) {
    struct CD$Vector3D* this$ = this;
    void* $t0;
    double (* $t1)(void*);
    return Math$sqrt(($t1 = ((struct CD$Vector3D *)($t0 = &(*this$)))->class$->squaredMagnitude, $t1($t0)));
}

int32_t CD$compareCallSign(struct CD$CallSign * lhs, struct CD$CallSign * rhs) {
    if( ((*lhs).value == (*rhs).value) ) {
        return 0;
    } else if( ((*lhs).value < (*rhs).value) ) {
        return (-1);
    } else {
        return 1;
    }
    return 0;
}

struct CD$Simulator * CD$createSimulator(int32_t numAircraft) {
    struct CD$Simulator * sim;
    int32_t i;
    struct CD$CallSign cs;
    struct CD$Simulator * $t0;
    void* $t1;
    void (* $t2)(void*, struct CD$CallSign *);
    sim = 0;
    i = 0;
    memset(&cs,0,sizeof(cs));
    CD$CallSign$init$(&cs);
    $t0 = OBX$Alloc(sizeof(struct CD$Simulator));
    memset($t0,0,sizeof(struct CD$Simulator));
    sim = $t0;
    CD$Simulator$init$($t0);
    (*sim).aircraft = som$Vector$a1be3657f7$create();
    i = 0;
    while(1) {
        if( (i <= (numAircraft - 1)) ) {
            cs.value = i;
            ($t2 = ((struct som$Vector$a1be3657f7$Vector *)($t1 = &(*(*sim).aircraft)))->class$->append, $t2($t1, &cs));
            i = (i + 1);
        } else {
            break;
        }
    }
    return sim;
}

struct som$Vector$c235aac6c4$Vector * CD$Simulator$simulate(void* this, double time) {
    struct CD$Simulator* this$ = this;
    struct som$Vector$c235aac6c4$Vector * frame;
    int32_t i;
    struct CD$Aircraft ac;
    void* $t0;
    int32_t (* $t1)(void*);
    void* $t2;
    struct CD$CallSign (* $t3)(void*, int32_t);
    void (* $t4)(void*, struct CD$Aircraft *);
    frame = 0;
    i = 0;
    memset(&ac,0,sizeof(ac));
    CD$Aircraft$init$(&ac);
    frame = som$Vector$c235aac6c4$create();
    i = 0;
    while(1) {
        if( (i <= (($t1 = ((struct som$Vector$a1be3657f7$Vector *)($t0 = &(*(*this$).aircraft)))->class$->getSize, $t1($t0)) - 1)) ) {
            ac.callsign = ($t3 = ((struct som$Vector$a1be3657f7$Vector *)($t2 = &(*(*this$).aircraft)))->class$->at, $t3($t2, i));
            ac.position.x = time;
            ac.position.y = ((Math$cos(time) * 2.0000000e+00) + ((double)i * 3.0000000e+00));
            ac.position.z = 10;
            ($t4 = ((struct som$Vector$c235aac6c4$Vector *)($t0 = &(*frame)))->class$->append, $t4($t0, &ac));
            ac.callsign = ($t3 = ((struct som$Vector$a1be3657f7$Vector *)($t0 = &(*(*this$).aircraft)))->class$->at, $t3($t0, (i + 1)));
            ac.position.y = ((Math$sin(time) * 2.0000000e+00) + ((double)i * 3.0000000e+00));
            ($t4 = ((struct som$Vector$c235aac6c4$Vector *)($t0 = &(*frame)))->class$->append, $t4($t0, &ac));
            i = (i + 2);
        } else {
            break;
        }
    }
    return frame;
}

struct CD$Motion * CD$createMotion(struct CD$CallSign * callsign, struct CD$Vector3D * posOne, struct CD$Vector3D * posTwo) {
    struct CD$Motion * m;
    struct CD$Motion * $t0;
    m = 0;
    $t0 = OBX$Alloc(sizeof(struct CD$Motion));
    memset($t0,0,sizeof(struct CD$Motion));
    m = $t0;
    CD$Motion$init$($t0);
    (*m).callsign = (*callsign);
    (*m).posOne = (*posOne);
    (*m).posTwo = (*posTwo);
    return m;
}

struct CD$Vector3D CD$Motion$delta(void* this) {
    struct CD$Motion* this$ = this;
    void* $t0;
    struct CD$Vector3D (* $t1)(void*, struct CD$Vector3D *);
    return ($t1 = ((struct CD$Vector3D *)($t0 = &(*this$).posTwo))->class$->minus, $t1($t0, &(*this$).posOne));
}

uint8_t CD$Motion$findIntersection(void* this, struct CD$Motion * other, struct CD$Vector3D * result) {
    struct CD$Motion* this$ = this;
    struct CD$Vector3D init1;
    struct CD$Vector3D init2;
    struct CD$Vector3D vec1;
    struct CD$Vector3D vec2;
    struct CD$Vector3D result1;
    struct CD$Vector3D result2;
    double radius;
    double a;
    double b;
    double c;
    double discr;
    double v;
    double v1;
    double v2;
    double dist;
    void* $t0;
    struct CD$Vector3D (* $t1)(void*);
    double (* $t2)(void*);
    void* $t3;
    struct CD$Vector3D (* $t4)(void*, struct CD$Vector3D *);
    double (* $t5)(void*, struct CD$Vector3D *);
    void* $t6;
    struct CD$Vector3D (* $t7)(void*, struct CD$Vector3D *);
    struct CD$Vector3D (* $t8)(void*, double);
    memset(&init1,0,sizeof(init1));
    CD$Vector3D$init$(&init1);
    memset(&init2,0,sizeof(init2));
    CD$Vector3D$init$(&init2);
    memset(&vec1,0,sizeof(vec1));
    CD$Vector3D$init$(&vec1);
    memset(&vec2,0,sizeof(vec2));
    CD$Vector3D$init$(&vec2);
    memset(&result1,0,sizeof(result1));
    CD$Vector3D$init$(&result1);
    memset(&result2,0,sizeof(result2));
    CD$Vector3D$init$(&result2);
    radius = 0;
    a = 0;
    b = 0;
    c = 0;
    discr = 0;
    v = 0;
    v1 = 0;
    v2 = 0;
    dist = 0;
    init1 = (*this$).posOne;
    init2 = (*other).posOne;
    vec1 = ($t1 = ((struct CD$Motion *)($t0 = &(*this$)))->class$->delta, $t1($t0));
    vec2 = ($t1 = ((struct CD$Motion *)($t0 = &(*other)))->class$->delta, $t1($t0));
    radius = 1.0000000e+00;
    a = ($t2 = ((struct CD$Vector3D *)($t0 = &((struct CD$Vector3D[1]){($t4 = ((struct CD$Vector3D *)($t3 = &vec2))->class$->minus, $t4($t3, &vec1))})[0]))->class$->squaredMagnitude, $t2($t0));
    if( (a != 0.0000000e+00) ) {
        b = (2.0000000e+00 * ($t5 = ((struct CD$Vector3D *)($t0 = &((struct CD$Vector3D[1]){($t4 = ((struct CD$Vector3D *)($t3 = &init1))->class$->minus, $t4($t3, &init2))})[0]))->class$->dot, $t5($t0, &((struct CD$Vector3D[1]){($t7 = ((struct CD$Vector3D *)($t6 = &vec1))->class$->minus, $t7($t6, &vec2))})[0])));
        c = ((-(radius * radius)) + ($t2 = ((struct CD$Vector3D *)($t0 = &((struct CD$Vector3D[1]){($t4 = ((struct CD$Vector3D *)($t3 = &init2))->class$->minus, $t4($t3, &init1))})[0]))->class$->squaredMagnitude, $t2($t0)));
        discr = ((b * b) - ((4.0000000e+00 * a) * c));
        if( (discr < 0.0000000e+00) ) {
            return 0;
        } 
        v1 = (((-b) - Math$sqrt(discr)) / (2.0000000e+00 * a));
        v2 = (((-b) + Math$sqrt(discr)) / (2.0000000e+00 * a));
        if( ((v1 <= v2) && ((((v1 <= 1.0000000e+00) && (1.0000000e+00 <= v2)) || ((v1 <= 0.0000000e+00) && (0.0000000e+00 <= v2))) || ((0.0000000e+00 <= v1) && (v2 <= 1.0000000e+00)))) ) {
            if( (v1 <= 0.0000000e+00) ) {
                v = 0.0000000e+00;
            } else {
                v = v1;
            }
            result1 = ($t4 = ((struct CD$Vector3D *)($t0 = &init1))->class$->plus, $t4($t0, &((struct CD$Vector3D[1]){($t8 = ((struct CD$Vector3D *)($t3 = &vec1))->class$->times, $t8($t3, v))})[0]));
            result2 = ($t4 = ((struct CD$Vector3D *)($t0 = &init2))->class$->plus, $t4($t0, &((struct CD$Vector3D[1]){($t8 = ((struct CD$Vector3D *)($t3 = &vec2))->class$->times, $t8($t3, v))})[0]));
            (*result) = ($t8 = ((struct CD$Vector3D *)($t0 = &((struct CD$Vector3D[1]){($t4 = ((struct CD$Vector3D *)($t3 = &result1))->class$->plus, $t4($t3, &result2))})[0]))->class$->times, $t8($t0, 5.0000000e-01));
            if( (((((((*result).x >= 0.0000000e+00) && ((*result).x <= 1.0000000e+03)) && ((*result).y >= 0.0000000e+00)) && ((*result).y <= 1.0000000e+03)) && ((*result).z >= 0.0000000e+00)) && ((*result).z <= 1.0000000e+01)) ) {
                return 1;
            } 
        } 
        return 0;
    } 
    dist = ($t2 = ((struct CD$Vector3D *)($t0 = &((struct CD$Vector3D[1]){($t4 = ((struct CD$Vector3D *)($t3 = &init2))->class$->minus, $t4($t3, &init1))})[0]))->class$->magnitude, $t2($t0));
    if( (dist <= radius) ) {
        (*result) = ($t8 = ((struct CD$Vector3D *)($t0 = &((struct CD$Vector3D[1]){($t4 = ((struct CD$Vector3D *)($t3 = &init1))->class$->plus, $t4($t3, &init2))})[0]))->class$->times, $t8($t0, 5.0000000e-01));
        return 1;
    } 
    return 0;
}

struct CD$CollisionDetector * CD$createCD() {
    struct CD$CollisionDetector * cd;
    struct CD$CollisionDetector * $t0;
    cd = 0;
    $t0 = OBX$Alloc(sizeof(struct CD$CollisionDetector));
    memset($t0,0,sizeof(struct CD$CollisionDetector));
    cd = $t0;
    CD$CollisionDetector$init$($t0);
    (*cd).state = som$RedBlackTree$80265c2f3b$create(CD$compareCallSign);
    return cd;
}

struct som$Vector$326bd6ec32$Vector * CD$CollisionDetector$handleNewFrame(void* this, struct som$Vector$c235aac6c4$Vector * frame) {
    struct CD$CollisionDetector* this$ = this;
    struct som$Vector$e0832c0c14$Vector * motions;
    struct som$RedBlackTree$adef759a05$RedBlackTree * seen;
    int32_t i;
    int32_t j;
    int32_t k;
    struct CD$Aircraft aircraft;
    struct CD$Vector3D oldPosition;
    struct CD$Vector3D newPosition;
    struct som$Vector$a1be3657f7$Vector * toRemove;
    struct som$Vector$326bd6ec32$Vector * collisions;
    uint8_t dummy;
    struct CD$Vector3D dummy2;
    struct CD$CollisionDetector$handleNewFrame$ForEachInterface it;
    struct som$Vector$d8f2cdf460$Vector * allReduced;
    struct som$Vector$e0832c0c14$Vector * reduced;
    struct CD$Motion * motion1;
    struct CD$Motion * motion2;
    struct CD$Vector3D collisionPos;
    struct CD$Collision collision;
    uint8_t newEntry;
    void* $t0;
    int32_t (* $t1)(void*);
    void* $t2;
    struct CD$Aircraft (* $t3)(void*, int32_t);
    struct CD$Vector3D (* $t4)(void*, struct CD$CallSign *, struct CD$Vector3D *, uint8_t *);
    uint8_t (* $t5)(void*, struct CD$CallSign *, uint8_t *);
    void (* $t6)(void*, struct CD$Motion * *);
    void (* $t7)(void*, struct som$Interfaces$b3330a6a65$ForEachInterface *);
    struct CD$Vector3D (* $t8)(void*, struct CD$CallSign *);
    void* $t9;
    struct CD$CallSign (* $t10)(void*, int32_t);
    struct som$Vector$e0832c0c14$Vector * (* $t11)(void*, int32_t);
    struct CD$Motion * (* $t12)(void*, int32_t);
    uint8_t (* $t13)(void*, struct CD$Motion *, struct CD$Vector3D *);
    void (* $t14)(void*, struct CD$Collision *);
    motions = 0;
    seen = 0;
    i = 0;
    j = 0;
    k = 0;
    memset(&aircraft,0,sizeof(aircraft));
    CD$Aircraft$init$(&aircraft);
    memset(&oldPosition,0,sizeof(oldPosition));
    CD$Vector3D$init$(&oldPosition);
    memset(&newPosition,0,sizeof(newPosition));
    CD$Vector3D$init$(&newPosition);
    toRemove = 0;
    collisions = 0;
    dummy = 0;
    memset(&dummy2,0,sizeof(dummy2));
    CD$Vector3D$init$(&dummy2);
    memset(&it,0,sizeof(it));
    CD$CollisionDetector$handleNewFrame$ForEachInterface$init$(&it);
    allReduced = 0;
    reduced = 0;
    motion1 = 0;
    motion2 = 0;
    memset(&collisionPos,0,sizeof(collisionPos));
    CD$Vector3D$init$(&collisionPos);
    memset(&collision,0,sizeof(collision));
    CD$Collision$init$(&collision);
    newEntry = 0;
    motions = som$Vector$e0832c0c14$create();
    seen = som$RedBlackTree$adef759a05$create(CD$compareCallSign);
    i = 0;
    while(1) {
        if( (i <= (($t1 = ((struct som$Vector$c235aac6c4$Vector *)($t0 = &(*frame)))->class$->getSize, $t1($t0)) - 1)) ) {
            aircraft = ($t3 = ((struct som$Vector$c235aac6c4$Vector *)($t2 = &(*frame)))->class$->at, $t3($t2, i));
            oldPosition = ($t4 = ((struct som$RedBlackTree$80265c2f3b$RedBlackTree *)($t0 = &(*(*this$).state)))->class$->putChecked, $t4($t0, &aircraft.callsign, &aircraft.position, &newEntry));
            newPosition = aircraft.position;
            dummy = ($t5 = ((struct som$RedBlackTree$adef759a05$RedBlackTree *)($t0 = &(*seen)))->class$->put, $t5($t0, &aircraft.callsign, &(uint8_t){1}));
            if( newEntry ) {
                oldPosition = newPosition;
            } 
            ($t6 = ((struct som$Vector$e0832c0c14$Vector *)($t0 = &(*motions)))->class$->append, $t6($t0, &((struct CD$Motion *[1]){CD$createMotion(&aircraft.callsign, &oldPosition, &newPosition)})[0]));
            i = (i + 1);
        } else {
            break;
        }
    }
    toRemove = som$Vector$a1be3657f7$create();
    it.toRemove = toRemove;
    it.seen = seen;
    ($t7 = ((struct som$RedBlackTree$80265c2f3b$RedBlackTree *)($t0 = &(*(*this$).state)))->class$->forEach, $t7($t0, ((struct som$Interfaces$b3330a6a65$ForEachInterface *)&it)));
    i = 0;
    while(1) {
        if( (i <= (($t1 = ((struct som$Vector$a1be3657f7$Vector *)($t0 = &(*toRemove)))->class$->getSize, $t1($t0)) - 1)) ) {
            dummy2 = ($t8 = ((struct som$RedBlackTree$80265c2f3b$RedBlackTree *)($t2 = &(*(*this$).state)))->class$->remove, $t8($t2, &((struct CD$CallSign[1]){($t10 = ((struct som$Vector$a1be3657f7$Vector *)($t9 = &(*toRemove)))->class$->at, $t10($t9, i))})[0]));
            i = (i + 1);
        } else {
            break;
        }
    }
    allReduced = CD$reduceCollisionSet(motions);
    collisions = som$Vector$326bd6ec32$create();
    k = 0;
    while(1) {
        if( (k <= (($t1 = ((struct som$Vector$d8f2cdf460$Vector *)($t0 = &(*allReduced)))->class$->getSize, $t1($t0)) - 1)) ) {
            reduced = ($t11 = ((struct som$Vector$d8f2cdf460$Vector *)($t2 = &(*allReduced)))->class$->at, $t11($t2, k));
            i = 0;
            while(1) {
                if( (i <= (($t1 = ((struct som$Vector$e0832c0c14$Vector *)($t0 = &(*reduced)))->class$->getSize, $t1($t0)) - 1)) ) {
                    motion1 = ($t12 = ((struct som$Vector$e0832c0c14$Vector *)($t2 = &(*reduced)))->class$->at, $t12($t2, i));
                    j = (i + 1);
                    while(1) {
                        if( (j <= (($t1 = ((struct som$Vector$e0832c0c14$Vector *)($t0 = &(*reduced)))->class$->getSize, $t1($t0)) - 1)) ) {
                            motion2 = ($t12 = ((struct som$Vector$e0832c0c14$Vector *)($t2 = &(*reduced)))->class$->at, $t12($t2, j));
                            if( ($t13 = ((struct CD$Motion *)($t0 = &(*motion1)))->class$->findIntersection, $t13($t0, motion2, &collisionPos)) ) {
                                collision.aircraftA = (*motion1).callsign;
                                collision.aircraftB = (*motion2).callsign;
                                collision.position = collisionPos;
                                ($t14 = ((struct som$Vector$326bd6ec32$Vector *)($t0 = &(*collisions)))->class$->append, $t14($t0, &collision));
                            } 
                            j = (j + 1);
                        } else {
                            break;
                        }
                    }
                    i = (i + 1);
                } else {
                    break;
                }
            }
            k = (k + 1);
        } else {
            break;
        }
    }
    return collisions;
}

void CD$CollisionDetector$handleNewFrame$ForEachInterface$apply(void* this, struct som$RedBlackTree$80265c2f3b$Entry * elem) {
    struct CD$CollisionDetector$handleNewFrame$ForEachInterface* this$ = this;
    void* $t0;
    uint8_t (* $t1)(void*, struct CD$CallSign *);
    void* $t2;
    void (* $t3)(void*, struct CD$CallSign *);
    if( (!($t1 = ((struct som$RedBlackTree$adef759a05$RedBlackTree *)($t0 = &(*(*this$).seen)))->class$->get, $t1($t0, &(*(struct CD$CallSign *)&(*elem).key)))) ) {
        ($t3 = ((struct som$Vector$a1be3657f7$Vector *)($t2 = &(*(*this$).toRemove)))->class$->append, $t3($t2, &(*(struct CD$CallSign *)&(*elem).key)));
    } 
}

uint8_t CD$isInVoxel(struct CD$Vector2D * voxel, struct CD$Motion * motion) {
    struct CD$Vector3D init;
    struct CD$Vector3D fin;
    double v_s;
    double r;
    double v_x;
    double x0;
    double xv;
    double v_y;
    double y0;
    double yv;
    double low_x;
    double high_x;
    double tmp;
    double low_y;
    double high_y;
    memset(&init,0,sizeof(init));
    CD$Vector3D$init$(&init);
    memset(&fin,0,sizeof(fin));
    CD$Vector3D$init$(&fin);
    v_s = 0;
    r = 0;
    v_x = 0;
    x0 = 0;
    xv = 0;
    v_y = 0;
    y0 = 0;
    yv = 0;
    low_x = 0;
    high_x = 0;
    tmp = 0;
    low_y = 0;
    high_y = 0;
    if( (((((*voxel).x > 1.0000000e+03) || ((*voxel).x < 0.0000000e+00)) || ((*voxel).y > 1.0000000e+03)) || ((*voxel).y < 0.0000000e+00)) ) {
        return 0;
    } 
    init = (*motion).posOne;
    fin = (*motion).posTwo;
    v_s = 2.0000000e+00;
    r = (1.0000000e+00 / 2.0000000e+00);
    v_x = (*voxel).x;
    x0 = init.x;
    xv = (fin.x - init.x);
    v_y = (*voxel).y;
    y0 = init.y;
    yv = (fin.y - init.y);
    low_x = (((v_x - r) - x0) / xv);
    high_x = ((((v_x + v_s) + r) - x0) / xv);
    if( (xv < 0.0000000e+00) ) {
        tmp = low_x;
        low_x = high_x;
        high_x = tmp;
    } 
    low_y = (((v_y - r) - y0) / yv);
    high_y = ((((v_y + v_s) + r) - y0) / yv);
    if( (yv < 0.0000000e+00) ) {
        tmp = low_y;
        low_y = high_y;
        high_y = tmp;
    } 
    return ((((((((xv == 0.0000000e+00) && (v_x <= (x0 + r))) && ((x0 - r) <= (v_x + v_s))) || ((low_x <= 1.0000000e+00) && (1.0000000e+00 <= high_x))) || ((low_x <= 0.0000000e+00) && (0.0000000e+00 <= high_x))) || ((0.0000000e+00 <= low_x) && (high_x <= 1.0000000e+00))) && ((((yv == 0.0000000e+00) && (v_y <= (y0 + r))) && ((y0 - r) <= (v_y + v_s))) || ((((low_y <= 1.0000000e+00) && (1.0000000e+00 <= high_y)) || ((low_y <= 0.0000000e+00) && (0.0000000e+00 <= high_y))) || ((0.0000000e+00 <= low_y) && (high_y <= 1.0000000e+00))))) && (((((xv == 0.0000000e+00) || (yv == 0.0000000e+00)) || ((low_y <= high_x) && (high_x <= high_y))) || ((low_y <= low_x) && (low_x <= high_y))) || ((low_x <= low_y) && (high_y <= high_x))));
}

void CD$putIntoMap(struct som$RedBlackTree$14446907c4$RedBlackTree * voxelMap, struct CD$Vector2D * voxel, struct CD$Motion * motion) {
    struct som$Vector$e0832c0c14$Vector * arr;
    struct som$Vector$e0832c0c14$Vector * dummy;
    void* $t0;
    struct som$Vector$e0832c0c14$Vector * (* $t1)(void*, struct CD$Vector2D *);
    struct som$Vector$e0832c0c14$Vector * (* $t2)(void*, struct CD$Vector2D *, struct som$Vector$e0832c0c14$Vector * *);
    void (* $t3)(void*, struct CD$Motion * *);
    arr = 0;
    dummy = 0;
    arr = ($t1 = ((struct som$RedBlackTree$14446907c4$RedBlackTree *)($t0 = &(*voxelMap)))->class$->get, $t1($t0, &(*voxel)));
    if( ((void*)arr == (void*)0) ) {
        arr = som$Vector$e0832c0c14$create();
        dummy = ($t2 = ((struct som$RedBlackTree$14446907c4$RedBlackTree *)($t0 = &(*voxelMap)))->class$->put, $t2($t0, &(*voxel), &arr));
    } 
    ($t3 = ((struct som$Vector$e0832c0c14$Vector *)($t0 = &(*arr)))->class$->append, $t3($t0, &motion));
}

struct som$Vector$d8f2cdf460$Vector * CD$reduceCollisionSet(struct som$Vector$e0832c0c14$Vector * motions) {
    struct som$RedBlackTree$14446907c4$RedBlackTree * voxelMap;
    struct som$Vector$d8f2cdf460$Vector * result;
    int32_t i;
    struct CD$reduceCollisionSet$ForEachInterface it;
    void* $t0;
    int32_t (* $t1)(void*);
    void* $t2;
    struct CD$Motion * (* $t3)(void*, int32_t);
    void (* $t4)(void*, struct som$Interfaces$d1517c3aa3$ForEachInterface *);
    voxelMap = 0;
    result = 0;
    i = 0;
    memset(&it,0,sizeof(it));
    CD$reduceCollisionSet$ForEachInterface$init$(&it);
    voxelMap = som$RedBlackTree$14446907c4$create(CD$compareVector2D);
    i = 0;
    while(1) {
        if( (i <= (($t1 = ((struct som$Vector$e0832c0c14$Vector *)($t0 = &(*motions)))->class$->getSize, $t1($t0)) - 1)) ) {
            CD$drawMotionOnVoxelMap(voxelMap, ($t3 = ((struct som$Vector$e0832c0c14$Vector *)($t2 = &(*motions)))->class$->at, $t3($t2, i)));
            i = (i + 1);
        } else {
            break;
        }
    }
    result = som$Vector$d8f2cdf460$create();
    it.result = result;
    ($t4 = ((struct som$RedBlackTree$14446907c4$RedBlackTree *)($t0 = &(*voxelMap)))->class$->forEach, $t4($t0, ((struct som$Interfaces$d1517c3aa3$ForEachInterface *)&it)));
    return result;
}

void CD$reduceCollisionSet$ForEachInterface$apply(void* this, struct som$RedBlackTree$14446907c4$Entry * elem) {
    struct CD$reduceCollisionSet$ForEachInterface* this$ = this;
    void* $t0;
    int32_t (* $t1)(void*);
    void* $t2;
    void (* $t3)(void*, struct som$Vector$e0832c0c14$Vector * *);
    if( (($t1 = ((struct som$Vector$e0832c0c14$Vector *)($t0 = &(*(*elem).value)))->class$->getSize, $t1($t0)) > 1) ) {
        ($t3 = ((struct som$Vector$d8f2cdf460$Vector *)($t2 = &(*(*this$).result)))->class$->append, $t3($t2, &(*elem).value));
    } 
}

void CD$recurse(struct som$RedBlackTree$14446907c4$RedBlackTree * voxelMap, struct som$RedBlackTree$3520dd22aa$RedBlackTree * seen, struct CD$Vector2D * nextVoxel, struct CD$Motion * motion) {
    void* $t0;
    uint8_t (* $t1)(void*, struct CD$Vector2D *, uint8_t *);
    struct CD$Vector2D (* $t2)(void*, struct CD$Vector2D *);
    void* $t3;
    struct CD$Vector2D (* $t4)(void*, struct CD$Vector2D *);
    if( (!CD$isInVoxel(&(*nextVoxel), motion)) ) {
        return ;
    } 
    if( ($t1 = ((struct som$RedBlackTree$3520dd22aa$RedBlackTree *)($t0 = &(*seen)))->class$->put, $t1($t0, &(*nextVoxel), &(uint8_t){1})) ) {
        return ;
    } 
    CD$putIntoMap(voxelMap, &(*nextVoxel), motion);
    CD$recurse(voxelMap, seen, &((struct CD$Vector2D[1]){($t2 = ((struct CD$Vector2D *)($t0 = &(*nextVoxel)))->class$->minus, $t2($t0, &CD$horizontal))})[0], motion);
    CD$recurse(voxelMap, seen, &((struct CD$Vector2D[1]){($t2 = ((struct CD$Vector2D *)($t0 = &(*nextVoxel)))->class$->plus, $t2($t0, &CD$horizontal))})[0], motion);
    CD$recurse(voxelMap, seen, &((struct CD$Vector2D[1]){($t2 = ((struct CD$Vector2D *)($t0 = &(*nextVoxel)))->class$->minus, $t2($t0, &CD$vertical))})[0], motion);
    CD$recurse(voxelMap, seen, &((struct CD$Vector2D[1]){($t2 = ((struct CD$Vector2D *)($t0 = &(*nextVoxel)))->class$->plus, $t2($t0, &CD$vertical))})[0], motion);
    CD$recurse(voxelMap, seen, &((struct CD$Vector2D[1]){($t2 = ((struct CD$Vector2D *)($t0 = &((struct CD$Vector2D[1]){($t4 = ((struct CD$Vector2D *)($t3 = &(*nextVoxel)))->class$->minus, $t4($t3, &CD$horizontal))})[0]))->class$->minus, $t2($t0, &CD$vertical))})[0], motion);
    CD$recurse(voxelMap, seen, &((struct CD$Vector2D[1]){($t2 = ((struct CD$Vector2D *)($t0 = &((struct CD$Vector2D[1]){($t4 = ((struct CD$Vector2D *)($t3 = &(*nextVoxel)))->class$->minus, $t4($t3, &CD$horizontal))})[0]))->class$->plus, $t2($t0, &CD$vertical))})[0], motion);
    CD$recurse(voxelMap, seen, &((struct CD$Vector2D[1]){($t2 = ((struct CD$Vector2D *)($t0 = &((struct CD$Vector2D[1]){($t4 = ((struct CD$Vector2D *)($t3 = &(*nextVoxel)))->class$->plus, $t4($t3, &CD$horizontal))})[0]))->class$->minus, $t2($t0, &CD$vertical))})[0], motion);
    CD$recurse(voxelMap, seen, &((struct CD$Vector2D[1]){($t2 = ((struct CD$Vector2D *)($t0 = &((struct CD$Vector2D[1]){($t4 = ((struct CD$Vector2D *)($t3 = &(*nextVoxel)))->class$->plus, $t4($t3, &CD$horizontal))})[0]))->class$->plus, $t2($t0, &CD$vertical))})[0], motion);
}

struct CD$Vector2D CD$voxelHash(struct CD$Vector3D * position) {
    int32_t xDiv;
    int32_t yDiv;
    double x;
    double y;
    struct CD$Vector2D res;
    xDiv = 0;
    yDiv = 0;
    x = 0;
    y = 0;
    memset(&res,0,sizeof(res));
    CD$Vector2D$init$(&res);
    xDiv = (int32_t)floorf(((*position).x / 2.0000000e+00));
    yDiv = (int32_t)floorf(((*position).y / 2.0000000e+00));
    x = (2.0000000e+00 * (double)xDiv);
    y = (2.0000000e+00 * (double)yDiv);
    if( ((*position).x < 0.0000000e+00) ) {
        x = (x - 2.0000000e+00);
    } 
    if( ((*position).y < 0.0000000e+00) ) {
        y = (y - 2.0000000e+00);
    } 
    res.x = x;
    res.y = y;
    return res;
}

void CD$drawMotionOnVoxelMap(struct som$RedBlackTree$14446907c4$RedBlackTree * voxelMap, struct CD$Motion * motion) {
    struct som$RedBlackTree$3520dd22aa$RedBlackTree * seen;
    seen = 0;
    seen = som$RedBlackTree$3520dd22aa$create(CD$compareVector2D);
    CD$recurse(voxelMap, seen, &((struct CD$Vector2D[1]){CD$voxelHash(&(*motion).posOne)})[0], motion);
}

struct CD$Vector3D$Class$ CD$Vector3D$class$ = { 
    0,
    CD$Vector3D$plus,
    CD$Vector3D$minus,
    CD$Vector3D$times,
    CD$Vector3D$dot,
    CD$Vector3D$squaredMagnitude,
    CD$Vector3D$magnitude,
};

struct CD$CollisionDetector$handleNewFrame$ForEachInterface$Class$ CD$CollisionDetector$handleNewFrame$ForEachInterface$class$ = { 
    &som$Interfaces$b3330a6a65$ForEachInterface$class$,
    CD$CollisionDetector$handleNewFrame$ForEachInterface$apply,
};

struct CD$CollisionDetector$Class$ CD$CollisionDetector$class$ = { 
    0,
    CD$CollisionDetector$handleNewFrame,
};

struct CD$Simulator$Class$ CD$Simulator$class$ = { 
    0,
    CD$Simulator$simulate,
};

struct CD$reduceCollisionSet$ForEachInterface$Class$ CD$reduceCollisionSet$ForEachInterface$class$ = { 
    &som$Interfaces$d1517c3aa3$ForEachInterface$class$,
    CD$reduceCollisionSet$ForEachInterface$apply,
};

struct CD$CD$Class$ CD$CD$class$ = { 
    &Benchmark$Benchmark$class$,
    CD$CD$benchmark,
    CD$CD$verifyResult,
    CD$CD$innerBenchmarkLoop,
};

struct CD$Vector2D$Class$ CD$Vector2D$class$ = { 
    0,
    CD$Vector2D$plus,
    CD$Vector2D$minus,
};

struct CD$CallSign$Class$ CD$CallSign$class$ = { 
    0,
};

struct CD$Motion$Class$ CD$Motion$class$ = { 
    0,
    CD$Motion$delta,
    CD$Motion$findIntersection,
};

struct CD$Aircraft$Class$ CD$Aircraft$class$ = { 
    0,
};

struct CD$Collision$Class$ CD$Collision$class$ = { 
    0,
};

static int initDone$ = 0;
void CD$init$(void) {
    if(initDone$) return; else initDone$ = 1;
    Benchmark$init$();
    Out$init$();
    Math$init$();
    som$Vector$a1be3657f7$init$();
    som$Vector$c235aac6c4$init$();
    som$Vector$e0832c0c14$init$();
    som$Vector$326bd6ec32$init$();
    som$Vector$d8f2cdf460$init$();
    som$RedBlackTree$80265c2f3b$init$();
    som$RedBlackTree$14446907c4$init$();
    som$RedBlackTree$3520dd22aa$init$();
    som$RedBlackTree$adef759a05$init$();
    memset(&CD$horizontal,0,sizeof(CD$horizontal));
    CD$Vector2D$init$(&CD$horizontal);
    memset(&CD$vertical,0,sizeof(CD$vertical));
    CD$Vector2D$init$(&CD$vertical);
    CD$horizontal.x = 2.0000000e+00;
    CD$horizontal.y = 0.0000000e+00;
    CD$vertical.x = 0.0000000e+00;
    CD$vertical.y = 2.0000000e+00;
}
OBX$Cmd CD$cmd$(const char* name) {
    if( name == 0 ) return CD$init$;
    return 0;
}
