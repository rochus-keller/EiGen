// Generated by Oberon+ IDE (Mono) 0.9.106 on 2024-07-13T01:26:30

#include "DeltaBlue.h"

void DeltaBlue$AbstractConstraint$inputsKnown$TI$init$(struct DeltaBlue$AbstractConstraint$inputsKnown$TI* inst){
    inst->class$ = &DeltaBlue$AbstractConstraint$inputsKnown$TI$class$;
}
void DeltaBlue$Variable$init$(struct DeltaBlue$Variable* inst){
    inst->class$ = &DeltaBlue$Variable$class$;
}
void DeltaBlue$Planner$removePropagateFrom$IC$init$(struct DeltaBlue$Planner$removePropagateFrom$IC* inst){
    inst->class$ = &DeltaBlue$Planner$removePropagateFrom$IC$class$;
}
void DeltaBlue$StayConstraint$init$(struct DeltaBlue$StayConstraint* inst){
    inst->class$ = &DeltaBlue$StayConstraint$class$;
}
void DeltaBlue$BinaryConstraint$init$(struct DeltaBlue$BinaryConstraint* inst){
    inst->class$ = &DeltaBlue$BinaryConstraint$class$;
}
void DeltaBlue$EqualityConstraint$init$(struct DeltaBlue$EqualityConstraint* inst){
    inst->class$ = &DeltaBlue$EqualityConstraint$class$;
}
void DeltaBlue$Strength$init$(struct DeltaBlue$Strength* inst){
    inst->class$ = &DeltaBlue$Strength$class$;
}
void DeltaBlue$AbstractConstraint$satisfy$FI$init$(struct DeltaBlue$AbstractConstraint$satisfy$FI* inst){
    inst->class$ = &DeltaBlue$AbstractConstraint$satisfy$FI$class$;
}
void DeltaBlue$EditConstraint$init$(struct DeltaBlue$EditConstraint* inst){
    inst->class$ = &DeltaBlue$EditConstraint$class$;
}
void DeltaBlue$Planner$init$(struct DeltaBlue$Planner* inst){
    inst->class$ = &DeltaBlue$Planner$class$;
}
void DeltaBlue$ScaleConstraint$init$(struct DeltaBlue$ScaleConstraint* inst){
    inst->class$ = &DeltaBlue$ScaleConstraint$class$;
}
void DeltaBlue$DeltaBlue$init$(struct DeltaBlue$DeltaBlue* inst){
    inst->class$ = &DeltaBlue$DeltaBlue$class$;
}
void DeltaBlue$Sym$init$(struct DeltaBlue$Sym* inst){
    inst->class$ = &DeltaBlue$Sym$class$;
}
void DeltaBlue$Planner$removePropagateFrom$FI$init$(struct DeltaBlue$Planner$removePropagateFrom$FI* inst){
    inst->class$ = &DeltaBlue$Planner$removePropagateFrom$FI$class$;
}
void DeltaBlue$UnaryConstraint$init$(struct DeltaBlue$UnaryConstraint* inst){
    inst->class$ = &DeltaBlue$UnaryConstraint$class$;
}
void DeltaBlue$Plan$init$(struct DeltaBlue$Plan* inst){
    inst->class$ = &DeltaBlue$Plan$class$;
}
void DeltaBlue$AbstractConstraint$init$(struct DeltaBlue$AbstractConstraint* inst){
    inst->class$ = &DeltaBlue$AbstractConstraint$class$;
}
struct DeltaBlue$Sym * DeltaBlue$ABSOLUTE_STRONGEST = 0;
struct DeltaBlue$Sym * DeltaBlue$REQUIRED = 0;
struct DeltaBlue$Sym * DeltaBlue$STRONG_PREFERRED = 0;
struct DeltaBlue$Sym * DeltaBlue$PREFERRED = 0;
struct DeltaBlue$Sym * DeltaBlue$STRONG_DEFAULT = 0;
struct DeltaBlue$Sym * DeltaBlue$DEFAULT = 0;
struct DeltaBlue$Sym * DeltaBlue$WEAK_DEFAULT = 0;
struct DeltaBlue$Sym * DeltaBlue$ABSOLUTE_WEAKEST = 0;
struct DeltaBlue$Strength * DeltaBlue$absoluteWeakest = 0;
struct DeltaBlue$Strength * DeltaBlue$required = 0;
struct som$Dictionary2$5c466e54b6$Dictionary * DeltaBlue$strengthTable = 0;
struct som$Dictionary2$1fc4d3b22f$Dictionary * DeltaBlue$strengthConstant = 0;
struct DeltaBlue$DeltaBlue * DeltaBlue$create() {
    struct DeltaBlue$DeltaBlue * d;
    struct DeltaBlue$DeltaBlue * $t0;
    d = 0;
    $t0 = OBX$Alloc(sizeof(struct DeltaBlue$DeltaBlue));
    memset($t0,0,sizeof(struct DeltaBlue$DeltaBlue));
    d = $t0;
    DeltaBlue$DeltaBlue$init$($t0);
    return d;
}

struct Benchmark$Result * DeltaBlue$DeltaBlue$benchmark(void* this) {
    struct DeltaBlue$DeltaBlue* this$ = this;
    assert(0);
    return 0;
}

uint8_t DeltaBlue$DeltaBlue$verifyResult(void* this, struct Benchmark$Result * result) {
    struct DeltaBlue$DeltaBlue* this$ = this;
    assert(0);
    return 0;
}

uint8_t DeltaBlue$DeltaBlue$innerBenchmarkLoop(void* this, int32_t innerIterations) {
    struct DeltaBlue$DeltaBlue* this$ = this;
    DeltaBlue$chainTest(innerIterations);
    DeltaBlue$projectionTest(innerIterations);
    return 1;
}

struct DeltaBlue$Sym * DeltaBlue$createSym(int32_t hash) {
    struct DeltaBlue$Sym * s;
    struct DeltaBlue$Sym * $t0;
    s = 0;
    $t0 = OBX$Alloc(sizeof(struct DeltaBlue$Sym));
    memset($t0,0,sizeof(struct DeltaBlue$Sym));
    s = $t0;
    DeltaBlue$Sym$init$($t0);
    (*s).hash = hash;
    return s;
}

int32_t DeltaBlue$symHash(struct DeltaBlue$Sym * * k) {
    return (*(*k)).hash;
}

struct DeltaBlue$Strength * DeltaBlue$createStrength(struct DeltaBlue$Sym * symbolicValue) {
    struct DeltaBlue$Strength * s;
    struct DeltaBlue$Strength * $t0;
    void* $t1;
    int32_t (* $t2)(void*, struct DeltaBlue$Sym * *);
    s = 0;
    $t0 = OBX$Alloc(sizeof(struct DeltaBlue$Strength));
    memset($t0,0,sizeof(struct DeltaBlue$Strength));
    s = $t0;
    DeltaBlue$Strength$init$($t0);
    (*s).symbolicValue = symbolicValue;
    (*s).arithmeticValue = ($t2 = ((struct som$Dictionary2$5c466e54b6$Dictionary *)($t1 = &(*DeltaBlue$strengthTable)))->class$->at, $t2($t1, &symbolicValue));
    return s;
}

uint8_t DeltaBlue$Strength$sameAs(void* this, struct DeltaBlue$Strength * s) {
    struct DeltaBlue$Strength* this$ = this;
    return ((*this$).arithmeticValue == (*s).arithmeticValue);
}

uint8_t DeltaBlue$Strength$stronger(void* this, struct DeltaBlue$Strength * s) {
    struct DeltaBlue$Strength* this$ = this;
    return ((*this$).arithmeticValue < (*s).arithmeticValue);
}

uint8_t DeltaBlue$Strength$weaker(void* this, struct DeltaBlue$Strength * s) {
    struct DeltaBlue$Strength* this$ = this;
    return ((*this$).arithmeticValue > (*s).arithmeticValue);
}

struct DeltaBlue$Strength * DeltaBlue$Strength$strongest(void* this, struct DeltaBlue$Strength * s) {
    struct DeltaBlue$Strength* this$ = this;
    void* $t0;
    uint8_t (* $t1)(void*, struct DeltaBlue$Strength *);
    if( ($t1 = ((struct DeltaBlue$Strength *)($t0 = &(*s)))->class$->stronger, $t1($t0, this$)) ) {
        return s;
    } else {
        return this$;
    }
    return 0;
}

struct DeltaBlue$Strength * DeltaBlue$Strength$weakest(void* this, struct DeltaBlue$Strength * s) {
    struct DeltaBlue$Strength* this$ = this;
    void* $t0;
    uint8_t (* $t1)(void*, struct DeltaBlue$Strength *);
    if( ($t1 = ((struct DeltaBlue$Strength *)($t0 = &(*s)))->class$->weaker, $t1($t0, this$)) ) {
        return s;
    } else {
        return this$;
    }
    return 0;
}

void DeltaBlue$AbstractConstraint$initAbstractConstraint(void* this, struct DeltaBlue$Sym * strength) {
    struct DeltaBlue$AbstractConstraint* this$ = this;
    void* $t0;
    struct DeltaBlue$Strength * (* $t1)(void*, struct DeltaBlue$Sym * *);
    (*this$).strength = ($t1 = ((struct som$Dictionary2$1fc4d3b22f$Dictionary *)($t0 = &(*DeltaBlue$strengthConstant)))->class$->at, $t1($t0, &strength));
}

uint8_t DeltaBlue$equalConstraint(struct DeltaBlue$AbstractConstraint * * lhs, struct DeltaBlue$AbstractConstraint * * rhs) {
    return ((void*)(*lhs) == (void*)(*rhs));
}

uint8_t DeltaBlue$AbstractConstraint$isInput(void* this) {
    struct DeltaBlue$AbstractConstraint* this$ = this;
    return 0;
}

uint8_t DeltaBlue$AbstractConstraint$isSatisfied(void* this) {
    struct DeltaBlue$AbstractConstraint* this$ = this;
    return 0;
}

void DeltaBlue$AbstractConstraint$addToGraph(void* this) {
    struct DeltaBlue$AbstractConstraint* this$ = this;
}

void DeltaBlue$AbstractConstraint$removeFromGraph(void* this) {
    struct DeltaBlue$AbstractConstraint* this$ = this;
}

int DeltaBlue$AbstractConstraint$chooseMethod(void* this, int32_t mark) {
    struct DeltaBlue$AbstractConstraint* this$ = this;
    return 0;
}

void DeltaBlue$AbstractConstraint$execute(void* this) {
    struct DeltaBlue$AbstractConstraint* this$ = this;
}

void DeltaBlue$AbstractConstraint$addConstraint(void* this, struct DeltaBlue$Planner * planner) {
    struct DeltaBlue$AbstractConstraint* this$ = this;
    void* $t0;
    void (* $t1)(void*);
    void (* $t2)(void*, struct DeltaBlue$AbstractConstraint *);
    ($t1 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*this$)))->class$->addToGraph, $t1($t0));
    ($t2 = ((struct DeltaBlue$Planner *)($t0 = &(*planner)))->class$->incrementalAdd, $t2($t0, this$));
}

void DeltaBlue$AbstractConstraint$destroyConstraint(void* this, struct DeltaBlue$Planner * planner) {
    struct DeltaBlue$AbstractConstraint* this$ = this;
    void* $t0;
    uint8_t (* $t1)(void*);
    void* $t2;
    void (* $t3)(void*, struct DeltaBlue$AbstractConstraint *);
    void (* $t4)(void*);
    if( ($t1 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*this$)))->class$->isSatisfied, $t1($t0)) ) {
        ($t3 = ((struct DeltaBlue$Planner *)($t2 = &(*planner)))->class$->incrementalRemove, $t3($t2, this$));
    } 
    ($t4 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*this$)))->class$->removeFromGraph, $t4($t0));
}

void DeltaBlue$AbstractConstraint$inputsDo(void* this, struct som$Interfaces$7850aff62d$ForEachInterfaceRW * fn) {
    struct DeltaBlue$AbstractConstraint* this$ = this;
}

uint8_t DeltaBlue$AbstractConstraint$inputsHasOne(void* this, struct som$Interfaces$7850aff62d$TestInterface * fn) {
    struct DeltaBlue$AbstractConstraint* this$ = this;
    return 0;
}

uint8_t DeltaBlue$AbstractConstraint$inputsKnown(void* this, int32_t mark) {
    struct DeltaBlue$AbstractConstraint* this$ = this;
    struct DeltaBlue$AbstractConstraint$inputsKnown$TI i;
    void* $t0;
    uint8_t (* $t1)(void*, struct som$Interfaces$7850aff62d$TestInterface *);
    memset(&i,0,sizeof(i));
    DeltaBlue$AbstractConstraint$inputsKnown$TI$init$(&i);
    i.mark = mark;
    return (!($t1 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*this$)))->class$->inputsHasOne, $t1($t0, ((struct som$Interfaces$7850aff62d$TestInterface *)&i))));
}

uint8_t DeltaBlue$AbstractConstraint$inputsKnown$TI$test(void* this, struct DeltaBlue$Variable * * v) {
    struct DeltaBlue$AbstractConstraint$inputsKnown$TI* this$ = this;
    return (!((((*(*v)).mark == (*this$).mark) || (*(*v)).stay) || ((void*)(*(*v)).determinedBy == (void*)0)));
}

void DeltaBlue$AbstractConstraint$markUnsatisfied(void* this) {
    struct DeltaBlue$AbstractConstraint* this$ = this;
}

struct DeltaBlue$Variable * DeltaBlue$AbstractConstraint$getOutput(void* this) {
    struct DeltaBlue$AbstractConstraint* this$ = this;
    return 0;
}

void DeltaBlue$AbstractConstraint$recalculate(void* this) {
    struct DeltaBlue$AbstractConstraint* this$ = this;
}

struct DeltaBlue$AbstractConstraint * DeltaBlue$AbstractConstraint$satisfy(void* this, int32_t mark, struct DeltaBlue$Planner * planner) {
    struct DeltaBlue$AbstractConstraint* this$ = this;
    struct DeltaBlue$AbstractConstraint * overridden;
    struct DeltaBlue$Variable * out;
    struct DeltaBlue$AbstractConstraint$satisfy$FI iter;
    int dummy;
    void* $t0;
    int (* $t1)(void*, int32_t);
    uint8_t (* $t2)(void*);
    void (* $t3)(void*, struct som$Interfaces$7850aff62d$ForEachInterfaceRW *);
    struct DeltaBlue$Variable * (* $t4)(void*);
    void (* $t5)(void*);
    uint8_t (* $t6)(void*, struct DeltaBlue$AbstractConstraint *, int32_t);
    uint8_t (* $t7)(void*, struct DeltaBlue$Strength *);
    overridden = 0;
    out = 0;
    memset(&iter,0,sizeof(iter));
    DeltaBlue$AbstractConstraint$satisfy$FI$init$(&iter);
    dummy = 0;
    dummy = ($t1 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*this$)))->class$->chooseMethod, $t1($t0, mark));
    if( ($t2 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*this$)))->class$->isSatisfied, $t2($t0)) ) {
        iter.mark = mark;
        ($t3 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*this$)))->class$->inputsDo, $t3($t0, ((struct som$Interfaces$7850aff62d$ForEachInterfaceRW *)&iter)));
        out = ($t4 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*this$)))->class$->getOutput, $t4($t0));
        overridden = (*out).determinedBy;
        if( ((void*)overridden != (void*)0) ) {
            ($t5 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*overridden)))->class$->markUnsatisfied, $t5($t0));
        } 
        (*out).determinedBy = this$;
        if( (!($t6 = ((struct DeltaBlue$Planner *)($t0 = &(*planner)))->class$->addPropagate, $t6($t0, this$, mark))) ) {
            assert(0);
        } 
        (*out).mark = mark;
    } else {
        overridden = 0;
        if( ($t7 = ((struct DeltaBlue$Strength *)($t0 = &(*(*this$).strength)))->class$->sameAs, $t7($t0, DeltaBlue$required)) ) {
            assert(0);
        } 
    }
    return overridden;
}

void DeltaBlue$AbstractConstraint$satisfy$FI$apply(void* this, struct DeltaBlue$Variable * * v) {
    struct DeltaBlue$AbstractConstraint$satisfy$FI* this$ = this;
    (*(*v)).mark = (*this$).mark;
}

struct DeltaBlue$Variable * DeltaBlue$value(int32_t aValue) {
    struct DeltaBlue$Variable * v;
    struct DeltaBlue$Variable * $t0;
    v = 0;
    $t0 = OBX$Alloc(sizeof(struct DeltaBlue$Variable));
    memset($t0,0,sizeof(struct DeltaBlue$Variable));
    v = $t0;
    DeltaBlue$Variable$init$($t0);
    (*v).value = aValue;
    (*v).constraints = som$Vector$ad6c2c594a$create();
    (*v).walkStrength = DeltaBlue$absoluteWeakest;
    (*v).stay = 1;
    (*v).mark = 0;
    return v;
}

void DeltaBlue$Variable$addConstraint(void* this, struct DeltaBlue$AbstractConstraint * c) {
    struct DeltaBlue$Variable* this$ = this;
    void* $t0;
    void (* $t1)(void*, struct DeltaBlue$AbstractConstraint * *);
    ($t1 = ((struct som$Vector$ad6c2c594a$Vector *)($t0 = &(*(*this$).constraints)))->class$->append, $t1($t0, &c));
}

void DeltaBlue$Variable$removeConstraint(void* this, struct DeltaBlue$AbstractConstraint * c) {
    struct DeltaBlue$Variable* this$ = this;
    uint8_t _;
    void* $t0;
    uint8_t (* $t1)(void*, struct DeltaBlue$AbstractConstraint * *, uint8_t (*)(struct DeltaBlue$AbstractConstraint * *, struct DeltaBlue$AbstractConstraint * *));
    _ = 0;
    _ = ($t1 = ((struct som$Vector$ad6c2c594a$Vector *)($t0 = &(*(*this$).constraints)))->class$->remove, $t1($t0, &c, DeltaBlue$equalConstraint));
    if( ((void*)(*this$).determinedBy == (void*)c) ) {
        (*this$).determinedBy = 0;
    } 
}

void DeltaBlue$Plan$execute(void* this) {
    struct DeltaBlue$Plan* this$ = this;
    int32_t i;
    void* $t0;
    int32_t (* $t1)(void*);
    void* $t2;
    void (* $t3)(void*);
    void* $t4;
    struct DeltaBlue$AbstractConstraint * (* $t5)(void*, int32_t);
    i = 0;
    i = 0;
    while(1) {
        if( (i <= (($t1 = ((struct som$Vector$ad6c2c594a$Vector *)($t0 = &(*(*this$).plan)))->class$->getSize, $t1($t0)) - 1)) ) {
            ($t3 = ((struct DeltaBlue$AbstractConstraint *)($t2 = &(*($t5 = ((struct som$Vector$ad6c2c594a$Vector *)($t4 = &(*(*this$).plan)))->class$->at, $t5($t4, i)))))->class$->execute, $t3($t2));
            i = (i + 1);
        } else {
            break;
        }
    }
}

struct DeltaBlue$Planner * DeltaBlue$createPlanner() {
    struct DeltaBlue$Planner * p;
    struct DeltaBlue$Planner * $t0;
    p = 0;
    $t0 = OBX$Alloc(sizeof(struct DeltaBlue$Planner));
    memset($t0,0,sizeof(struct DeltaBlue$Planner));
    p = $t0;
    DeltaBlue$Planner$init$($t0);
    (*p).currentMark = 1;
    return p;
}

void DeltaBlue$Planner$incrementalAdd(void* this, struct DeltaBlue$AbstractConstraint * c) {
    struct DeltaBlue$Planner* this$ = this;
    int32_t mark;
    struct DeltaBlue$AbstractConstraint * overridden;
    void* $t0;
    int32_t (* $t1)(void*);
    struct DeltaBlue$AbstractConstraint * (* $t2)(void*, int32_t, struct DeltaBlue$Planner *);
    mark = 0;
    overridden = 0;
    mark = ($t1 = ((struct DeltaBlue$Planner *)($t0 = &(*this$)))->class$->newMark, $t1($t0));
    overridden = ($t2 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*c)))->class$->satisfy, $t2($t0, mark, this$));
    while(1) {
        if( ((void*)overridden != (void*)0) ) {
            overridden = ($t2 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*overridden)))->class$->satisfy, $t2($t0, mark, this$));
        } else {
            break;
        }
    }
}

void DeltaBlue$Planner$incrementalRemove(void* this, struct DeltaBlue$AbstractConstraint * c) {
    struct DeltaBlue$Planner* this$ = this;
    struct DeltaBlue$Variable * out;
    struct som$Vector$ad6c2c594a$Vector * unsatisfied;
    int32_t i;
    void* $t0;
    struct DeltaBlue$Variable * (* $t1)(void*);
    void (* $t2)(void*);
    struct som$Vector$ad6c2c594a$Vector * (* $t3)(void*, struct DeltaBlue$Variable *);
    int32_t (* $t4)(void*);
    void* $t5;
    void (* $t6)(void*, struct DeltaBlue$AbstractConstraint *);
    void* $t7;
    struct DeltaBlue$AbstractConstraint * (* $t8)(void*, int32_t);
    out = 0;
    unsatisfied = 0;
    i = 0;
    out = ($t1 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*c)))->class$->getOutput, $t1($t0));
    ($t2 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*c)))->class$->markUnsatisfied, $t2($t0));
    ($t2 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*c)))->class$->removeFromGraph, $t2($t0));
    unsatisfied = ($t3 = ((struct DeltaBlue$Planner *)($t0 = &(*this$)))->class$->removePropagateFrom, $t3($t0, out));
    i = 0;
    while(1) {
        if( (i <= (($t4 = ((struct som$Vector$ad6c2c594a$Vector *)($t0 = &(*unsatisfied)))->class$->getSize, $t4($t0)) - 1)) ) {
            ($t6 = ((struct DeltaBlue$Planner *)($t5 = &(*this$)))->class$->incrementalAdd, $t6($t5, ($t8 = ((struct som$Vector$ad6c2c594a$Vector *)($t7 = &(*unsatisfied)))->class$->at, $t8($t7, i))));
            i = (i + 1);
        } else {
            break;
        }
    }
}

struct DeltaBlue$Plan * DeltaBlue$Planner$extractPlanFromConstraints(void* this, struct som$Vector$ad6c2c594a$Vector * constraints) {
    struct DeltaBlue$Planner* this$ = this;
    struct som$Vector$ad6c2c594a$Vector * sources;
    int32_t i;
    struct DeltaBlue$AbstractConstraint * c;
    void* $t0;
    int32_t (* $t1)(void*);
    void* $t2;
    struct DeltaBlue$AbstractConstraint * (* $t3)(void*, int32_t);
    uint8_t (* $t4)(void*);
    uint8_t (* $t5)(void*);
    void* $t6;
    void (* $t7)(void*, struct DeltaBlue$AbstractConstraint * *);
    struct DeltaBlue$Plan * (* $t8)(void*, struct som$Vector$ad6c2c594a$Vector *);
    sources = 0;
    i = 0;
    c = 0;
    sources = som$Vector$ad6c2c594a$create();
    i = 0;
    while(1) {
        if( (i <= (($t1 = ((struct som$Vector$ad6c2c594a$Vector *)($t0 = &(*constraints)))->class$->getSize, $t1($t0)) - 1)) ) {
            c = ($t3 = ((struct som$Vector$ad6c2c594a$Vector *)($t2 = &(*constraints)))->class$->at, $t3($t2, i));
            if( (($t4 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*c)))->class$->isInput, $t4($t0)) && ($t5 = ((struct DeltaBlue$AbstractConstraint *)($t2 = &(*c)))->class$->isSatisfied, $t5($t2))) ) {
                ($t7 = ((struct som$Vector$ad6c2c594a$Vector *)($t6 = &(*sources)))->class$->append, $t7($t6, &c));
            } 
            i = (i + 1);
        } else {
            break;
        }
    }
    return ($t8 = ((struct DeltaBlue$Planner *)($t0 = &(*this$)))->class$->makePlan, $t8($t0, sources));
}

struct DeltaBlue$Plan * DeltaBlue$Planner$makePlan(void* this, struct som$Vector$ad6c2c594a$Vector * sources) {
    struct DeltaBlue$Planner* this$ = this;
    int32_t mark;
    struct DeltaBlue$Plan * plan;
    struct som$Vector$ad6c2c594a$Vector * todo;
    struct DeltaBlue$AbstractConstraint * c;
    void* $t0;
    int32_t (* $t1)(void*);
    struct DeltaBlue$Plan * $t2;
    uint8_t (* $t3)(void*);
    void* $t4;
    struct DeltaBlue$AbstractConstraint * (* $t5)(void*);
    struct DeltaBlue$Variable * (* $t6)(void*);
    uint8_t (* $t7)(void*, int32_t);
    void* $t8;
    void (* $t9)(void*, struct DeltaBlue$AbstractConstraint * *);
    void (* $t10)(void*, struct DeltaBlue$Variable *, struct som$Vector$ad6c2c594a$Vector *);
    mark = 0;
    plan = 0;
    todo = 0;
    c = 0;
    mark = ($t1 = ((struct DeltaBlue$Planner *)($t0 = &(*this$)))->class$->newMark, $t1($t0));
    $t2 = OBX$Alloc(sizeof(struct DeltaBlue$Plan));
    memset($t2,0,sizeof(struct DeltaBlue$Plan));
    plan = $t2;
    DeltaBlue$Plan$init$($t2);
    (*plan).plan = som$Vector$ad6c2c594a$create();
    todo = sources;
    while(1) {
        if( (!($t3 = ((struct som$Vector$ad6c2c594a$Vector *)($t0 = &(*todo)))->class$->isEmpty, $t3($t0))) ) {
            c = ($t5 = ((struct som$Vector$ad6c2c594a$Vector *)($t4 = &(*todo)))->class$->removeFirst, $t5($t4));
            if( (((*($t6 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*c)))->class$->getOutput, $t6($t0))).mark != mark) && ($t7 = ((struct DeltaBlue$AbstractConstraint *)($t4 = &(*c)))->class$->inputsKnown, $t7($t4, mark))) ) {
                ($t9 = ((struct som$Vector$ad6c2c594a$Vector *)($t8 = &(*(*plan).plan)))->class$->append, $t9($t8, &c));
                (*($t6 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*c)))->class$->getOutput, $t6($t0))).mark = mark;
                ($t10 = ((struct DeltaBlue$Planner *)($t0 = &(*this$)))->class$->addConstraintsConsumingTo, $t10($t0, ($t6 = ((struct DeltaBlue$AbstractConstraint *)($t4 = &(*c)))->class$->getOutput, $t6($t4)), todo));
            } 
        } else {
            break;
        }
    }
    return plan;
}

void DeltaBlue$Planner$propagateFrom(void* this, struct DeltaBlue$Variable * v) {
    struct DeltaBlue$Planner* this$ = this;
    struct som$Vector$ad6c2c594a$Vector * todo;
    struct DeltaBlue$AbstractConstraint * c;
    void* $t0;
    void (* $t1)(void*, struct DeltaBlue$Variable *, struct som$Vector$ad6c2c594a$Vector *);
    uint8_t (* $t2)(void*);
    void* $t3;
    struct DeltaBlue$AbstractConstraint * (* $t4)(void*);
    void (* $t5)(void*);
    struct DeltaBlue$Variable * (* $t6)(void*);
    todo = 0;
    c = 0;
    todo = som$Vector$ad6c2c594a$create();
    ($t1 = ((struct DeltaBlue$Planner *)($t0 = &(*this$)))->class$->addConstraintsConsumingTo, $t1($t0, v, todo));
    while(1) {
        if( (!($t2 = ((struct som$Vector$ad6c2c594a$Vector *)($t0 = &(*todo)))->class$->isEmpty, $t2($t0))) ) {
            c = ($t4 = ((struct som$Vector$ad6c2c594a$Vector *)($t3 = &(*todo)))->class$->removeFirst, $t4($t3));
            ($t5 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*c)))->class$->execute, $t5($t0));
            ($t1 = ((struct DeltaBlue$Planner *)($t0 = &(*this$)))->class$->addConstraintsConsumingTo, $t1($t0, ($t6 = ((struct DeltaBlue$AbstractConstraint *)($t3 = &(*c)))->class$->getOutput, $t6($t3)), todo));
        } else {
            break;
        }
    }
}

void DeltaBlue$Planner$addConstraintsConsumingTo(void* this, struct DeltaBlue$Variable * v, struct som$Vector$ad6c2c594a$Vector * coll) {
    struct DeltaBlue$Planner* this$ = this;
    struct DeltaBlue$AbstractConstraint * determiningC;
    struct DeltaBlue$AbstractConstraint * c;
    int32_t i;
    void* $t0;
    int32_t (* $t1)(void*);
    void* $t2;
    struct DeltaBlue$AbstractConstraint * (* $t3)(void*, int32_t);
    uint8_t (* $t4)(void*);
    void (* $t5)(void*, struct DeltaBlue$AbstractConstraint * *);
    determiningC = 0;
    c = 0;
    i = 0;
    determiningC = (*v).determinedBy;
    i = 0;
    while(1) {
        if( (i <= (($t1 = ((struct som$Vector$ad6c2c594a$Vector *)($t0 = &(*(*v).constraints)))->class$->getSize, $t1($t0)) - 1)) ) {
            c = ($t3 = ((struct som$Vector$ad6c2c594a$Vector *)($t2 = &(*(*v).constraints)))->class$->at, $t3($t2, i));
            if( (((void*)c != (void*)determiningC) && ($t4 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*c)))->class$->isSatisfied, $t4($t0))) ) {
                ($t5 = ((struct som$Vector$ad6c2c594a$Vector *)($t2 = &(*coll)))->class$->append, $t5($t2, &c));
            } 
            i = (i + 1);
        } else {
            break;
        }
    }
}

uint8_t DeltaBlue$Planner$addPropagate(void* this, struct DeltaBlue$AbstractConstraint * c, int32_t mark) {
    struct DeltaBlue$Planner* this$ = this;
    struct som$Vector$ad6c2c594a$Vector * todo;
    struct DeltaBlue$AbstractConstraint * d;
    void* $t0;
    uint8_t (* $t1)(void*);
    void* $t2;
    struct DeltaBlue$AbstractConstraint * (* $t3)(void*);
    struct DeltaBlue$Variable * (* $t4)(void*);
    void (* $t5)(void*, struct DeltaBlue$AbstractConstraint *);
    void (* $t6)(void*);
    void (* $t7)(void*, struct DeltaBlue$Variable *, struct som$Vector$ad6c2c594a$Vector *);
    todo = 0;
    d = 0;
    todo = som$Vector$ad6c2c594a$createWithElement(&c);
    while(1) {
        if( (!($t1 = ((struct som$Vector$ad6c2c594a$Vector *)($t0 = &(*todo)))->class$->isEmpty, $t1($t0))) ) {
            d = ($t3 = ((struct som$Vector$ad6c2c594a$Vector *)($t2 = &(*todo)))->class$->removeFirst, $t3($t2));
            if( ((*($t4 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*d)))->class$->getOutput, $t4($t0))).mark == mark) ) {
                ($t5 = ((struct DeltaBlue$Planner *)($t2 = &(*this$)))->class$->incrementalRemove, $t5($t2, c));
                return 0;
            } 
            ($t6 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*d)))->class$->recalculate, $t6($t0));
            ($t7 = ((struct DeltaBlue$Planner *)($t0 = &(*this$)))->class$->addConstraintsConsumingTo, $t7($t0, ($t4 = ((struct DeltaBlue$AbstractConstraint *)($t2 = &(*d)))->class$->getOutput, $t4($t2)), todo));
        } else {
            break;
        }
    }
    return 1;
}

void DeltaBlue$Planner$change(void* this, struct DeltaBlue$Variable * v, int32_t newValue) {
    struct DeltaBlue$Planner* this$ = this;
    struct DeltaBlue$EditConstraint * editC;
    struct som$Vector$ad6c2c594a$Vector * editV;
    struct DeltaBlue$Plan * plan;
    int32_t i;
    void* $t0;
    struct DeltaBlue$Plan * (* $t1)(void*, struct som$Vector$ad6c2c594a$Vector *);
    void (* $t2)(void*);
    void (* $t3)(void*, struct DeltaBlue$Planner *);
    editC = 0;
    editV = 0;
    plan = 0;
    i = 0;
    editC = DeltaBlue$createEditConstraint(v, DeltaBlue$PREFERRED, this$);
    editV = som$Vector$ad6c2c594a$createWithElement(((struct DeltaBlue$AbstractConstraint * *)&editC));
    plan = ($t1 = ((struct DeltaBlue$Planner *)($t0 = &(*this$)))->class$->extractPlanFromConstraints, $t1($t0, editV));
    i = 0;
    while(1) {
        if( (i <= (10 - 1)) ) {
            (*v).value = newValue;
            ($t2 = ((struct DeltaBlue$Plan *)($t0 = &(*plan)))->class$->execute, $t2($t0));
            i = (i + 1);
        } else {
            break;
        }
    }
    ($t3 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*editC)))->class$->destroyConstraint, $t3($t0, this$));
}

void DeltaBlue$Planner$constraintsConsuming(void* this, struct DeltaBlue$Variable * v, struct som$Interfaces$ad6c2c594a$ForEachInterface * fn) {
    struct DeltaBlue$Planner* this$ = this;
    struct DeltaBlue$AbstractConstraint * determiningC;
    struct DeltaBlue$AbstractConstraint * c;
    int32_t i;
    void* $t0;
    int32_t (* $t1)(void*);
    void* $t2;
    struct DeltaBlue$AbstractConstraint * (* $t3)(void*, int32_t);
    uint8_t (* $t4)(void*);
    void (* $t5)(void*, struct DeltaBlue$AbstractConstraint * *);
    determiningC = 0;
    c = 0;
    i = 0;
    determiningC = (*v).determinedBy;
    i = 0;
    while(1) {
        if( (i <= (($t1 = ((struct som$Vector$ad6c2c594a$Vector *)($t0 = &(*(*v).constraints)))->class$->getSize, $t1($t0)) - 1)) ) {
            c = ($t3 = ((struct som$Vector$ad6c2c594a$Vector *)($t2 = &(*(*v).constraints)))->class$->at, $t3($t2, i));
            if( (((void*)c != (void*)determiningC) && ($t4 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*c)))->class$->isSatisfied, $t4($t0))) ) {
                ($t5 = ((struct som$Interfaces$ad6c2c594a$ForEachInterface *)($t2 = &(*fn)))->class$->apply, $t5($t2, &c));
            } 
            i = (i + 1);
        } else {
            break;
        }
    }
}

int32_t DeltaBlue$Planner$newMark(void* this) {
    struct DeltaBlue$Planner* this$ = this;
    int32_t cur;
    cur = 0;
    cur = (*this$).currentMark;
    (*this$).currentMark++;
    return cur;
}

struct som$Vector$ad6c2c594a$Vector * DeltaBlue$Planner$removePropagateFrom(void* this, struct DeltaBlue$Variable * out) {
    struct DeltaBlue$Planner* this$ = this;
    struct som$Vector$ad6c2c594a$Vector * unsatisfied;
    struct som$Vector$7850aff62d$Vector * todo;
    struct DeltaBlue$Variable * v;
    int32_t i;
    struct DeltaBlue$AbstractConstraint * c;
    struct DeltaBlue$Planner$removePropagateFrom$FI iter1;
    struct DeltaBlue$Planner$removePropagateFrom$IC iter2;
    void* $t0;
    uint8_t (* $t1)(void*);
    void* $t2;
    struct DeltaBlue$Variable * (* $t3)(void*);
    int32_t (* $t4)(void*);
    struct DeltaBlue$AbstractConstraint * (* $t5)(void*, int32_t);
    void (* $t6)(void*, struct DeltaBlue$AbstractConstraint * *);
    void (* $t7)(void*, struct DeltaBlue$Variable *, struct som$Interfaces$ad6c2c594a$ForEachInterface *);
    void (* $t8)(void*, struct som$Interfaces$ad6c2c594a$Comparator *);
    unsatisfied = 0;
    todo = 0;
    v = 0;
    i = 0;
    c = 0;
    memset(&iter1,0,sizeof(iter1));
    DeltaBlue$Planner$removePropagateFrom$FI$init$(&iter1);
    memset(&iter2,0,sizeof(iter2));
    DeltaBlue$Planner$removePropagateFrom$IC$init$(&iter2);
    unsatisfied = som$Vector$ad6c2c594a$create();
    (*out).determinedBy = 0;
    (*out).walkStrength = DeltaBlue$absoluteWeakest;
    (*out).stay = 1;
    todo = som$Vector$7850aff62d$createWithElement(&out);
    while(1) {
        if( (!($t1 = ((struct som$Vector$7850aff62d$Vector *)($t0 = &(*todo)))->class$->isEmpty, $t1($t0))) ) {
            v = ($t3 = ((struct som$Vector$7850aff62d$Vector *)($t2 = &(*todo)))->class$->removeFirst, $t3($t2));
            i = 0;
            while(1) {
                if( (i <= (($t4 = ((struct som$Vector$ad6c2c594a$Vector *)($t0 = &(*(*v).constraints)))->class$->getSize, $t4($t0)) - 1)) ) {
                    c = ($t5 = ((struct som$Vector$ad6c2c594a$Vector *)($t2 = &(*(*v).constraints)))->class$->at, $t5($t2, i));
                    if( (!($t1 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*c)))->class$->isSatisfied, $t1($t0))) ) {
                        ($t6 = ((struct som$Vector$ad6c2c594a$Vector *)($t2 = &(*unsatisfied)))->class$->append, $t6($t2, &c));
                    } 
                    i = (i + 1);
                } else {
                    break;
                }
            }
            iter1.todo = todo;
            ($t7 = ((struct DeltaBlue$Planner *)($t0 = &(*this$)))->class$->constraintsConsuming, $t7($t0, v, ((struct som$Interfaces$ad6c2c594a$ForEachInterface *)&iter1)));
        } else {
            break;
        }
    }
    ($t8 = ((struct som$Vector$ad6c2c594a$Vector *)($t0 = &(*unsatisfied)))->class$->sort, $t8($t0, ((struct som$Interfaces$ad6c2c594a$Comparator *)&iter2)));
    return unsatisfied;
}

void DeltaBlue$Planner$removePropagateFrom$FI$apply(void* this, struct DeltaBlue$AbstractConstraint * * c) {
    struct DeltaBlue$Planner$removePropagateFrom$FI* this$ = this;
    void* $t0;
    void (* $t1)(void*);
    void (* $t2)(void*, struct DeltaBlue$Variable * *);
    void* $t3;
    struct DeltaBlue$Variable * (* $t4)(void*);
    ($t1 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*(*c))))->class$->recalculate, $t1($t0));
    ($t2 = ((struct som$Vector$7850aff62d$Vector *)($t0 = &(*(*this$).todo)))->class$->append, $t2($t0, &((struct DeltaBlue$Variable *[1]){($t4 = ((struct DeltaBlue$AbstractConstraint *)($t3 = &(*(*c))))->class$->getOutput, $t4($t3))})[0]));
}

int32_t DeltaBlue$Planner$removePropagateFrom$IC$compare(void* this, struct DeltaBlue$AbstractConstraint * * c1, struct DeltaBlue$AbstractConstraint * * c2) {
    struct DeltaBlue$Planner$removePropagateFrom$IC* this$ = this;
    void* $t0;
    uint8_t (* $t1)(void*, struct DeltaBlue$Strength *);
    if( ($t1 = ((struct DeltaBlue$Strength *)($t0 = &(*(*(*c1)).strength)))->class$->stronger, $t1($t0, (*(*c2)).strength)) ) {
        return (-1);
    } else {
        return 1;
    }
    return 0;
}

void DeltaBlue$chainTest(int32_t n) {
    struct DeltaBlue$Planner * planner;
    struct OBX$Array$1 vars;
    int32_t i;
    struct DeltaBlue$Variable * v1;
    struct DeltaBlue$Variable * v2;
    struct DeltaBlue$EqualityConstraint * dummy;
    struct DeltaBlue$EditConstraint * editC;
    struct som$Vector$ad6c2c594a$Vector * editV;
    struct DeltaBlue$Plan * plan;
    struct DeltaBlue$StayConstraint * dummy2;
    struct DeltaBlue$Variable * * $t0;
    struct OBX$Array$1* $t1;
    void* $t2;
    struct DeltaBlue$Plan * (* $t3)(void*, struct som$Vector$ad6c2c594a$Vector *);
    void (* $t4)(void*);
    void (* $t5)(void*, struct DeltaBlue$Planner *);
    planner = 0;
    memset(&vars,0,sizeof(vars));
    i = 0;
    v1 = 0;
    v2 = 0;
    dummy = 0;
    editC = 0;
    editV = 0;
    plan = 0;
    dummy2 = 0;
    planner = DeltaBlue$createPlanner();
    {int $0 = (n + 1), $n = $0, $s=sizeof(struct DeltaBlue$Variable *); $t0 = OBX$Alloc($s*$n); memset($t0,0,$s*$n); vars = (struct OBX$Array$1){$0, 1, $t0};};
    i = 0;
    while(1) {
        if( (i <= n) ) {
            (*($t1 = (&vars),&((struct DeltaBlue$Variable * *)$t1->$a)[i])) = DeltaBlue$value(0);
            i = (i + 1);
        } else {
            break;
        }
    }
    i = 0;
    while(1) {
        if( (i <= (n - 1)) ) {
            v1 = (*($t1 = (&vars),&((struct DeltaBlue$Variable * *)$t1->$a)[i]));
            v2 = (*($t1 = (&vars),&((struct DeltaBlue$Variable * *)$t1->$a)[(i + 1)]));
            dummy = DeltaBlue$createEqualityConstraint(v1, v2, DeltaBlue$REQUIRED, planner);
            i = (i + 1);
        } else {
            break;
        }
    }
    dummy2 = DeltaBlue$createStayConstraint((*($t1 = (&vars),&((struct DeltaBlue$Variable * *)$t1->$a)[n])), DeltaBlue$STRONG_DEFAULT, planner);
    editC = DeltaBlue$createEditConstraint((*($t1 = (&vars),&((struct DeltaBlue$Variable * *)$t1->$a)[0])), DeltaBlue$PREFERRED, planner);
    editV = som$Vector$ad6c2c594a$createWithElement(((struct DeltaBlue$AbstractConstraint * *)&editC));
    plan = ($t3 = ((struct DeltaBlue$Planner *)($t2 = &(*planner)))->class$->extractPlanFromConstraints, $t3($t2, editV));
    i = 0;
    while(1) {
        if( (i <= (100 - 1)) ) {
            (*(*($t1 = (&vars),&((struct DeltaBlue$Variable * *)$t1->$a)[0]))).value = i;
            ($t4 = ((struct DeltaBlue$Plan *)($t2 = &(*plan)))->class$->execute, $t4($t2));
            if( ((*(*($t1 = (&vars),&((struct DeltaBlue$Variable * *)$t1->$a)[n]))).value != i) ) {
                assert(0);
            } 
            i = (i + 1);
        } else {
            break;
        }
    }
    ($t5 = ((struct DeltaBlue$AbstractConstraint *)($t2 = &(*editC)))->class$->destroyConstraint, $t5($t2, planner));
}

void DeltaBlue$projectionTest(int32_t n) {
    struct DeltaBlue$Planner * planner;
    struct som$Vector$7850aff62d$Vector * dests;
    struct DeltaBlue$Variable * scale;
    struct DeltaBlue$Variable * offset;
    struct DeltaBlue$Variable * src;
    struct DeltaBlue$Variable * dst;
    int32_t i;
    struct DeltaBlue$StayConstraint * dummy1;
    struct DeltaBlue$ScaleConstraint * dummy2;
    void* $t0;
    void (* $t1)(void*, struct DeltaBlue$Variable * *);
    void (* $t2)(void*, struct DeltaBlue$Variable *, int32_t);
    struct DeltaBlue$Variable * (* $t3)(void*, int32_t);
    planner = 0;
    dests = 0;
    scale = 0;
    offset = 0;
    src = 0;
    dst = 0;
    i = 0;
    dummy1 = 0;
    dummy2 = 0;
    planner = DeltaBlue$createPlanner();
    dests = som$Vector$7850aff62d$create();
    scale = DeltaBlue$value(10);
    offset = DeltaBlue$value(1000);
    i = 1;
    while(1) {
        if( (i <= n) ) {
            src = DeltaBlue$value(i);
            dst = DeltaBlue$value(i);
            ($t1 = ((struct som$Vector$7850aff62d$Vector *)($t0 = &(*dests)))->class$->append, $t1($t0, &dst));
            dummy1 = DeltaBlue$createStayConstraint(src, DeltaBlue$DEFAULT, planner);
            dummy2 = DeltaBlue$createScaleConstraint(src, scale, offset, dst, DeltaBlue$REQUIRED, planner);
            i = (i + 1);
        } else {
            break;
        }
    }
    ($t2 = ((struct DeltaBlue$Planner *)($t0 = &(*planner)))->class$->change, $t2($t0, src, 17));
    if( ((*dst).value != 1170) ) {
        assert(0);
    } 
    ($t2 = ((struct DeltaBlue$Planner *)($t0 = &(*planner)))->class$->change, $t2($t0, dst, 1050));
    if( ((*src).value != 5) ) {
        assert(0);
    } 
    ($t2 = ((struct DeltaBlue$Planner *)($t0 = &(*planner)))->class$->change, $t2($t0, scale, 5));
    i = 0;
    while(1) {
        if( (i <= (n - 2)) ) {
            if( ((*($t3 = ((struct som$Vector$7850aff62d$Vector *)($t0 = &(*dests)))->class$->at, $t3($t0, i))).value != (((i + 1) * 5) + 1000)) ) {
                assert(0);
            } 
            i = (i + 1);
        } else {
            break;
        }
    }
    ($t2 = ((struct DeltaBlue$Planner *)($t0 = &(*planner)))->class$->change, $t2($t0, offset, 2000));
    i = 0;
    while(1) {
        if( (i <= (n - 2)) ) {
            if( ((*($t3 = ((struct som$Vector$7850aff62d$Vector *)($t0 = &(*dests)))->class$->at, $t3($t0, i))).value != (((i + 1) * 5) + 2000)) ) {
                assert(0);
            } 
            i = (i + 1);
        } else {
            break;
        }
    }
}

void DeltaBlue$UnaryConstraint$initUnaryConstraint(void* this, struct DeltaBlue$Variable * v, struct DeltaBlue$Sym * strength, struct DeltaBlue$Planner * planner) {
    struct DeltaBlue$UnaryConstraint* this$ = this;
    void* $t0;
    void (* $t1)(void*, struct DeltaBlue$Sym *);
    void (* $t2)(void*, struct DeltaBlue$Planner *);
    ($t1 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*this$)))->class$->initAbstractConstraint, $t1($t0, strength));
    (*this$).output = v;
    ($t2 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*this$)))->class$->addConstraint, $t2($t0, planner));
}

uint8_t DeltaBlue$UnaryConstraint$isSatisfied(void* this) {
    struct DeltaBlue$UnaryConstraint* this$ = this;
    return (*this$).satisfied;
}

void DeltaBlue$UnaryConstraint$addToGraph(void* this) {
    struct DeltaBlue$UnaryConstraint* this$ = this;
    void* $t0;
    void (* $t1)(void*, struct DeltaBlue$AbstractConstraint *);
    ($t1 = ((struct DeltaBlue$Variable *)($t0 = &(*(*this$).output)))->class$->addConstraint, $t1($t0, ((struct DeltaBlue$AbstractConstraint *)this$)));
    (*this$).satisfied = 0;
}

void DeltaBlue$UnaryConstraint$removeFromGraph(void* this) {
    struct DeltaBlue$UnaryConstraint* this$ = this;
    void* $t0;
    void (* $t1)(void*, struct DeltaBlue$AbstractConstraint *);
    if( ((void*)(*this$).output != (void*)0) ) {
        ($t1 = ((struct DeltaBlue$Variable *)($t0 = &(*(*this$).output)))->class$->removeConstraint, $t1($t0, ((struct DeltaBlue$AbstractConstraint *)this$)));
    } 
    (*this$).satisfied = 0;
}

int DeltaBlue$UnaryConstraint$chooseMethod(void* this, int32_t mark) {
    struct DeltaBlue$UnaryConstraint* this$ = this;
    void* $t0;
    uint8_t (* $t1)(void*, struct DeltaBlue$Strength *);
    (*this$).satisfied = (((*(*this$).output).mark != mark) && ($t1 = ((struct DeltaBlue$Strength *)($t0 = &(*(*this$).strength)))->class$->stronger, $t1($t0, (*(*this$).output).walkStrength)));
    return 0;
}

void DeltaBlue$UnaryConstraint$markUnsatisfied(void* this) {
    struct DeltaBlue$UnaryConstraint* this$ = this;
    (*this$).satisfied = 0;
}

struct DeltaBlue$Variable * DeltaBlue$UnaryConstraint$getOutput(void* this) {
    struct DeltaBlue$UnaryConstraint* this$ = this;
    return (*this$).output;
}

void DeltaBlue$UnaryConstraint$recalculate(void* this) {
    struct DeltaBlue$UnaryConstraint* this$ = this;
    void* $t0;
    uint8_t (* $t1)(void*);
    void (* $t2)(void*);
    (*(*this$).output).walkStrength = (*this$).strength;
    (*(*this$).output).stay = (!($t1 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*this$)))->class$->isInput, $t1($t0)));
    if( (*(*this$).output).stay ) {
        ($t2 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*this$)))->class$->execute, $t2($t0));
    } 
}

struct DeltaBlue$EditConstraint * DeltaBlue$createEditConstraint(struct DeltaBlue$Variable * v, struct DeltaBlue$Sym * strength, struct DeltaBlue$Planner * planner) {
    struct DeltaBlue$EditConstraint * this;
    struct DeltaBlue$EditConstraint * $t0;
    void* $t1;
    void (* $t2)(void*, struct DeltaBlue$Variable *, struct DeltaBlue$Sym *, struct DeltaBlue$Planner *);
    this = 0;
    $t0 = OBX$Alloc(sizeof(struct DeltaBlue$EditConstraint));
    memset($t0,0,sizeof(struct DeltaBlue$EditConstraint));
    this = $t0;
    DeltaBlue$EditConstraint$init$($t0);
    ($t2 = ((struct DeltaBlue$UnaryConstraint *)($t1 = &(*this)))->class$->initUnaryConstraint, $t2($t1, v, strength, planner));
    return this;
}

uint8_t DeltaBlue$EditConstraint$isInput(void* this) {
    struct DeltaBlue$EditConstraint* this$ = this;
    return 1;
}

struct DeltaBlue$StayConstraint * DeltaBlue$createStayConstraint(struct DeltaBlue$Variable * v, struct DeltaBlue$Sym * strength, struct DeltaBlue$Planner * planner) {
    struct DeltaBlue$StayConstraint * this;
    struct DeltaBlue$StayConstraint * $t0;
    void* $t1;
    void (* $t2)(void*, struct DeltaBlue$Variable *, struct DeltaBlue$Sym *, struct DeltaBlue$Planner *);
    this = 0;
    $t0 = OBX$Alloc(sizeof(struct DeltaBlue$StayConstraint));
    memset($t0,0,sizeof(struct DeltaBlue$StayConstraint));
    this = $t0;
    DeltaBlue$StayConstraint$init$($t0);
    ($t2 = ((struct DeltaBlue$UnaryConstraint *)($t1 = &(*this)))->class$->initUnaryConstraint, $t2($t1, v, strength, planner));
    return this;
}

void DeltaBlue$BinaryConstraint$initBinaryConstraint(void* this, struct DeltaBlue$Variable * var1, struct DeltaBlue$Variable * var2, struct DeltaBlue$Sym * strength, struct DeltaBlue$Planner * planner) {
    struct DeltaBlue$BinaryConstraint* this$ = this;
    void* $t0;
    void (* $t1)(void*, struct DeltaBlue$Sym *);
    ($t1 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*this$)))->class$->initAbstractConstraint, $t1($t0, strength));
    (*this$).v1 = var1;
    (*this$).v2 = var2;
    (*this$).direction = 0;
}

uint8_t DeltaBlue$BinaryConstraint$isSatisfied(void* this) {
    struct DeltaBlue$BinaryConstraint* this$ = this;
    return ((*this$).direction != 0);
}

void DeltaBlue$BinaryConstraint$addToGraph(void* this) {
    struct DeltaBlue$BinaryConstraint* this$ = this;
    void* $t0;
    void (* $t1)(void*, struct DeltaBlue$AbstractConstraint *);
    ($t1 = ((struct DeltaBlue$Variable *)($t0 = &(*(*this$).v1)))->class$->addConstraint, $t1($t0, ((struct DeltaBlue$AbstractConstraint *)this$)));
    ($t1 = ((struct DeltaBlue$Variable *)($t0 = &(*(*this$).v2)))->class$->addConstraint, $t1($t0, ((struct DeltaBlue$AbstractConstraint *)this$)));
    (*this$).direction = 0;
}

void DeltaBlue$BinaryConstraint$removeFromGraph(void* this) {
    struct DeltaBlue$BinaryConstraint* this$ = this;
    void* $t0;
    void (* $t1)(void*, struct DeltaBlue$AbstractConstraint *);
    if( ((void*)(*this$).v1 != (void*)0) ) {
        ($t1 = ((struct DeltaBlue$Variable *)($t0 = &(*(*this$).v1)))->class$->removeConstraint, $t1($t0, ((struct DeltaBlue$AbstractConstraint *)this$)));
    } 
    if( ((void*)(*this$).v2 != (void*)0) ) {
        ($t1 = ((struct DeltaBlue$Variable *)($t0 = &(*(*this$).v2)))->class$->removeConstraint, $t1($t0, ((struct DeltaBlue$AbstractConstraint *)this$)));
    } 
    (*this$).direction = 0;
}

int DeltaBlue$BinaryConstraint$chooseMethod(void* this, int32_t mark) {
    struct DeltaBlue$BinaryConstraint* this$ = this;
    void* $t0;
    uint8_t (* $t1)(void*, struct DeltaBlue$Strength *);
    void* $t2;
    uint8_t (* $t3)(void*, struct DeltaBlue$Strength *);
    if( ((*(*this$).v1).mark == mark) ) {
        if( (((*(*this$).v2).mark != mark) && ($t1 = ((struct DeltaBlue$Strength *)($t0 = &(*(*this$).strength)))->class$->stronger, $t1($t0, (*(*this$).v2).walkStrength))) ) {
            (*this$).direction = 1;
            return (*this$).direction;
        } else {
            (*this$).direction = 0;
            return (*this$).direction;
        }
    } 
    if( ((*(*this$).v2).mark == mark) ) {
        if( (((*(*this$).v1).mark != mark) && ($t1 = ((struct DeltaBlue$Strength *)($t0 = &(*(*this$).strength)))->class$->stronger, $t1($t0, (*(*this$).v1).walkStrength))) ) {
            (*this$).direction = 2;
            return (*this$).direction;
        } else {
            (*this$).direction = 0;
            return (*this$).direction;
        }
    } 
    if( ($t1 = ((struct DeltaBlue$Strength *)($t0 = &(*(*(*this$).v1).walkStrength)))->class$->weaker, $t1($t0, (*(*this$).v2).walkStrength)) ) {
        if( ($t3 = ((struct DeltaBlue$Strength *)($t2 = &(*(*this$).strength)))->class$->stronger, $t3($t2, (*(*this$).v1).walkStrength)) ) {
            (*this$).direction = 2;
            return (*this$).direction;
        } else {
            (*this$).direction = 0;
            return (*this$).direction;
        }
    } else {
        if( ($t1 = ((struct DeltaBlue$Strength *)($t0 = &(*(*this$).strength)))->class$->stronger, $t1($t0, (*(*this$).v2).walkStrength)) ) {
            (*this$).direction = 1;
            return (*this$).direction;
        } else {
            (*this$).direction = 0;
            return (*this$).direction;
        }
    }
    return 0;
}

void DeltaBlue$BinaryConstraint$inputsDo(void* this, struct som$Interfaces$7850aff62d$ForEachInterfaceRW * fn) {
    struct DeltaBlue$BinaryConstraint* this$ = this;
    void* $t0;
    void (* $t1)(void*, struct DeltaBlue$Variable * *);
    if( ((*this$).direction == 1) ) {
        ($t1 = ((struct som$Interfaces$7850aff62d$ForEachInterfaceRW *)($t0 = &(*fn)))->class$->apply, $t1($t0, &(*this$).v1));
    } else {
        ($t1 = ((struct som$Interfaces$7850aff62d$ForEachInterfaceRW *)($t0 = &(*fn)))->class$->apply, $t1($t0, &(*this$).v2));
    }
}

uint8_t DeltaBlue$BinaryConstraint$inputsHasOne(void* this, struct som$Interfaces$7850aff62d$TestInterface * fn) {
    struct DeltaBlue$BinaryConstraint* this$ = this;
    void* $t0;
    uint8_t (* $t1)(void*, struct DeltaBlue$Variable * *);
    if( ((*this$).direction == 1) ) {
        return ($t1 = ((struct som$Interfaces$7850aff62d$TestInterface *)($t0 = &(*fn)))->class$->test, $t1($t0, &(*this$).v1));
    } else {
        return ($t1 = ((struct som$Interfaces$7850aff62d$TestInterface *)($t0 = &(*fn)))->class$->test, $t1($t0, &(*this$).v2));
    }
    return 0;
}

void DeltaBlue$BinaryConstraint$markUnsatisfied(void* this) {
    struct DeltaBlue$BinaryConstraint* this$ = this;
    (*this$).direction = 0;
}

struct DeltaBlue$Variable * DeltaBlue$BinaryConstraint$getOutput(void* this) {
    struct DeltaBlue$BinaryConstraint* this$ = this;
    if( ((*this$).direction == 1) ) {
        return (*this$).v2;
    } else {
        return (*this$).v1;
    }
    return 0;
}

void DeltaBlue$BinaryConstraint$recalculate(void* this) {
    struct DeltaBlue$BinaryConstraint* this$ = this;
    struct DeltaBlue$Variable * in_;
    struct DeltaBlue$Variable * out_;
    void* $t0;
    struct DeltaBlue$Strength * (* $t1)(void*, struct DeltaBlue$Strength *);
    void (* $t2)(void*);
    in_ = 0;
    out_ = 0;
    if( ((*this$).direction == 1) ) {
        in_ = (*this$).v1;
        out_ = (*this$).v2;
    } else {
        in_ = (*this$).v2;
        out_ = (*this$).v1;
    }
    (*out_).walkStrength = ($t1 = ((struct DeltaBlue$Strength *)($t0 = &(*(*this$).strength)))->class$->weakest, $t1($t0, (*in_).walkStrength));
    (*out_).stay = (*in_).stay;
    if( (*out_).stay ) {
        ($t2 = ((struct DeltaBlue$AbstractConstraint *)($t0 = &(*this$)))->class$->execute, $t2($t0));
    } 
}

struct DeltaBlue$EqualityConstraint * DeltaBlue$createEqualityConstraint(struct DeltaBlue$Variable * var1, struct DeltaBlue$Variable * var2, struct DeltaBlue$Sym * strength, struct DeltaBlue$Planner * planner) {
    struct DeltaBlue$EqualityConstraint * this;
    struct DeltaBlue$EqualityConstraint * $t0;
    void* $t1;
    void (* $t2)(void*, struct DeltaBlue$Variable *, struct DeltaBlue$Variable *, struct DeltaBlue$Sym *, struct DeltaBlue$Planner *);
    void (* $t3)(void*, struct DeltaBlue$Planner *);
    this = 0;
    $t0 = OBX$Alloc(sizeof(struct DeltaBlue$EqualityConstraint));
    memset($t0,0,sizeof(struct DeltaBlue$EqualityConstraint));
    this = $t0;
    DeltaBlue$EqualityConstraint$init$($t0);
    ($t2 = ((struct DeltaBlue$BinaryConstraint *)($t1 = &(*this)))->class$->initBinaryConstraint, $t2($t1, var1, var2, strength, planner));
    ($t3 = ((struct DeltaBlue$AbstractConstraint *)($t1 = &(*this)))->class$->addConstraint, $t3($t1, planner));
    return this;
}

void DeltaBlue$EqualityConstraint$execute(void* this) {
    struct DeltaBlue$EqualityConstraint* this$ = this;
    if( ((*this$).direction == 1) ) {
        (*(*this$).v2).value = (*(*this$).v1).value;
    } else {
        (*(*this$).v1).value = (*(*this$).v2).value;
    }
}

struct DeltaBlue$ScaleConstraint * DeltaBlue$createScaleConstraint(struct DeltaBlue$Variable * src, struct DeltaBlue$Variable * scale, struct DeltaBlue$Variable * offset, struct DeltaBlue$Variable * dest, struct DeltaBlue$Sym * strength, struct DeltaBlue$Planner * planner) {
    struct DeltaBlue$ScaleConstraint * this;
    struct DeltaBlue$ScaleConstraint * $t0;
    void* $t1;
    void (* $t2)(void*, struct DeltaBlue$Variable *, struct DeltaBlue$Variable *, struct DeltaBlue$Sym *, struct DeltaBlue$Planner *);
    void (* $t3)(void*, struct DeltaBlue$Planner *);
    this = 0;
    $t0 = OBX$Alloc(sizeof(struct DeltaBlue$ScaleConstraint));
    memset($t0,0,sizeof(struct DeltaBlue$ScaleConstraint));
    this = $t0;
    DeltaBlue$ScaleConstraint$init$($t0);
    ($t2 = ((struct DeltaBlue$BinaryConstraint *)($t1 = &(*this)))->class$->initBinaryConstraint, $t2($t1, src, dest, strength, planner));
    (*this).scale = scale;
    (*this).offset = offset;
    ($t3 = ((struct DeltaBlue$AbstractConstraint *)($t1 = &(*this)))->class$->addConstraint, $t3($t1, planner));
    return this;
}

void DeltaBlue$ScaleConstraint$addToGraph(void* this) {
    struct DeltaBlue$ScaleConstraint* this$ = this;
    void* $t0;
    void (* $t1)(void*, struct DeltaBlue$AbstractConstraint *);
    ($t1 = ((struct DeltaBlue$Variable *)($t0 = &(*(*this$).v1)))->class$->addConstraint, $t1($t0, ((struct DeltaBlue$AbstractConstraint *)this$)));
    ($t1 = ((struct DeltaBlue$Variable *)($t0 = &(*(*this$).v2)))->class$->addConstraint, $t1($t0, ((struct DeltaBlue$AbstractConstraint *)this$)));
    ($t1 = ((struct DeltaBlue$Variable *)($t0 = &(*(*this$).scale)))->class$->addConstraint, $t1($t0, ((struct DeltaBlue$AbstractConstraint *)this$)));
    ($t1 = ((struct DeltaBlue$Variable *)($t0 = &(*(*this$).offset)))->class$->addConstraint, $t1($t0, ((struct DeltaBlue$AbstractConstraint *)this$)));
    (*this$).direction = 0;
}

void DeltaBlue$ScaleConstraint$removeFromGraph(void* this) {
    struct DeltaBlue$ScaleConstraint* this$ = this;
    void* $t0;
    void (* $t1)(void*, struct DeltaBlue$AbstractConstraint *);
    if( ((void*)(*this$).v1 != (void*)0) ) {
        ($t1 = ((struct DeltaBlue$Variable *)($t0 = &(*(*this$).v1)))->class$->removeConstraint, $t1($t0, ((struct DeltaBlue$AbstractConstraint *)this$)));
    } 
    if( ((void*)(*this$).v2 != (void*)0) ) {
        ($t1 = ((struct DeltaBlue$Variable *)($t0 = &(*(*this$).v2)))->class$->removeConstraint, $t1($t0, ((struct DeltaBlue$AbstractConstraint *)this$)));
    } 
    if( ((void*)(*this$).scale != (void*)0) ) {
        ($t1 = ((struct DeltaBlue$Variable *)($t0 = &(*(*this$).scale)))->class$->removeConstraint, $t1($t0, ((struct DeltaBlue$AbstractConstraint *)this$)));
    } 
    if( ((void*)(*this$).offset != (void*)0) ) {
        ($t1 = ((struct DeltaBlue$Variable *)($t0 = &(*(*this$).offset)))->class$->removeConstraint, $t1($t0, ((struct DeltaBlue$AbstractConstraint *)this$)));
    } 
    (*this$).direction = 0;
}

void DeltaBlue$ScaleConstraint$execute(void* this) {
    struct DeltaBlue$ScaleConstraint* this$ = this;
    if( ((*this$).direction == 1) ) {
        (*(*this$).v2).value = (((*(*this$).v1).value * (*(*this$).scale).value) + (*(*this$).offset).value);
    } else {
        (*(*this$).v1).value = OBX$Div32(((*(*this$).v2).value - (*(*this$).offset).value),(*(*this$).scale).value);
    }
}

void DeltaBlue$ScaleConstraint$inputsDo(void* this, struct som$Interfaces$7850aff62d$ForEachInterfaceRW * fn) {
    struct DeltaBlue$ScaleConstraint* this$ = this;
    void* $t0;
    void (* $t1)(void*, struct DeltaBlue$Variable * *);
    if( ((*this$).direction == 1) ) {
        ($t1 = ((struct som$Interfaces$7850aff62d$ForEachInterfaceRW *)($t0 = &(*fn)))->class$->apply, $t1($t0, &(*this$).v1));
        ($t1 = ((struct som$Interfaces$7850aff62d$ForEachInterfaceRW *)($t0 = &(*fn)))->class$->apply, $t1($t0, &(*this$).scale));
        ($t1 = ((struct som$Interfaces$7850aff62d$ForEachInterfaceRW *)($t0 = &(*fn)))->class$->apply, $t1($t0, &(*this$).offset));
    } else {
        ($t1 = ((struct som$Interfaces$7850aff62d$ForEachInterfaceRW *)($t0 = &(*fn)))->class$->apply, $t1($t0, &(*this$).v2));
        ($t1 = ((struct som$Interfaces$7850aff62d$ForEachInterfaceRW *)($t0 = &(*fn)))->class$->apply, $t1($t0, &(*this$).scale));
        ($t1 = ((struct som$Interfaces$7850aff62d$ForEachInterfaceRW *)($t0 = &(*fn)))->class$->apply, $t1($t0, &(*this$).offset));
    }
}

void DeltaBlue$ScaleConstraint$recalculate(void* this) {
    struct DeltaBlue$ScaleConstraint* this$ = this;
    struct DeltaBlue$Variable * in_;
    struct DeltaBlue$Variable * out;
    void* $t0;
    struct DeltaBlue$Strength * (* $t1)(void*, struct DeltaBlue$Strength *);
    void (* $t2)(void*);
    in_ = 0;
    out = 0;
    if( ((*this$).direction == 1) ) {
        in_ = (*this$).v1;
        out = (*this$).v2;
    } else {
        out = (*this$).v1;
        in_ = (*this$).v2;
    }
    (*out).walkStrength = ($t1 = ((struct DeltaBlue$Strength *)($t0 = &(*(*this$).strength)))->class$->weakest, $t1($t0, (*in_).walkStrength));
    (*out).stay = (((*in_).stay && (*(*this$).scale).stay) && (*(*this$).offset).stay);
    if( (*out).stay ) {
        ($t2 = ((struct DeltaBlue$ScaleConstraint *)($t0 = &(*this$)))->class$->execute, $t2($t0));
    } 
}

struct DeltaBlue$AbstractConstraint$inputsKnown$TI$Class$ DeltaBlue$AbstractConstraint$inputsKnown$TI$class$ = { 
    &som$Interfaces$7850aff62d$TestInterface$class$,
    DeltaBlue$AbstractConstraint$inputsKnown$TI$test,
};

struct DeltaBlue$Variable$Class$ DeltaBlue$Variable$class$ = { 
    0,
    DeltaBlue$Variable$addConstraint,
    DeltaBlue$Variable$removeConstraint,
};

struct DeltaBlue$Planner$removePropagateFrom$IC$Class$ DeltaBlue$Planner$removePropagateFrom$IC$class$ = { 
    &som$Interfaces$ad6c2c594a$Comparator$class$,
    DeltaBlue$Planner$removePropagateFrom$IC$compare,
};

struct DeltaBlue$StayConstraint$Class$ DeltaBlue$StayConstraint$class$ = { 
    &DeltaBlue$UnaryConstraint$class$,
    DeltaBlue$AbstractConstraint$initAbstractConstraint,
    DeltaBlue$AbstractConstraint$isInput,
    DeltaBlue$UnaryConstraint$isSatisfied,
    DeltaBlue$UnaryConstraint$addToGraph,
    DeltaBlue$UnaryConstraint$removeFromGraph,
    DeltaBlue$UnaryConstraint$chooseMethod,
    DeltaBlue$AbstractConstraint$execute,
    DeltaBlue$AbstractConstraint$addConstraint,
    DeltaBlue$AbstractConstraint$destroyConstraint,
    DeltaBlue$AbstractConstraint$inputsDo,
    DeltaBlue$AbstractConstraint$inputsHasOne,
    DeltaBlue$AbstractConstraint$inputsKnown,
    DeltaBlue$UnaryConstraint$markUnsatisfied,
    DeltaBlue$UnaryConstraint$getOutput,
    DeltaBlue$UnaryConstraint$recalculate,
    DeltaBlue$AbstractConstraint$satisfy,
    DeltaBlue$UnaryConstraint$initUnaryConstraint,
};

struct DeltaBlue$BinaryConstraint$Class$ DeltaBlue$BinaryConstraint$class$ = { 
    &DeltaBlue$AbstractConstraint$class$,
    DeltaBlue$AbstractConstraint$initAbstractConstraint,
    DeltaBlue$AbstractConstraint$isInput,
    DeltaBlue$BinaryConstraint$isSatisfied,
    DeltaBlue$BinaryConstraint$addToGraph,
    DeltaBlue$BinaryConstraint$removeFromGraph,
    DeltaBlue$BinaryConstraint$chooseMethod,
    DeltaBlue$AbstractConstraint$execute,
    DeltaBlue$AbstractConstraint$addConstraint,
    DeltaBlue$AbstractConstraint$destroyConstraint,
    DeltaBlue$BinaryConstraint$inputsDo,
    DeltaBlue$BinaryConstraint$inputsHasOne,
    DeltaBlue$AbstractConstraint$inputsKnown,
    DeltaBlue$BinaryConstraint$markUnsatisfied,
    DeltaBlue$BinaryConstraint$getOutput,
    DeltaBlue$BinaryConstraint$recalculate,
    DeltaBlue$AbstractConstraint$satisfy,
    DeltaBlue$BinaryConstraint$initBinaryConstraint,
};

struct DeltaBlue$EqualityConstraint$Class$ DeltaBlue$EqualityConstraint$class$ = { 
    &DeltaBlue$BinaryConstraint$class$,
    DeltaBlue$AbstractConstraint$initAbstractConstraint,
    DeltaBlue$AbstractConstraint$isInput,
    DeltaBlue$BinaryConstraint$isSatisfied,
    DeltaBlue$BinaryConstraint$addToGraph,
    DeltaBlue$BinaryConstraint$removeFromGraph,
    DeltaBlue$BinaryConstraint$chooseMethod,
    DeltaBlue$EqualityConstraint$execute,
    DeltaBlue$AbstractConstraint$addConstraint,
    DeltaBlue$AbstractConstraint$destroyConstraint,
    DeltaBlue$BinaryConstraint$inputsDo,
    DeltaBlue$BinaryConstraint$inputsHasOne,
    DeltaBlue$AbstractConstraint$inputsKnown,
    DeltaBlue$BinaryConstraint$markUnsatisfied,
    DeltaBlue$BinaryConstraint$getOutput,
    DeltaBlue$BinaryConstraint$recalculate,
    DeltaBlue$AbstractConstraint$satisfy,
    DeltaBlue$BinaryConstraint$initBinaryConstraint,
};

struct DeltaBlue$Strength$Class$ DeltaBlue$Strength$class$ = { 
    0,
    DeltaBlue$Strength$sameAs,
    DeltaBlue$Strength$stronger,
    DeltaBlue$Strength$weaker,
    DeltaBlue$Strength$strongest,
    DeltaBlue$Strength$weakest,
};

struct DeltaBlue$AbstractConstraint$satisfy$FI$Class$ DeltaBlue$AbstractConstraint$satisfy$FI$class$ = { 
    &som$Interfaces$7850aff62d$ForEachInterfaceRW$class$,
    DeltaBlue$AbstractConstraint$satisfy$FI$apply,
};

struct DeltaBlue$EditConstraint$Class$ DeltaBlue$EditConstraint$class$ = { 
    &DeltaBlue$UnaryConstraint$class$,
    DeltaBlue$AbstractConstraint$initAbstractConstraint,
    DeltaBlue$EditConstraint$isInput,
    DeltaBlue$UnaryConstraint$isSatisfied,
    DeltaBlue$UnaryConstraint$addToGraph,
    DeltaBlue$UnaryConstraint$removeFromGraph,
    DeltaBlue$UnaryConstraint$chooseMethod,
    DeltaBlue$AbstractConstraint$execute,
    DeltaBlue$AbstractConstraint$addConstraint,
    DeltaBlue$AbstractConstraint$destroyConstraint,
    DeltaBlue$AbstractConstraint$inputsDo,
    DeltaBlue$AbstractConstraint$inputsHasOne,
    DeltaBlue$AbstractConstraint$inputsKnown,
    DeltaBlue$UnaryConstraint$markUnsatisfied,
    DeltaBlue$UnaryConstraint$getOutput,
    DeltaBlue$UnaryConstraint$recalculate,
    DeltaBlue$AbstractConstraint$satisfy,
    DeltaBlue$UnaryConstraint$initUnaryConstraint,
};

struct DeltaBlue$Planner$Class$ DeltaBlue$Planner$class$ = { 
    0,
    DeltaBlue$Planner$incrementalAdd,
    DeltaBlue$Planner$incrementalRemove,
    DeltaBlue$Planner$extractPlanFromConstraints,
    DeltaBlue$Planner$makePlan,
    DeltaBlue$Planner$propagateFrom,
    DeltaBlue$Planner$addConstraintsConsumingTo,
    DeltaBlue$Planner$addPropagate,
    DeltaBlue$Planner$change,
    DeltaBlue$Planner$constraintsConsuming,
    DeltaBlue$Planner$newMark,
    DeltaBlue$Planner$removePropagateFrom,
};

struct DeltaBlue$ScaleConstraint$Class$ DeltaBlue$ScaleConstraint$class$ = { 
    &DeltaBlue$BinaryConstraint$class$,
    DeltaBlue$AbstractConstraint$initAbstractConstraint,
    DeltaBlue$AbstractConstraint$isInput,
    DeltaBlue$BinaryConstraint$isSatisfied,
    DeltaBlue$ScaleConstraint$addToGraph,
    DeltaBlue$ScaleConstraint$removeFromGraph,
    DeltaBlue$BinaryConstraint$chooseMethod,
    DeltaBlue$ScaleConstraint$execute,
    DeltaBlue$AbstractConstraint$addConstraint,
    DeltaBlue$AbstractConstraint$destroyConstraint,
    DeltaBlue$ScaleConstraint$inputsDo,
    DeltaBlue$BinaryConstraint$inputsHasOne,
    DeltaBlue$AbstractConstraint$inputsKnown,
    DeltaBlue$BinaryConstraint$markUnsatisfied,
    DeltaBlue$BinaryConstraint$getOutput,
    DeltaBlue$ScaleConstraint$recalculate,
    DeltaBlue$AbstractConstraint$satisfy,
    DeltaBlue$BinaryConstraint$initBinaryConstraint,
};

struct DeltaBlue$DeltaBlue$Class$ DeltaBlue$DeltaBlue$class$ = { 
    &Benchmark$Benchmark$class$,
    DeltaBlue$DeltaBlue$benchmark,
    DeltaBlue$DeltaBlue$verifyResult,
    DeltaBlue$DeltaBlue$innerBenchmarkLoop,
};

struct DeltaBlue$Sym$Class$ DeltaBlue$Sym$class$ = { 
    0,
};

struct DeltaBlue$Planner$removePropagateFrom$FI$Class$ DeltaBlue$Planner$removePropagateFrom$FI$class$ = { 
    &som$Interfaces$ad6c2c594a$ForEachInterface$class$,
    DeltaBlue$Planner$removePropagateFrom$FI$apply,
};

struct DeltaBlue$UnaryConstraint$Class$ DeltaBlue$UnaryConstraint$class$ = { 
    &DeltaBlue$AbstractConstraint$class$,
    DeltaBlue$AbstractConstraint$initAbstractConstraint,
    DeltaBlue$AbstractConstraint$isInput,
    DeltaBlue$UnaryConstraint$isSatisfied,
    DeltaBlue$UnaryConstraint$addToGraph,
    DeltaBlue$UnaryConstraint$removeFromGraph,
    DeltaBlue$UnaryConstraint$chooseMethod,
    DeltaBlue$AbstractConstraint$execute,
    DeltaBlue$AbstractConstraint$addConstraint,
    DeltaBlue$AbstractConstraint$destroyConstraint,
    DeltaBlue$AbstractConstraint$inputsDo,
    DeltaBlue$AbstractConstraint$inputsHasOne,
    DeltaBlue$AbstractConstraint$inputsKnown,
    DeltaBlue$UnaryConstraint$markUnsatisfied,
    DeltaBlue$UnaryConstraint$getOutput,
    DeltaBlue$UnaryConstraint$recalculate,
    DeltaBlue$AbstractConstraint$satisfy,
    DeltaBlue$UnaryConstraint$initUnaryConstraint,
};

struct DeltaBlue$Plan$Class$ DeltaBlue$Plan$class$ = { 
    0,
    DeltaBlue$Plan$execute,
};

struct DeltaBlue$AbstractConstraint$Class$ DeltaBlue$AbstractConstraint$class$ = { 
    0,
    DeltaBlue$AbstractConstraint$initAbstractConstraint,
    DeltaBlue$AbstractConstraint$isInput,
    DeltaBlue$AbstractConstraint$isSatisfied,
    DeltaBlue$AbstractConstraint$addToGraph,
    DeltaBlue$AbstractConstraint$removeFromGraph,
    DeltaBlue$AbstractConstraint$chooseMethod,
    DeltaBlue$AbstractConstraint$execute,
    DeltaBlue$AbstractConstraint$addConstraint,
    DeltaBlue$AbstractConstraint$destroyConstraint,
    DeltaBlue$AbstractConstraint$inputsDo,
    DeltaBlue$AbstractConstraint$inputsHasOne,
    DeltaBlue$AbstractConstraint$inputsKnown,
    DeltaBlue$AbstractConstraint$markUnsatisfied,
    DeltaBlue$AbstractConstraint$getOutput,
    DeltaBlue$AbstractConstraint$recalculate,
    DeltaBlue$AbstractConstraint$satisfy,
};

static int initDone$ = 0;
void DeltaBlue$init$(void) {
    void* $t0;
    void (* $t1)(void*, struct DeltaBlue$Sym * *, int32_t *);
    void (* $t2)(void*, struct DeltaBlue$Sym * *, struct DeltaBlue$Strength * *);
    if(initDone$) return; else initDone$ = 1;
    Benchmark$init$();
    som$IdentityDictionary2$df63a5a394$init$();
    som$IdentityDictionary2$ec88893d1b$init$();
    som$Interfaces$7850aff62d$init$();
    som$Vector$ad6c2c594a$init$();
    som$Interfaces$ad6c2c594a$init$();
    som$Vector$7850aff62d$init$();
    DeltaBlue$ABSOLUTE_STRONGEST = DeltaBlue$createSym(0);
    DeltaBlue$REQUIRED = DeltaBlue$createSym(1);
    DeltaBlue$STRONG_PREFERRED = DeltaBlue$createSym(2);
    DeltaBlue$PREFERRED = DeltaBlue$createSym(3);
    DeltaBlue$STRONG_DEFAULT = DeltaBlue$createSym(4);
    DeltaBlue$DEFAULT = DeltaBlue$createSym(5);
    DeltaBlue$WEAK_DEFAULT = DeltaBlue$createSym(6);
    DeltaBlue$ABSOLUTE_WEAKEST = DeltaBlue$createSym(7);
    DeltaBlue$strengthTable = som$IdentityDictionary2$df63a5a394$create();
    ($t1 = ((struct som$Dictionary2$5c466e54b6$Dictionary *)($t0 = &(*DeltaBlue$strengthTable)))->class$->atPut, $t1($t0, &DeltaBlue$ABSOLUTE_STRONGEST, &(int32_t){(-10000)}));
    ($t1 = ((struct som$Dictionary2$5c466e54b6$Dictionary *)($t0 = &(*DeltaBlue$strengthTable)))->class$->atPut, $t1($t0, &DeltaBlue$REQUIRED, &(int32_t){(-800)}));
    ($t1 = ((struct som$Dictionary2$5c466e54b6$Dictionary *)($t0 = &(*DeltaBlue$strengthTable)))->class$->atPut, $t1($t0, &DeltaBlue$STRONG_PREFERRED, &(int32_t){(-600)}));
    ($t1 = ((struct som$Dictionary2$5c466e54b6$Dictionary *)($t0 = &(*DeltaBlue$strengthTable)))->class$->atPut, $t1($t0, &DeltaBlue$PREFERRED, &(int32_t){(-400)}));
    ($t1 = ((struct som$Dictionary2$5c466e54b6$Dictionary *)($t0 = &(*DeltaBlue$strengthTable)))->class$->atPut, $t1($t0, &DeltaBlue$STRONG_DEFAULT, &(int32_t){(-200)}));
    ($t1 = ((struct som$Dictionary2$5c466e54b6$Dictionary *)($t0 = &(*DeltaBlue$strengthTable)))->class$->atPut, $t1($t0, &DeltaBlue$DEFAULT, &(int32_t){0}));
    ($t1 = ((struct som$Dictionary2$5c466e54b6$Dictionary *)($t0 = &(*DeltaBlue$strengthTable)))->class$->atPut, $t1($t0, &DeltaBlue$WEAK_DEFAULT, &(int32_t){500}));
    ($t1 = ((struct som$Dictionary2$5c466e54b6$Dictionary *)($t0 = &(*DeltaBlue$strengthTable)))->class$->atPut, $t1($t0, &DeltaBlue$ABSOLUTE_WEAKEST, &(int32_t){10000}));
    DeltaBlue$strengthConstant = som$IdentityDictionary2$ec88893d1b$create();
    ($t2 = ((struct som$Dictionary2$1fc4d3b22f$Dictionary *)($t0 = &(*DeltaBlue$strengthConstant)))->class$->atPut, $t2($t0, &DeltaBlue$ABSOLUTE_STRONGEST, &((struct DeltaBlue$Strength *[1]){DeltaBlue$createStrength(DeltaBlue$ABSOLUTE_STRONGEST)})[0]));
    DeltaBlue$required = DeltaBlue$createStrength(DeltaBlue$REQUIRED);
    ($t2 = ((struct som$Dictionary2$1fc4d3b22f$Dictionary *)($t0 = &(*DeltaBlue$strengthConstant)))->class$->atPut, $t2($t0, &DeltaBlue$REQUIRED, &DeltaBlue$required));
    ($t2 = ((struct som$Dictionary2$1fc4d3b22f$Dictionary *)($t0 = &(*DeltaBlue$strengthConstant)))->class$->atPut, $t2($t0, &DeltaBlue$STRONG_PREFERRED, &((struct DeltaBlue$Strength *[1]){DeltaBlue$createStrength(DeltaBlue$STRONG_PREFERRED)})[0]));
    ($t2 = ((struct som$Dictionary2$1fc4d3b22f$Dictionary *)($t0 = &(*DeltaBlue$strengthConstant)))->class$->atPut, $t2($t0, &DeltaBlue$PREFERRED, &((struct DeltaBlue$Strength *[1]){DeltaBlue$createStrength(DeltaBlue$PREFERRED)})[0]));
    ($t2 = ((struct som$Dictionary2$1fc4d3b22f$Dictionary *)($t0 = &(*DeltaBlue$strengthConstant)))->class$->atPut, $t2($t0, &DeltaBlue$STRONG_DEFAULT, &((struct DeltaBlue$Strength *[1]){DeltaBlue$createStrength(DeltaBlue$STRONG_DEFAULT)})[0]));
    ($t2 = ((struct som$Dictionary2$1fc4d3b22f$Dictionary *)($t0 = &(*DeltaBlue$strengthConstant)))->class$->atPut, $t2($t0, &DeltaBlue$DEFAULT, &((struct DeltaBlue$Strength *[1]){DeltaBlue$createStrength(DeltaBlue$DEFAULT)})[0]));
    ($t2 = ((struct som$Dictionary2$1fc4d3b22f$Dictionary *)($t0 = &(*DeltaBlue$strengthConstant)))->class$->atPut, $t2($t0, &DeltaBlue$WEAK_DEFAULT, &((struct DeltaBlue$Strength *[1]){DeltaBlue$createStrength(DeltaBlue$WEAK_DEFAULT)})[0]));
    DeltaBlue$absoluteWeakest = DeltaBlue$createStrength(DeltaBlue$ABSOLUTE_WEAKEST);
    ($t2 = ((struct som$Dictionary2$1fc4d3b22f$Dictionary *)($t0 = &(*DeltaBlue$strengthConstant)))->class$->atPut, $t2($t0, &DeltaBlue$ABSOLUTE_WEAKEST, &DeltaBlue$absoluteWeakest));
}
OBX$Cmd DeltaBlue$cmd$(const char* name) {
    if( name == 0 ) return DeltaBlue$init$;
    return 0;
}
