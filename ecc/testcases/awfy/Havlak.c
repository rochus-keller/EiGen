// Generated by Oberon+ IDE (Mono) 0.9.106 on 2024-07-13T01:26:30

#include "Havlak.h"

void Havlak$HavlakLoopFinder$findLoops$FI1$init$(struct Havlak$HavlakLoopFinder$findLoops$FI1* inst){
    inst->class$ = &Havlak$HavlakLoopFinder$findLoops$FI1$class$;
}
void Havlak$Havlak$init$(struct Havlak$Havlak* inst){
    inst->class$ = &Havlak$Havlak$class$;
}
void Havlak$LoopStructureGraph$init$(struct Havlak$LoopStructureGraph* inst){
    inst->class$ = &Havlak$LoopStructureGraph$class$;
}
void Havlak$HavlakLoopFinder$init$(struct Havlak$HavlakLoopFinder* inst){
    inst->class$ = &Havlak$HavlakLoopFinder$class$;
}
void Havlak$LoopStructureGraph$calculateNestingLevelRec$FI$init$(struct Havlak$LoopStructureGraph$calculateNestingLevelRec$FI* inst){
    inst->class$ = &Havlak$LoopStructureGraph$calculateNestingLevelRec$FI$class$;
}
void Havlak$UnionFindNode$findSet$FI$init$(struct Havlak$UnionFindNode$findSet$FI* inst){
    inst->class$ = &Havlak$UnionFindNode$findSet$FI$class$;
}
void Havlak$LoopStructureGraph$calculateNestingLevel$FI$init$(struct Havlak$LoopStructureGraph$calculateNestingLevel$FI* inst){
    inst->class$ = &Havlak$LoopStructureGraph$calculateNestingLevel$FI$class$;
}
void Havlak$IntIntResult$init$(struct Havlak$IntIntResult* inst){
    inst->class$ = &Havlak$IntIntResult$class$;
}
void Havlak$BasicBlock$init$(struct Havlak$BasicBlock* inst){
    inst->class$ = &Havlak$BasicBlock$class$;
}
void Havlak$HavlakLoopFinder$stepEProcessNonBackPreds$FI$apply$TI$init$(struct Havlak$HavlakLoopFinder$stepEProcessNonBackPreds$FI$apply$TI* inst){
    inst->class$ = &Havlak$HavlakLoopFinder$stepEProcessNonBackPreds$FI$apply$TI$class$;
}
void Havlak$SimpleLoop$init$(struct Havlak$SimpleLoop* inst){
    inst->class$ = &Havlak$SimpleLoop$class$;
}
void Havlak$HavlakLoopFinder$setLoopAttributes$FI$init$(struct Havlak$HavlakLoopFinder$setLoopAttributes$FI* inst){
    inst->class$ = &Havlak$HavlakLoopFinder$setLoopAttributes$FI$class$;
}
void Havlak$HavlakLoopFinder$processEdges$FI$init$(struct Havlak$HavlakLoopFinder$processEdges$FI* inst){
    inst->class$ = &Havlak$HavlakLoopFinder$processEdges$FI$class$;
}
void Havlak$HavlakLoopFinder$initAllNodes$FI$init$(struct Havlak$HavlakLoopFinder$initAllNodes$FI* inst){
    inst->class$ = &Havlak$HavlakLoopFinder$initAllNodes$FI$class$;
}
void Havlak$BasicBlockEdge$init$(struct Havlak$BasicBlockEdge* inst){
    inst->class$ = &Havlak$BasicBlockEdge$class$;
}
void Havlak$UnionFindNode$init$(struct Havlak$UnionFindNode* inst){
    inst->class$ = &Havlak$UnionFindNode$class$;
}
void Havlak$HavlakLoopFinder$stepD$FI$init$(struct Havlak$HavlakLoopFinder$stepD$FI* inst){
    inst->class$ = &Havlak$HavlakLoopFinder$stepD$FI$class$;
}
void Havlak$ControlFlowGraph$init$(struct Havlak$ControlFlowGraph* inst){
    inst->class$ = &Havlak$ControlFlowGraph$class$;
}
void Havlak$LoopTesterApp$init$(struct Havlak$LoopTesterApp* inst){
    inst->class$ = &Havlak$LoopTesterApp$class$;
}
void Havlak$HavlakLoopFinder$stepEProcessNonBackPreds$FI$init$(struct Havlak$HavlakLoopFinder$stepEProcessNonBackPreds$FI* inst){
    inst->class$ = &Havlak$HavlakLoopFinder$stepEProcessNonBackPreds$FI$class$;
}
struct Havlak$Havlak * Havlak$create() {
    struct Havlak$Havlak * h;
    struct Havlak$Havlak * $t0;
    h = 0;
    $t0 = OBX$Alloc(sizeof(struct Havlak$Havlak));
    memset($t0,0,sizeof(struct Havlak$Havlak));
    h = $t0;
    Havlak$Havlak$init$($t0);
    return h;
}

struct Benchmark$Result * Havlak$Havlak$benchmark(void* this) {
    struct Havlak$Havlak* this$ = this;
    assert(0);
    return 0;
}

uint8_t Havlak$Havlak$verifyResult(void* this, struct Benchmark$Result * result) {
    struct Havlak$Havlak* this$ = this;
    assert(0);
    return 0;
}

uint8_t Havlak$Havlak$innerBenchmarkLoop(void* this, int32_t innerIterations) {
    struct Havlak$Havlak* this$ = this;
    struct Havlak$LoopTesterApp * app;
    void* $t0;
    struct Havlak$IntIntResult * (* $t1)(void*, int32_t, int32_t, int32_t, int32_t, int32_t);
    app = 0;
    app = Havlak$createLoopTesterApp();
    return Havlak$verifyResult2(($t1 = ((struct Havlak$LoopTesterApp *)($t0 = &(*app)))->class$->main_, $t1($t0, innerIterations, 50, 10, 10, 5)), innerIterations);
}

uint8_t Havlak$verifyResult2(struct Havlak$IntIntResult * r, int32_t innerIterations) {
    if( (innerIterations == 15000) ) {
        return (((*r).res1 == 46602) && ((*r).res2 == 5213));
    } 
    if( (innerIterations == 1500) ) {
        return (((*r).res1 == 6102) && ((*r).res2 == 5213));
    } 
    if( (innerIterations == 150) ) {
        return (((*r).res1 == 2052) && ((*r).res2 == 5213));
    } 
    if( (innerIterations == 15) ) {
        return (((*r).res1 == 1647) && ((*r).res2 == 5213));
    } 
    if( (innerIterations == 1) ) {
        return (((*r).res1 == 1605) && ((*r).res2 == 5213));
    } 
    Out$String((const struct OBX$Array$1){28,0,OBX$FromUtf("No verification result for ",28,0)});
    Out$Int(innerIterations, 0);
    Out$String((const struct OBX$Array$1){7,0,OBX$FromUtf(" found",7,0)});
    Out$Ln();
    Out$String((const struct OBX$Array$1){12,0,OBX$FromUtf("Result is: ",12,0)});
    Out$Int((*r).res1, 0);
    Out$String((const struct OBX$Array$1){3,0,OBX$FromUtf(", ",3,0)});
    Out$Int((*r).res2, 0);
    Out$Ln();
    return 0;
}

struct Havlak$BasicBlock * Havlak$createBasicBlock(int32_t name) {
    struct Havlak$BasicBlock * b;
    struct Havlak$BasicBlock * $t0;
    b = 0;
    $t0 = OBX$Alloc(sizeof(struct Havlak$BasicBlock));
    memset($t0,0,sizeof(struct Havlak$BasicBlock));
    b = $t0;
    Havlak$BasicBlock$init$($t0);
    (*b).name = name;
    (*b).inEdges = som$Vector$6226d61315$createWithSize(2);
    (*b).outEdges = som$Vector$6226d61315$createWithSize(2);
    return b;
}

int32_t Havlak$BasicBlockHash(struct Havlak$BasicBlock * * b) {
    return (*(*b)).name;
}

struct Havlak$BasicBlockEdge * Havlak$createEdge(struct Havlak$ControlFlowGraph * cfg, int32_t fromName, int32_t toName) {
    struct Havlak$BasicBlockEdge * this;
    struct Havlak$BasicBlockEdge * $t0;
    void* $t1;
    struct Havlak$BasicBlock * (* $t2)(void*, int32_t);
    void (* $t3)(void*, struct Havlak$BasicBlock * *);
    void (* $t4)(void*, struct Havlak$BasicBlockEdge * *);
    this = 0;
    $t0 = OBX$Alloc(sizeof(struct Havlak$BasicBlockEdge));
    memset($t0,0,sizeof(struct Havlak$BasicBlockEdge));
    this = $t0;
    Havlak$BasicBlockEdge$init$($t0);
    (*this).from = ($t2 = ((struct Havlak$ControlFlowGraph *)($t1 = &(*cfg)))->class$->createNode, $t2($t1, fromName));
    (*this).too = ($t2 = ((struct Havlak$ControlFlowGraph *)($t1 = &(*cfg)))->class$->createNode, $t2($t1, toName));
    ($t3 = ((struct som$Vector$6226d61315$Vector *)($t1 = &(*(*(*this).from).outEdges)))->class$->append, $t3($t1, &(*this).too));
    ($t3 = ((struct som$Vector$6226d61315$Vector *)($t1 = &(*(*(*this).too).inEdges)))->class$->append, $t3($t1, &(*this).from));
    ($t4 = ((struct som$Vector$6184042aef$Vector *)($t1 = &(*(*cfg).edgeList)))->class$->append, $t4($t1, &this));
    return this;
}

struct Havlak$ControlFlowGraph * Havlak$createCFG() {
    struct Havlak$ControlFlowGraph * cfg;
    struct Havlak$ControlFlowGraph * $t0;
    cfg = 0;
    $t0 = OBX$Alloc(sizeof(struct Havlak$ControlFlowGraph));
    memset($t0,0,sizeof(struct Havlak$ControlFlowGraph));
    cfg = $t0;
    Havlak$ControlFlowGraph$init$($t0);
    (*cfg).basicBlockMap = som$Vector$6226d61315$create();
    (*cfg).edgeList = som$Vector$6184042aef$create();
    return cfg;
}

struct Havlak$BasicBlock * Havlak$ControlFlowGraph$createNode(void* this, int32_t name) {
    struct Havlak$ControlFlowGraph* this$ = this;
    struct Havlak$BasicBlock * node;
    void* $t0;
    struct Havlak$BasicBlock * (* $t1)(void*, int32_t);
    void* $t2;
    struct Havlak$BasicBlock * (* $t3)(void*, int32_t);
    void (* $t4)(void*, int32_t, struct Havlak$BasicBlock * *);
    int32_t (* $t5)(void*);
    node = 0;
    if( ((void*)($t1 = ((struct som$Vector$6226d61315$Vector *)($t0 = &(*(*this$).basicBlockMap)))->class$->at, $t1($t0, name)) != (void*)0) ) {
        node = ($t3 = ((struct som$Vector$6226d61315$Vector *)($t2 = &(*(*this$).basicBlockMap)))->class$->at, $t3($t2, name));
    } else {
        node = Havlak$createBasicBlock(name);
        ($t4 = ((struct som$Vector$6226d61315$Vector *)($t0 = &(*(*this$).basicBlockMap)))->class$->atPut, $t4($t0, name, &node));
    }
    if( (($t5 = ((struct Havlak$ControlFlowGraph *)($t0 = &(*this$)))->class$->getNumNodes, $t5($t0)) == 1) ) {
        (*this$).startNode = node;
    } 
    return node;
}

int32_t Havlak$ControlFlowGraph$getNumNodes(void* this) {
    struct Havlak$ControlFlowGraph* this$ = this;
    void* $t0;
    int32_t (* $t1)(void*);
    return ($t1 = ((struct som$Vector$6226d61315$Vector *)($t0 = &(*(*this$).basicBlockMap)))->class$->getSize, $t1($t0));
}

struct Havlak$SimpleLoop * Havlak$createSimpleLoop(struct Havlak$BasicBlock * bb) {
    struct Havlak$SimpleLoop * this;
    struct Havlak$SimpleLoop * $t0;
    void* $t1;
    void (* $t2)(void*, int32_t);
    void (* $t3)(void*, struct Havlak$BasicBlock * *);
    this = 0;
    $t0 = OBX$Alloc(sizeof(struct Havlak$SimpleLoop));
    memset($t0,0,sizeof(struct Havlak$SimpleLoop));
    this = $t0;
    Havlak$SimpleLoop$init$($t0);
    ($t2 = ((struct Havlak$SimpleLoop *)($t1 = &(*this)))->class$->setNestingLevel, $t2($t1, 0));
    (*this).basicBlocks = som$IdentitySet$6226d61315$create();
    (*this).children = som$IdentitySet$2b688abfab$create();
    if( ((void*)bb != (void*)0) ) {
        ($t3 = ((struct som$Set$6226d61315$Set *)($t1 = &(*(*this).basicBlocks)))->class$->add, $t3($t1, &bb));
    } 
    return this;
}

void Havlak$SimpleLoop$setParent(void* this, struct Havlak$SimpleLoop * parent) {
    struct Havlak$SimpleLoop* this$ = this;
    void* $t0;
    void (* $t1)(void*, struct Havlak$SimpleLoop * *);
    (*this$).parent = parent;
    ($t1 = ((struct som$Set$2b688abfab$Set *)($t0 = &(*(*(*this$).parent).children)))->class$->add, $t1($t0, &this$));
}

void Havlak$SimpleLoop$setNestingLevel(void* this, int32_t level) {
    struct Havlak$SimpleLoop* this$ = this;
    (*this$).nestingLevel = level;
    if( (level == 0) ) {
        (*this$).isRoot = 1;
    } 
}

void Havlak$UnionFindNode$initNode(void* this, struct Havlak$BasicBlock * bb, int32_t dfsNumber) {
    struct Havlak$UnionFindNode* this$ = this;
    (*this$).parent = this$;
    (*this$).bb = bb;
    (*this$).dfsNumber = dfsNumber;
}

void Havlak$UnionFindNode$union(void* this, struct Havlak$UnionFindNode * basicBlock) {
    struct Havlak$UnionFindNode* this$ = this;
    (*this$).parent = basicBlock;
}

struct Havlak$UnionFindNode * Havlak$UnionFindNode$findSet(void* this) {
    struct Havlak$UnionFindNode* this$ = this;
    struct som$Vector$d944f549ff$Vector * nodeList;
    struct Havlak$UnionFindNode * node;
    struct Havlak$UnionFindNode$findSet$FI iter;
    void* $t0;
    void (* $t1)(void*, struct Havlak$UnionFindNode * *);
    void (* $t2)(void*, struct som$Interfaces$d944f549ff$ForEachInterface *);
    nodeList = 0;
    node = 0;
    memset(&iter,0,sizeof(iter));
    Havlak$UnionFindNode$findSet$FI$init$(&iter);
    nodeList = som$Vector$d944f549ff$create();
    node = this$;
    while(1) {
        if( ((void*)node != (void*)(*node).parent) ) {
            if( ((void*)(*node).parent != (void*)(*(*node).parent).parent) ) {
                ($t1 = ((struct som$Vector$d944f549ff$Vector *)($t0 = &(*nodeList)))->class$->append, $t1($t0, &node));
            } 
            node = (*node).parent;
        } else {
            break;
        }
    }
    iter.parent = (*this$).parent;
    ($t2 = ((struct som$Vector$d944f549ff$Vector *)($t0 = &(*nodeList)))->class$->forEach, $t2($t0, ((struct som$Interfaces$d944f549ff$ForEachInterface *)&iter)));
    return node;
}

void Havlak$UnionFindNode$findSet$FI$apply(void* this, struct Havlak$UnionFindNode * * elem) {
    struct Havlak$UnionFindNode$findSet$FI* this$ = this;
    void* $t0;
    void (* $t1)(void*, struct Havlak$UnionFindNode *);
    ($t1 = ((struct Havlak$UnionFindNode *)($t0 = &(*(*elem))))->class$->union_, $t1($t0, (*this$).parent));
}

struct Havlak$LoopStructureGraph * Havlak$createLoopStructureGraph() {
    struct Havlak$LoopStructureGraph * this;
    struct Havlak$LoopStructureGraph * $t0;
    void* $t1;
    void (* $t2)(void*, int32_t);
    void (* $t3)(void*, struct Havlak$SimpleLoop * *);
    this = 0;
    $t0 = OBX$Alloc(sizeof(struct Havlak$LoopStructureGraph));
    memset($t0,0,sizeof(struct Havlak$LoopStructureGraph));
    this = $t0;
    Havlak$LoopStructureGraph$init$($t0);
    (*this).loopCounter = 0;
    (*this).loops = som$Vector$2b688abfab$create();
    (*this).root = Havlak$createSimpleLoop(0);
    ($t2 = ((struct Havlak$SimpleLoop *)($t1 = &(*(*this).root)))->class$->setNestingLevel, $t2($t1, 0));
    (*this).loopCounter++;
    ($t3 = ((struct som$Vector$2b688abfab$Vector *)($t1 = &(*(*this).loops)))->class$->append, $t3($t1, &(*this).root));
    return this;
}

struct Havlak$SimpleLoop * Havlak$LoopStructureGraph$createNewLoop(void* this, struct Havlak$BasicBlock * bb) {
    struct Havlak$LoopStructureGraph* this$ = this;
    struct Havlak$SimpleLoop * looop;
    void* $t0;
    void (* $t1)(void*, struct Havlak$SimpleLoop * *);
    looop = 0;
    looop = Havlak$createSimpleLoop(bb);
    (*this$).loopCounter++;
    ($t1 = ((struct som$Vector$2b688abfab$Vector *)($t0 = &(*(*this$).loops)))->class$->append, $t1($t0, &looop));
    return looop;
}

void Havlak$LoopStructureGraph$calculateNestingLevel(void* this) {
    struct Havlak$LoopStructureGraph* this$ = this;
    struct Havlak$LoopStructureGraph$calculateNestingLevel$FI liter;
    void* $t0;
    void (* $t1)(void*, struct som$Interfaces$2b688abfab$ForEachInterface *);
    void (* $t2)(void*, struct Havlak$SimpleLoop *, int32_t);
    memset(&liter,0,sizeof(liter));
    Havlak$LoopStructureGraph$calculateNestingLevel$FI$init$(&liter);
    liter.root = (*this$).root;
    ($t1 = ((struct som$Vector$2b688abfab$Vector *)($t0 = &(*(*this$).loops)))->class$->forEach, $t1($t0, ((struct som$Interfaces$2b688abfab$ForEachInterface *)&liter)));
    ($t2 = ((struct Havlak$LoopStructureGraph *)($t0 = &(*this$)))->class$->calculateNestingLevelRec, $t2($t0, (*this$).root, 0));
}

void Havlak$LoopStructureGraph$calculateNestingLevel$FI$apply(void* this, struct Havlak$SimpleLoop * * elem) {
    struct Havlak$LoopStructureGraph$calculateNestingLevel$FI* this$ = this;
    void* $t0;
    void (* $t1)(void*, struct Havlak$SimpleLoop *);
    if( (!(*(*elem)).isRoot) ) {
        if( ((void*)(*(*elem)).parent == (void*)0) ) {
            ($t1 = ((struct Havlak$SimpleLoop *)($t0 = &(*(*elem))))->class$->setParent, $t1($t0, (*this$).root));
        } 
    } 
}

void Havlak$LoopStructureGraph$calculateNestingLevelRec(void* this, struct Havlak$SimpleLoop * looop, int32_t depth) {
    struct Havlak$LoopStructureGraph* this$ = this;
    struct Havlak$LoopStructureGraph$calculateNestingLevelRec$FI liter;
    void* $t0;
    void (* $t1)(void*, struct som$Interfaces$2b688abfab$ForEachInterface *);
    memset(&liter,0,sizeof(liter));
    Havlak$LoopStructureGraph$calculateNestingLevelRec$FI$init$(&liter);
    liter.this = this$;
    liter.looop = looop;
    liter.depth = depth;
    ($t1 = ((struct som$Set$2b688abfab$Set *)($t0 = &(*(*looop).children)))->class$->forEach, $t1($t0, ((struct som$Interfaces$2b688abfab$ForEachInterface *)&liter)));
}

void Havlak$LoopStructureGraph$calculateNestingLevelRec$FI$apply(void* this, struct Havlak$SimpleLoop * * elem) {
    struct Havlak$LoopStructureGraph$calculateNestingLevelRec$FI* this$ = this;
    void* $t0;
    void (* $t1)(void*, struct Havlak$SimpleLoop *, int32_t);
    void (* $t2)(void*, int32_t);
    ($t1 = ((struct Havlak$LoopStructureGraph *)($t0 = &(*(*this$).this)))->class$->calculateNestingLevelRec, $t1($t0, (*elem), ((*this$).depth + 1)));
    ($t2 = ((struct Havlak$SimpleLoop *)($t0 = &(*(*this$).looop)))->class$->setNestingLevel, $t2($t0, ((*(*this$).looop).nestingLevel > (1 + (*(*elem)).nestingLevel) ? (*(*this$).looop).nestingLevel : (1 + (*(*elem)).nestingLevel))));
}

struct Havlak$LoopTesterApp * Havlak$createLoopTesterApp() {
    struct Havlak$LoopTesterApp * this;
    struct Havlak$BasicBlock * bb;
    struct Havlak$LoopTesterApp * $t0;
    void* $t1;
    struct Havlak$BasicBlock * (* $t2)(void*, int32_t);
    this = 0;
    bb = 0;
    $t0 = OBX$Alloc(sizeof(struct Havlak$LoopTesterApp));
    memset($t0,0,sizeof(struct Havlak$LoopTesterApp));
    this = $t0;
    Havlak$LoopTesterApp$init$($t0);
    (*this).cfg = Havlak$createCFG();
    (*this).lsg = Havlak$createLoopStructureGraph();
    bb = ($t2 = ((struct Havlak$ControlFlowGraph *)($t1 = &(*(*this).cfg)))->class$->createNode, $t2($t1, 0));
    return this;
}

int32_t Havlak$LoopTesterApp$buildDiamond(void* this, int32_t start) {
    struct Havlak$LoopTesterApp* this$ = this;
    struct Havlak$BasicBlockEdge * bb;
    bb = 0;
    bb = Havlak$createEdge((*this$).cfg, start, (start + 1));
    bb = Havlak$createEdge((*this$).cfg, start, (start + 2));
    bb = Havlak$createEdge((*this$).cfg, (start + 1), (start + 3));
    bb = Havlak$createEdge((*this$).cfg, (start + 2), (start + 3));
    return (start + 3);
}

void Havlak$LoopTesterApp$buildConnect(void* this, int32_t start, int32_t _end) {
    struct Havlak$LoopTesterApp* this$ = this;
    struct Havlak$BasicBlockEdge * e;
    e = 0;
    e = Havlak$createEdge((*this$).cfg, start, _end);
}

int32_t Havlak$LoopTesterApp$buildStraight(void* this, int32_t start, int32_t n) {
    struct Havlak$LoopTesterApp* this$ = this;
    int32_t i;
    void* $t0;
    void (* $t1)(void*, int32_t, int32_t);
    i = 0;
    i = 0;
    while(1) {
        if( (i <= (n - 1)) ) {
            ($t1 = ((struct Havlak$LoopTesterApp *)($t0 = &(*this$)))->class$->buildConnect, $t1($t0, (start + i), ((start + i) + 1)));
            i = (i + 1);
        } else {
            break;
        }
    }
    return (start + n);
}

int32_t Havlak$LoopTesterApp$buildBaseLoop(void* this, int32_t from) {
    struct Havlak$LoopTesterApp* this$ = this;
    int32_t header;
    int32_t diamond1;
    int32_t d11;
    int32_t diamond2;
    int32_t footer;
    void* $t0;
    int32_t (* $t1)(void*, int32_t, int32_t);
    int32_t (* $t2)(void*, int32_t);
    void (* $t3)(void*, int32_t, int32_t);
    header = 0;
    diamond1 = 0;
    d11 = 0;
    diamond2 = 0;
    footer = 0;
    header = ($t1 = ((struct Havlak$LoopTesterApp *)($t0 = &(*this$)))->class$->buildStraight, $t1($t0, from, 1));
    diamond1 = ($t2 = ((struct Havlak$LoopTesterApp *)($t0 = &(*this$)))->class$->buildDiamond, $t2($t0, header));
    d11 = ($t1 = ((struct Havlak$LoopTesterApp *)($t0 = &(*this$)))->class$->buildStraight, $t1($t0, diamond1, 1));
    diamond2 = ($t2 = ((struct Havlak$LoopTesterApp *)($t0 = &(*this$)))->class$->buildDiamond, $t2($t0, d11));
    footer = ($t1 = ((struct Havlak$LoopTesterApp *)($t0 = &(*this$)))->class$->buildStraight, $t1($t0, diamond2, 1));
    ($t3 = ((struct Havlak$LoopTesterApp *)($t0 = &(*this$)))->class$->buildConnect, $t3($t0, diamond2, d11));
    ($t3 = ((struct Havlak$LoopTesterApp *)($t0 = &(*this$)))->class$->buildConnect, $t3($t0, diamond1, header));
    ($t3 = ((struct Havlak$LoopTesterApp *)($t0 = &(*this$)))->class$->buildConnect, $t3($t0, footer, from));
    footer = ($t1 = ((struct Havlak$LoopTesterApp *)($t0 = &(*this$)))->class$->buildStraight, $t1($t0, footer, 1));
    return footer;
}

void Havlak$LoopTesterApp$constructCFG(void* this, int32_t parLoops, int32_t pparLoops, int32_t ppparLoops) {
    struct Havlak$LoopTesterApp* this$ = this;
    int32_t n;
    int32_t parlooptrees;
    int32_t i;
    int32_t j;
    int32_t top;
    int32_t bottom;
    struct Havlak$BasicBlock * dummy;
    void* $t0;
    struct Havlak$BasicBlock * (* $t1)(void*, int32_t);
    void (* $t2)(void*, int32_t, int32_t);
    int32_t (* $t3)(void*, int32_t, int32_t);
    int32_t (* $t4)(void*, int32_t);
    n = 0;
    parlooptrees = 0;
    i = 0;
    j = 0;
    top = 0;
    bottom = 0;
    dummy = 0;
    n = 2;
    parlooptrees = 0;
    while(1) {
        if( (parlooptrees <= (parLoops - 1)) ) {
            dummy = ($t1 = ((struct Havlak$ControlFlowGraph *)($t0 = &(*(*this$).cfg)))->class$->createNode, $t1($t0, (n + 1)));
            ($t2 = ((struct Havlak$LoopTesterApp *)($t0 = &(*this$)))->class$->buildConnect, $t2($t0, 2, (n + 1)));
            n++;
            i = 0;
            while(1) {
                if( (i <= (pparLoops - 1)) ) {
                    top = n;
                    n = ($t3 = ((struct Havlak$LoopTesterApp *)($t0 = &(*this$)))->class$->buildStraight, $t3($t0, n, 1));
                    j = 0;
                    while(1) {
                        if( (j <= (ppparLoops - 1)) ) {
                            n = ($t4 = ((struct Havlak$LoopTesterApp *)($t0 = &(*this$)))->class$->buildBaseLoop, $t4($t0, n));
                            j = (j + 1);
                        } else {
                            break;
                        }
                    }
                    bottom = ($t3 = ((struct Havlak$LoopTesterApp *)($t0 = &(*this$)))->class$->buildStraight, $t3($t0, n, 1));
                    ($t2 = ((struct Havlak$LoopTesterApp *)($t0 = &(*this$)))->class$->buildConnect, $t2($t0, n, top));
                    n = bottom;
                    i = (i + 1);
                } else {
                    break;
                }
            }
            ($t2 = ((struct Havlak$LoopTesterApp *)($t0 = &(*this$)))->class$->buildConnect, $t2($t0, n, 1));
            parlooptrees = (parlooptrees + 1);
        } else {
            break;
        }
    }
}

void Havlak$LoopTesterApp$addDummyLoops(void* this, int32_t numDummyLoops) {
    struct Havlak$LoopTesterApp* this$ = this;
    int32_t dummyloop;
    void* $t0;
    void (* $t1)(void*, struct Havlak$LoopStructureGraph *);
    dummyloop = 0;
    dummyloop = 0;
    while(1) {
        if( (dummyloop <= (numDummyLoops - 1)) ) {
            ($t1 = ((struct Havlak$LoopTesterApp *)($t0 = &(*this$)))->class$->findLoops, $t1($t0, (*this$).lsg));
            dummyloop = (dummyloop + 1);
        } else {
            break;
        }
    }
}

void Havlak$LoopTesterApp$findLoops(void* this, struct Havlak$LoopStructureGraph * loopStructure) {
    struct Havlak$LoopTesterApp* this$ = this;
    struct Havlak$HavlakLoopFinder * finder;
    void* $t0;
    void (* $t1)(void*);
    finder = 0;
    finder = Havlak$createHavlakLoopFinder((*this$).cfg, loopStructure);
    ($t1 = ((struct Havlak$HavlakLoopFinder *)($t0 = &(*finder)))->class$->findLoops, $t1($t0));
}

void Havlak$LoopTesterApp$constructSimpleCFG(void* this) {
    struct Havlak$LoopTesterApp* this$ = this;
    struct Havlak$BasicBlockEdge * dummy2;
    struct Havlak$BasicBlock * dummy;
    int32_t dummy3;
    void* $t0;
    struct Havlak$BasicBlock * (* $t1)(void*, int32_t);
    int32_t (* $t2)(void*, int32_t);
    dummy2 = 0;
    dummy = 0;
    dummy3 = 0;
    dummy = ($t1 = ((struct Havlak$ControlFlowGraph *)($t0 = &(*(*this$).cfg)))->class$->createNode, $t1($t0, 0));
    dummy3 = ($t2 = ((struct Havlak$LoopTesterApp *)($t0 = &(*this$)))->class$->buildBaseLoop, $t2($t0, 0));
    dummy = ($t1 = ((struct Havlak$ControlFlowGraph *)($t0 = &(*(*this$).cfg)))->class$->createNode, $t1($t0, 1));
    dummy2 = Havlak$createEdge((*this$).cfg, 0, 2);
}

struct Havlak$IntIntResult * Havlak$LoopTesterApp$main(void* this, int32_t numDummyLoops, int32_t findLoopIterations, int32_t parLoops, int32_t pparLoops, int32_t ppparLoops) {
    struct Havlak$LoopTesterApp* this$ = this;
    int32_t i;
    struct Havlak$IntIntResult * res;
    void* $t0;
    void (* $t1)(void*);
    void (* $t2)(void*, int32_t);
    void (* $t3)(void*, int32_t, int32_t, int32_t);
    void (* $t4)(void*, struct Havlak$LoopStructureGraph *);
    struct Havlak$IntIntResult * $t5;
    int32_t (* $t6)(void*);
    i = 0;
    res = 0;
    ($t1 = ((struct Havlak$LoopTesterApp *)($t0 = &(*this$)))->class$->constructSimpleCFG, $t1($t0));
    ($t2 = ((struct Havlak$LoopTesterApp *)($t0 = &(*this$)))->class$->addDummyLoops, $t2($t0, numDummyLoops));
    ($t3 = ((struct Havlak$LoopTesterApp *)($t0 = &(*this$)))->class$->constructCFG, $t3($t0, parLoops, pparLoops, ppparLoops));
    ($t4 = ((struct Havlak$LoopTesterApp *)($t0 = &(*this$)))->class$->findLoops, $t4($t0, (*this$).lsg));
    i = 0;
    while(1) {
        if( (i <= (findLoopIterations - 1)) ) {
            ($t4 = ((struct Havlak$LoopTesterApp *)($t0 = &(*this$)))->class$->findLoops, $t4($t0, Havlak$createLoopStructureGraph()));
            i = (i + 1);
        } else {
            break;
        }
    }
    ($t1 = ((struct Havlak$LoopStructureGraph *)($t0 = &(*(*this$).lsg)))->class$->calculateNestingLevel, $t1($t0));
    $t5 = OBX$Alloc(sizeof(struct Havlak$IntIntResult));
    memset($t5,0,sizeof(struct Havlak$IntIntResult));
    res = $t5;
    Havlak$IntIntResult$init$($t5);
    (*res).res1 = ($t6 = ((struct som$Vector$2b688abfab$Vector *)($t0 = &(*(*(*this$).lsg).loops)))->class$->getSize, $t6($t0));
    (*res).res2 = ($t6 = ((struct Havlak$ControlFlowGraph *)($t0 = &(*(*this$).cfg)))->class$->getNumNodes, $t6($t0));
    return res;
}

struct Havlak$HavlakLoopFinder * Havlak$createHavlakLoopFinder(struct Havlak$ControlFlowGraph * cfg, struct Havlak$LoopStructureGraph * lsg) {
    struct Havlak$HavlakLoopFinder * this;
    struct Havlak$HavlakLoopFinder * $t0;
    this = 0;
    $t0 = OBX$Alloc(sizeof(struct Havlak$HavlakLoopFinder));
    memset($t0,0,sizeof(struct Havlak$HavlakLoopFinder));
    this = $t0;
    Havlak$HavlakLoopFinder$init$($t0);
    (*this).cfg = cfg;
    (*this).lsg = lsg;
    (*this).maxSize = 0;
    (*this).nonBackPreds = som$Vector$aa9eee315e$create();
    (*this).backPreds = som$Vector$bccc871b36$create();
    (*this).number = som$IdentityDictionary$84b2aa0859$create(Havlak$hashBasicBlock);
    return this;
}

int32_t Havlak$hashBasicBlock(struct Havlak$BasicBlock * * k) {
    return (*(*k)).name;
}

uint8_t Havlak$HavlakLoopFinder$isAncestor(void* this, int32_t w, int32_t v) {
    struct Havlak$HavlakLoopFinder* this$ = this;
    struct OBX$Array$1* $t0;
    return ((w <= v) && (v <= (*($t0 = (&(*this$).last),&((int32_t *)$t0->$a)[w]))));
}

int32_t Havlak$HavlakLoopFinder$doDFS(void* this, struct Havlak$BasicBlock * currentNode, int32_t current) {
    struct Havlak$HavlakLoopFinder* this$ = this;
    int32_t lastId;
    int32_t i;
    struct som$Vector$6226d61315$Vector * outerBlocks;
    struct Havlak$BasicBlock * target;
    void* $t0;
    void (* $t1)(void*, struct Havlak$BasicBlock *, int32_t);
    struct OBX$Array$1* $t2;
    void (* $t3)(void*, struct Havlak$BasicBlock * *, int32_t *);
    int32_t (* $t4)(void*);
    void* $t5;
    struct Havlak$BasicBlock * (* $t6)(void*, int32_t);
    int32_t (* $t7)(void*, struct Havlak$BasicBlock * *);
    int32_t (* $t8)(void*, struct Havlak$BasicBlock *, int32_t);
    lastId = 0;
    i = 0;
    outerBlocks = 0;
    target = 0;
    ($t1 = ((struct Havlak$UnionFindNode *)($t0 = &(*(*($t2 = (&(*this$).nodes),&((struct Havlak$UnionFindNode * *)$t2->$a)[current])))))->class$->initNode, $t1($t0, currentNode, current));
    ($t3 = ((struct som$Dictionary$84b2aa0859$Dictionary *)($t0 = &(*(*this$).number)))->class$->atPut, $t3($t0, &currentNode, &current));
    lastId = current;
    outerBlocks = (*currentNode).outEdges;
    i = 0;
    while(1) {
        if( (i <= (($t4 = ((struct som$Vector$6226d61315$Vector *)($t0 = &(*outerBlocks)))->class$->getSize, $t4($t0)) - 1)) ) {
            target = ($t6 = ((struct som$Vector$6226d61315$Vector *)($t5 = &(*outerBlocks)))->class$->at, $t6($t5, i));
            if( (($t7 = ((struct som$Dictionary$84b2aa0859$Dictionary *)($t0 = &(*(*this$).number)))->class$->at, $t7($t0, &target)) == 2147483647) ) {
                lastId = ($t8 = ((struct Havlak$HavlakLoopFinder *)($t5 = &(*this$)))->class$->doDFS, $t8($t5, target, (lastId + 1)));
            } 
            i = (i + 1);
        } else {
            break;
        }
    }
    (*($t2 = (&(*this$).last),&((int32_t *)$t2->$a)[current])) = lastId;
    return lastId;
}

void Havlak$HavlakLoopFinder$initAllNodes(void* this) {
    struct Havlak$HavlakLoopFinder* this$ = this;
    struct Havlak$HavlakLoopFinder$initAllNodes$FI iter;
    int32_t dummy;
    void* $t0;
    void (* $t1)(void*, struct som$Interfaces$6226d61315$ForEachInterface *);
    int32_t (* $t2)(void*, struct Havlak$BasicBlock *, int32_t);
    memset(&iter,0,sizeof(iter));
    Havlak$HavlakLoopFinder$initAllNodes$FI$init$(&iter);
    dummy = 0;
    iter.number = (*this$).number;
    ($t1 = ((struct som$Vector$6226d61315$Vector *)($t0 = &(*(*(*this$).cfg).basicBlockMap)))->class$->forEach, $t1($t0, ((struct som$Interfaces$6226d61315$ForEachInterface *)&iter)));
    dummy = ($t2 = ((struct Havlak$HavlakLoopFinder *)($t0 = &(*this$)))->class$->doDFS, $t2($t0, (*(*this$).cfg).startNode, 0));
}

void Havlak$HavlakLoopFinder$initAllNodes$FI$apply(void* this, struct Havlak$BasicBlock * * elem) {
    struct Havlak$HavlakLoopFinder$initAllNodes$FI* this$ = this;
    void* $t0;
    void (* $t1)(void*, struct Havlak$BasicBlock * *, int32_t *);
    ($t1 = ((struct som$Dictionary$84b2aa0859$Dictionary *)($t0 = &(*(*this$).number)))->class$->atPut, $t1($t0, &(*elem), &(int32_t){2147483647}));
}

void Havlak$HavlakLoopFinder$identifyEdges(void* this, int32_t size) {
    struct Havlak$HavlakLoopFinder* this$ = this;
    int32_t w;
    struct Havlak$BasicBlock * nodeW;
    struct OBX$Array$1* $t0;
    void* $t1;
    void (* $t2)(void*, struct Havlak$BasicBlock *, int32_t);
    w = 0;
    nodeW = 0;
    w = 0;
    while(1) {
        if( (w <= (size - 1)) ) {
            (*($t0 = (&(*this$).header),&((int32_t *)$t0->$a)[w])) = 0;
            (*($t0 = (&(*this$).type_),&((int *)$t0->$a)[w])) = 1;
            nodeW = (*(*($t0 = (&(*this$).nodes),&((struct Havlak$UnionFindNode * *)$t0->$a)[w]))).bb;
            if( ((void*)nodeW == (void*)0) ) {
                (*($t0 = (&(*this$).type_),&((int *)$t0->$a)[w])) = 5;
            } else {
                ($t2 = ((struct Havlak$HavlakLoopFinder *)($t1 = &(*this$)))->class$->processEdges, $t2($t1, nodeW, w));
            }
            w = (w + 1);
        } else {
            break;
        }
    }
}

void Havlak$HavlakLoopFinder$processEdges(void* this, struct Havlak$BasicBlock * nodeW, int32_t w) {
    struct Havlak$HavlakLoopFinder* this$ = this;
    struct Havlak$HavlakLoopFinder$processEdges$FI iter;
    void* $t0;
    int32_t (* $t1)(void*);
    void* $t2;
    void (* $t3)(void*, struct som$Interfaces$6226d61315$ForEachInterface *);
    memset(&iter,0,sizeof(iter));
    Havlak$HavlakLoopFinder$processEdges$FI$init$(&iter);
    iter.this = this$;
    iter.w = w;
    if( (($t1 = ((struct som$Vector$6226d61315$Vector *)($t0 = &(*(*nodeW).inEdges)))->class$->getSize, $t1($t0)) > 0) ) {
        ($t3 = ((struct som$Vector$6226d61315$Vector *)($t2 = &(*(*nodeW).inEdges)))->class$->forEach, $t3($t2, ((struct som$Interfaces$6226d61315$ForEachInterface *)&iter)));
    } 
}

void Havlak$HavlakLoopFinder$processEdges$FI$apply(void* this, struct Havlak$BasicBlock * * nodeV) {
    struct Havlak$HavlakLoopFinder$processEdges$FI* this$ = this;
    int32_t v;
    struct som$Set$04445da84e$Set * tmp;
    void* $t0;
    int32_t (* $t1)(void*, struct Havlak$BasicBlock * *);
    uint8_t (* $t2)(void*, int32_t, int32_t);
    void* $t3;
    void (* $t4)(void*, int32_t *);
    void* $t5;
    struct som$Vector$04445da84e$Vector * (* $t6)(void*, int32_t);
    struct som$Set$04445da84e$Set * (* $t7)(void*, int32_t);
    v = 0;
    tmp = 0;
    v = ($t1 = ((struct som$Dictionary$84b2aa0859$Dictionary *)($t0 = &(*(*(*this$).this).number)))->class$->at, $t1($t0, &(*nodeV)));
    if( (v != 2147483647) ) {
        if( ($t2 = ((struct Havlak$HavlakLoopFinder *)($t0 = &(*(*this$).this)))->class$->isAncestor, $t2($t0, (*this$).w, v)) ) {
            ($t4 = ((struct som$Vector$04445da84e$Vector *)($t3 = &(*($t6 = ((struct som$Vector$bccc871b36$Vector *)($t5 = &(*(*(*this$).this).backPreds)))->class$->at, $t6($t5, (*this$).w)))))->class$->append, $t4($t3, &v));
        } else {
            ($t4 = ((struct som$Set$04445da84e$Set *)($t0 = &(*($t7 = ((struct som$Vector$aa9eee315e$Vector *)($t3 = &(*(*(*this$).this).nonBackPreds)))->class$->at, $t7($t3, (*this$).w)))))->class$->add, $t4($t0, &v));
        }
    } 
}

void Havlak$HavlakLoopFinder$findLoops(void* this) {
    struct Havlak$HavlakLoopFinder* this$ = this;
    int32_t size;
    int32_t i;
    int32_t w;
    int32_t nonBackSize;
    struct som$Set$04445da84e$Set * s;
    struct som$Vector$04445da84e$Vector * v;
    struct som$Vector$d944f549ff$Vector * nodePool;
    struct som$Vector$d944f549ff$Vector * workList;
    struct Havlak$BasicBlock * nodeW;
    struct Havlak$HavlakLoopFinder$findLoops$FI1 niter;
    struct Havlak$UnionFindNode * x;
    struct Havlak$SimpleLoop * looop;
    void* $t0;
    int32_t (* $t1)(void*);
    void (* $t2)(void*);
    int32_t * $t3;
    int * $t4;
    struct Havlak$UnionFindNode * * $t5;
    void (* $t6)(void*, struct som$Set$04445da84e$Set * *);
    void (* $t7)(void*, struct som$Vector$04445da84e$Vector * *);
    struct Havlak$UnionFindNode * $t8;
    struct OBX$Array$1* $t9;
    void (* $t10)(void*, int32_t);
    void (* $t11)(void*, int32_t, struct som$Vector$d944f549ff$Vector *);
    void (* $t12)(void*, struct som$Interfaces$d944f549ff$ForEachInterface *);
    uint8_t (* $t13)(void*);
    void* $t14;
    struct Havlak$UnionFindNode * (* $t15)(void*);
    struct som$Set$04445da84e$Set * (* $t16)(void*, int32_t);
    void (* $t17)(void*, int32_t, struct som$Vector$d944f549ff$Vector *, struct som$Vector$d944f549ff$Vector *, struct Havlak$UnionFindNode *);
    struct Havlak$SimpleLoop * (* $t18)(void*, struct Havlak$BasicBlock *);
    void (* $t19)(void*, int32_t, struct som$Vector$d944f549ff$Vector *, struct Havlak$SimpleLoop *);
    size = 0;
    i = 0;
    w = 0;
    nonBackSize = 0;
    s = 0;
    v = 0;
    nodePool = 0;
    workList = 0;
    nodeW = 0;
    memset(&niter,0,sizeof(niter));
    Havlak$HavlakLoopFinder$findLoops$FI1$init$(&niter);
    x = 0;
    looop = 0;
    if( ((void*)(*(*this$).cfg).startNode == (void*)0) ) {
        return ;
    } 
    size = ($t1 = ((struct Havlak$ControlFlowGraph *)($t0 = &(*(*this$).cfg)))->class$->getNumNodes, $t1($t0));
    ($t2 = ((struct som$Vector$aa9eee315e$Vector *)($t0 = &(*(*this$).nonBackPreds)))->class$->removeAll, $t2($t0));
    ($t2 = ((struct som$Vector$bccc871b36$Vector *)($t0 = &(*(*this$).backPreds)))->class$->removeAll, $t2($t0));
    ($t2 = ((struct som$Dictionary$84b2aa0859$Dictionary *)($t0 = &(*(*this$).number)))->class$->removeAll, $t2($t0));
    if( (size > (*this$).maxSize) ) {
        {int $0 = size, $n = $0, $s=sizeof(int32_t); $t3 = OBX$Alloc($s*$n); memset($t3,0,$s*$n); (*this$).header = (struct OBX$Array$1){$0, 1, $t3};};
        {int $0 = size, $n = $0, $s=sizeof(int); $t4 = OBX$Alloc($s*$n); memset($t4,0,$s*$n); (*this$).type_ = (struct OBX$Array$1){$0, 1, $t4};};
        {int $0 = size, $n = $0, $s=sizeof(int32_t); $t3 = OBX$Alloc($s*$n); memset($t3,0,$s*$n); (*this$).last = (struct OBX$Array$1){$0, 1, $t3};};
        {int $0 = size, $n = $0, $s=sizeof(struct Havlak$UnionFindNode *); $t5 = OBX$Alloc($s*$n); memset($t5,0,$s*$n); (*this$).nodes = (struct OBX$Array$1){$0, 1, $t5};};
        (*this$).maxSize = size;
    } 
    i = 0;
    while(1) {
        if( (i <= (size - 1)) ) {
            s = som$Set$04445da84e$create();
            ($t6 = ((struct som$Vector$aa9eee315e$Vector *)($t0 = &(*(*this$).nonBackPreds)))->class$->append, $t6($t0, &s));
            v = som$Vector$04445da84e$create();
            ($t7 = ((struct som$Vector$bccc871b36$Vector *)($t0 = &(*(*this$).backPreds)))->class$->append, $t7($t0, &v));
            $t8 = OBX$Alloc(sizeof(struct Havlak$UnionFindNode));
            memset($t8,0,sizeof(struct Havlak$UnionFindNode));
            (*($t9 = (&(*this$).nodes),&((struct Havlak$UnionFindNode * *)$t9->$a)[i])) = $t8;
            Havlak$UnionFindNode$init$($t8);
            i = (i + 1);
        } else {
            break;
        }
    }
    ($t2 = ((struct Havlak$HavlakLoopFinder *)($t0 = &(*this$)))->class$->initAllNodes, $t2($t0));
    ($t10 = ((struct Havlak$HavlakLoopFinder *)($t0 = &(*this$)))->class$->identifyEdges, $t10($t0, size));
    (*($t9 = (&(*this$).header),&((int32_t *)$t9->$a)[0])) = 0;
    w = (size - 1);
    while(1) {
        if( (w >= 0) ) {
            nodePool = som$Vector$d944f549ff$create();
            nodeW = (*(*($t9 = (&(*this$).nodes),&((struct Havlak$UnionFindNode * *)$t9->$a)[w]))).bb;
            if( ((void*)nodeW != (void*)0) ) {
                ($t11 = ((struct Havlak$HavlakLoopFinder *)($t0 = &(*this$)))->class$->stepD, $t11($t0, w, nodePool));
                workList = som$Vector$d944f549ff$create();
                niter.workList = workList;
                ($t12 = ((struct som$Vector$d944f549ff$Vector *)($t0 = &(*nodePool)))->class$->forEach, $t12($t0, ((struct som$Interfaces$d944f549ff$ForEachInterface *)&niter)));
                if( (($t1 = ((struct som$Vector$d944f549ff$Vector *)($t0 = &(*nodePool)))->class$->getSize, $t1($t0)) != 0) ) {
                    (*($t9 = (&(*this$).type_),&((int *)$t9->$a)[w])) = 2;
                } 
                while(1) {
                    if( (!($t13 = ((struct som$Vector$d944f549ff$Vector *)($t0 = &(*workList)))->class$->isEmpty, $t13($t0))) ) {
                        x = ($t15 = ((struct som$Vector$d944f549ff$Vector *)($t14 = &(*workList)))->class$->removeFirst, $t15($t14));
                        nonBackSize = ($t1 = ((struct som$Set$04445da84e$Set *)($t0 = &(*($t16 = ((struct som$Vector$aa9eee315e$Vector *)($t14 = &(*(*this$).nonBackPreds)))->class$->at, $t16($t14, (*x).dfsNumber)))))->class$->getSize, $t1($t0));
                        if( (nonBackSize > 32768) ) {
                            return ;
                        } 
                        ($t17 = ((struct Havlak$HavlakLoopFinder *)($t0 = &(*this$)))->class$->stepEProcessNonBackPreds, $t17($t0, w, nodePool, workList, x));
                    } else {
                        break;
                    }
                }
                if( ((($t1 = ((struct som$Vector$d944f549ff$Vector *)($t0 = &(*nodePool)))->class$->getSize, $t1($t0)) > 0) || ((*($t9 = (&(*this$).type_),&((int *)$t9->$a)[w])) == 3)) ) {
                    looop = ($t18 = ((struct Havlak$LoopStructureGraph *)($t14 = &(*(*this$).lsg)))->class$->createNewLoop, $t18($t14, nodeW));
                    ($t19 = ((struct Havlak$HavlakLoopFinder *)($t0 = &(*this$)))->class$->setLoopAttributes, $t19($t0, w, nodePool, looop));
                } 
            } 
            w = (w + (-1));
        } else {
            break;
        }
    }
}

void Havlak$HavlakLoopFinder$findLoops$FI1$apply(void* this, struct Havlak$UnionFindNode * * elem) {
    struct Havlak$HavlakLoopFinder$findLoops$FI1* this$ = this;
    void* $t0;
    void (* $t1)(void*, struct Havlak$UnionFindNode * *);
    ($t1 = ((struct som$Vector$d944f549ff$Vector *)($t0 = &(*(*this$).workList)))->class$->append, $t1($t0, &(*elem)));
}

void Havlak$HavlakLoopFinder$stepEProcessNonBackPreds(void* this, int32_t w, struct som$Vector$d944f549ff$Vector * nodePool, struct som$Vector$d944f549ff$Vector * workList, struct Havlak$UnionFindNode * x) {
    struct Havlak$HavlakLoopFinder* this$ = this;
    struct Havlak$HavlakLoopFinder$stepEProcessNonBackPreds$FI iter;
    void* $t0;
    void (* $t1)(void*, struct som$Interfaces$04445da84e$ForEachInterface *);
    void* $t2;
    struct som$Set$04445da84e$Set * (* $t3)(void*, int32_t);
    memset(&iter,0,sizeof(iter));
    Havlak$HavlakLoopFinder$stepEProcessNonBackPreds$FI$init$(&iter);
    iter.this = this$;
    iter.nodePool = nodePool;
    iter.workList = workList;
    iter.w = w;
    ($t1 = ((struct som$Set$04445da84e$Set *)($t0 = &(*($t3 = ((struct som$Vector$aa9eee315e$Vector *)($t2 = &(*(*this$).nonBackPreds)))->class$->at, $t3($t2, (*x).dfsNumber)))))->class$->forEach, $t1($t0, ((struct som$Interfaces$04445da84e$ForEachInterface *)&iter)));
}

void Havlak$HavlakLoopFinder$stepEProcessNonBackPreds$FI$apply(void* this, int32_t * elem) {
    struct Havlak$HavlakLoopFinder$stepEProcessNonBackPreds$FI* this$ = this;
    struct Havlak$UnionFindNode * y;
    struct Havlak$UnionFindNode * ydash;
    struct Havlak$HavlakLoopFinder$stepEProcessNonBackPreds$FI$apply$TI iter;
    struct som$Set$04445da84e$Set * tmp;
    struct OBX$Array$1* $t0;
    void* $t1;
    struct Havlak$UnionFindNode * (* $t2)(void*);
    uint8_t (* $t3)(void*, int32_t, int32_t);
    void (* $t4)(void*, int32_t *);
    void* $t5;
    struct som$Set$04445da84e$Set * (* $t6)(void*, int32_t);
    uint8_t (* $t7)(void*, struct som$Interfaces$d944f549ff$TestInterface *);
    void (* $t8)(void*, struct Havlak$UnionFindNode * *);
    y = 0;
    ydash = 0;
    memset(&iter,0,sizeof(iter));
    Havlak$HavlakLoopFinder$stepEProcessNonBackPreds$FI$apply$TI$init$(&iter);
    tmp = 0;
    y = (*($t0 = (&(*(*this$).this).nodes),&((struct Havlak$UnionFindNode * *)$t0->$a)[(*elem)]));
    ydash = ($t2 = ((struct Havlak$UnionFindNode *)($t1 = &(*y)))->class$->findSet, $t2($t1));
    if( (!($t3 = ((struct Havlak$HavlakLoopFinder *)($t1 = &(*(*this$).this)))->class$->isAncestor, $t3($t1, (*this$).w, (*ydash).dfsNumber))) ) {
        (*($t0 = (&(*(*this$).this).type_),&((int *)$t0->$a)[(*this$).w])) = 4;
        ($t4 = ((struct som$Set$04445da84e$Set *)($t1 = &(*($t6 = ((struct som$Vector$aa9eee315e$Vector *)($t5 = &(*(*(*this$).this).nonBackPreds)))->class$->at, $t6($t5, (*this$).w)))))->class$->add, $t4($t1, &(*ydash).dfsNumber));
    } else {
        if( ((*ydash).dfsNumber != (*this$).w) ) {
            iter.ydash = ydash;
            if( (!($t7 = ((struct som$Vector$d944f549ff$Vector *)($t1 = &(*(*this$).nodePool)))->class$->hasSome, $t7($t1, ((struct som$Interfaces$d944f549ff$TestInterface *)&iter)))) ) {
                ($t8 = ((struct som$Vector$d944f549ff$Vector *)($t5 = &(*(*this$).workList)))->class$->append, $t8($t5, &ydash));
                ($t8 = ((struct som$Vector$d944f549ff$Vector *)($t1 = &(*(*this$).nodePool)))->class$->append, $t8($t1, &ydash));
            } 
        } 
    }
}

uint8_t Havlak$HavlakLoopFinder$stepEProcessNonBackPreds$FI$apply$TI$test(void* this, struct Havlak$UnionFindNode * * elem) {
    struct Havlak$HavlakLoopFinder$stepEProcessNonBackPreds$FI$apply$TI* this$ = this;
    return ((void*)(*elem) == (void*)(*this$).ydash);
}

void Havlak$HavlakLoopFinder$setLoopAttributes(void* this, int32_t w, struct som$Vector$d944f549ff$Vector * nodePool, struct Havlak$SimpleLoop * looop) {
    struct Havlak$HavlakLoopFinder* this$ = this;
    struct Havlak$HavlakLoopFinder$setLoopAttributes$FI iter;
    struct OBX$Array$1* $t0;
    void* $t1;
    void (* $t2)(void*, struct som$Interfaces$d944f549ff$ForEachInterface *);
    memset(&iter,0,sizeof(iter));
    Havlak$HavlakLoopFinder$setLoopAttributes$FI$init$(&iter);
    (*(*($t0 = (&(*this$).nodes),&((struct Havlak$UnionFindNode * *)$t0->$a)[w]))).looop = looop;
    iter.this = this$;
    iter.w = w;
    iter.looop = looop;
    ($t2 = ((struct som$Vector$d944f549ff$Vector *)($t1 = &(*nodePool)))->class$->forEach, $t2($t1, ((struct som$Interfaces$d944f549ff$ForEachInterface *)&iter)));
}

void Havlak$HavlakLoopFinder$setLoopAttributes$FI$apply(void* this, struct Havlak$UnionFindNode * * node) {
    struct Havlak$HavlakLoopFinder$setLoopAttributes$FI* this$ = this;
    struct OBX$Array$1* $t0;
    void* $t1;
    void (* $t2)(void*, struct Havlak$UnionFindNode *);
    void (* $t3)(void*, struct Havlak$SimpleLoop *);
    void (* $t4)(void*, struct Havlak$BasicBlock * *);
    (*($t0 = (&(*(*this$).this).header),&((int32_t *)$t0->$a)[(*(*node)).dfsNumber])) = (*this$).w;
    ($t2 = ((struct Havlak$UnionFindNode *)($t1 = &(*(*node))))->class$->union_, $t2($t1, (*($t0 = (&(*(*this$).this).nodes),&((struct Havlak$UnionFindNode * *)$t0->$a)[(*this$).w]))));
    if( ((void*)(*(*node)).looop != (void*)0) ) {
        ($t3 = ((struct Havlak$SimpleLoop *)($t1 = &(*(*(*node)).looop)))->class$->setParent, $t3($t1, (*this$).looop));
    } else {
        ($t4 = ((struct som$Set$6226d61315$Set *)($t1 = &(*(*(*this$).looop).basicBlocks)))->class$->add, $t4($t1, &(*(*node)).bb));
    }
}

void Havlak$HavlakLoopFinder$stepD(void* this, int32_t w, struct som$Vector$d944f549ff$Vector * nodePool) {
    struct Havlak$HavlakLoopFinder* this$ = this;
    struct Havlak$HavlakLoopFinder$stepD$FI iter;
    void* $t0;
    void (* $t1)(void*, struct som$Interfaces$04445da84e$ForEachInterface *);
    void* $t2;
    struct som$Vector$04445da84e$Vector * (* $t3)(void*, int32_t);
    memset(&iter,0,sizeof(iter));
    Havlak$HavlakLoopFinder$stepD$FI$init$(&iter);
    iter.this = this$;
    iter.w = w;
    iter.nodePool = nodePool;
    ($t1 = ((struct som$Vector$04445da84e$Vector *)($t0 = &(*($t3 = ((struct som$Vector$bccc871b36$Vector *)($t2 = &(*(*this$).backPreds)))->class$->at, $t3($t2, w)))))->class$->forEach, $t1($t0, ((struct som$Interfaces$04445da84e$ForEachInterface *)&iter)));
}

void Havlak$HavlakLoopFinder$stepD$FI$apply(void* this, int32_t * v) {
    struct Havlak$HavlakLoopFinder$stepD$FI* this$ = this;
    void* $t0;
    void (* $t1)(void*, struct Havlak$UnionFindNode * *);
    void* $t2;
    struct Havlak$UnionFindNode * (* $t3)(void*);
    struct OBX$Array$1* $t4;
    if( ((*v) != (*this$).w) ) {
        ($t1 = ((struct som$Vector$d944f549ff$Vector *)($t0 = &(*(*this$).nodePool)))->class$->append, $t1($t0, &((struct Havlak$UnionFindNode *[1]){($t3 = ((struct Havlak$UnionFindNode *)($t2 = &(*(*($t4 = (&(*(*this$).this).nodes),&((struct Havlak$UnionFindNode * *)$t4->$a)[(*v)])))))->class$->findSet, $t3($t2))})[0]));
    } else {
        (*($t4 = (&(*(*this$).this).type_),&((int *)$t4->$a)[(*this$).w])) = 3;
    }
}

struct Havlak$HavlakLoopFinder$findLoops$FI1$Class$ Havlak$HavlakLoopFinder$findLoops$FI1$class$ = { 
    &som$Interfaces$d944f549ff$ForEachInterface$class$,
    Havlak$HavlakLoopFinder$findLoops$FI1$apply,
};

struct Havlak$Havlak$Class$ Havlak$Havlak$class$ = { 
    &Benchmark$Benchmark$class$,
    Havlak$Havlak$benchmark,
    Havlak$Havlak$verifyResult,
    Havlak$Havlak$innerBenchmarkLoop,
};

struct Havlak$LoopStructureGraph$Class$ Havlak$LoopStructureGraph$class$ = { 
    0,
    Havlak$LoopStructureGraph$createNewLoop,
    Havlak$LoopStructureGraph$calculateNestingLevel,
    Havlak$LoopStructureGraph$calculateNestingLevelRec,
};

struct Havlak$HavlakLoopFinder$Class$ Havlak$HavlakLoopFinder$class$ = { 
    0,
    Havlak$HavlakLoopFinder$isAncestor,
    Havlak$HavlakLoopFinder$doDFS,
    Havlak$HavlakLoopFinder$initAllNodes,
    Havlak$HavlakLoopFinder$identifyEdges,
    Havlak$HavlakLoopFinder$processEdges,
    Havlak$HavlakLoopFinder$findLoops,
    Havlak$HavlakLoopFinder$stepEProcessNonBackPreds,
    Havlak$HavlakLoopFinder$setLoopAttributes,
    Havlak$HavlakLoopFinder$stepD,
};

struct Havlak$LoopStructureGraph$calculateNestingLevelRec$FI$Class$ Havlak$LoopStructureGraph$calculateNestingLevelRec$FI$class$ = { 
    &som$Interfaces$2b688abfab$ForEachInterface$class$,
    Havlak$LoopStructureGraph$calculateNestingLevelRec$FI$apply,
};

struct Havlak$UnionFindNode$findSet$FI$Class$ Havlak$UnionFindNode$findSet$FI$class$ = { 
    &som$Interfaces$d944f549ff$ForEachInterface$class$,
    Havlak$UnionFindNode$findSet$FI$apply,
};

struct Havlak$LoopStructureGraph$calculateNestingLevel$FI$Class$ Havlak$LoopStructureGraph$calculateNestingLevel$FI$class$ = { 
    &som$Interfaces$2b688abfab$ForEachInterface$class$,
    Havlak$LoopStructureGraph$calculateNestingLevel$FI$apply,
};

struct Havlak$IntIntResult$Class$ Havlak$IntIntResult$class$ = { 
    &Benchmark$Result$class$,
};

struct Havlak$BasicBlock$Class$ Havlak$BasicBlock$class$ = { 
    0,
};

struct Havlak$HavlakLoopFinder$stepEProcessNonBackPreds$FI$apply$TI$Class$ Havlak$HavlakLoopFinder$stepEProcessNonBackPreds$FI$apply$TI$class$ = { 
    &som$Interfaces$d944f549ff$TestInterface$class$,
    Havlak$HavlakLoopFinder$stepEProcessNonBackPreds$FI$apply$TI$test,
};

struct Havlak$SimpleLoop$Class$ Havlak$SimpleLoop$class$ = { 
    0,
    Havlak$SimpleLoop$setParent,
    Havlak$SimpleLoop$setNestingLevel,
};

struct Havlak$HavlakLoopFinder$setLoopAttributes$FI$Class$ Havlak$HavlakLoopFinder$setLoopAttributes$FI$class$ = { 
    &som$Interfaces$d944f549ff$ForEachInterface$class$,
    Havlak$HavlakLoopFinder$setLoopAttributes$FI$apply,
};

struct Havlak$HavlakLoopFinder$processEdges$FI$Class$ Havlak$HavlakLoopFinder$processEdges$FI$class$ = { 
    &som$Interfaces$6226d61315$ForEachInterface$class$,
    Havlak$HavlakLoopFinder$processEdges$FI$apply,
};

struct Havlak$HavlakLoopFinder$initAllNodes$FI$Class$ Havlak$HavlakLoopFinder$initAllNodes$FI$class$ = { 
    &som$Interfaces$6226d61315$ForEachInterface$class$,
    Havlak$HavlakLoopFinder$initAllNodes$FI$apply,
};

struct Havlak$BasicBlockEdge$Class$ Havlak$BasicBlockEdge$class$ = { 
    0,
};

struct Havlak$UnionFindNode$Class$ Havlak$UnionFindNode$class$ = { 
    0,
    Havlak$UnionFindNode$initNode,
    Havlak$UnionFindNode$union,
    Havlak$UnionFindNode$findSet,
};

struct Havlak$HavlakLoopFinder$stepD$FI$Class$ Havlak$HavlakLoopFinder$stepD$FI$class$ = { 
    &som$Interfaces$04445da84e$ForEachInterface$class$,
    Havlak$HavlakLoopFinder$stepD$FI$apply,
};

struct Havlak$ControlFlowGraph$Class$ Havlak$ControlFlowGraph$class$ = { 
    0,
    Havlak$ControlFlowGraph$createNode,
    Havlak$ControlFlowGraph$getNumNodes,
};

struct Havlak$LoopTesterApp$Class$ Havlak$LoopTesterApp$class$ = { 
    0,
    Havlak$LoopTesterApp$buildDiamond,
    Havlak$LoopTesterApp$buildConnect,
    Havlak$LoopTesterApp$buildStraight,
    Havlak$LoopTesterApp$buildBaseLoop,
    Havlak$LoopTesterApp$constructCFG,
    Havlak$LoopTesterApp$addDummyLoops,
    Havlak$LoopTesterApp$findLoops,
    Havlak$LoopTesterApp$constructSimpleCFG,
    Havlak$LoopTesterApp$main,
};

struct Havlak$HavlakLoopFinder$stepEProcessNonBackPreds$FI$Class$ Havlak$HavlakLoopFinder$stepEProcessNonBackPreds$FI$class$ = { 
    &som$Interfaces$04445da84e$ForEachInterface$class$,
    Havlak$HavlakLoopFinder$stepEProcessNonBackPreds$FI$apply,
};

static int initDone$ = 0;
void Havlak$init$(void) {
    if(initDone$) return; else initDone$ = 1;
    Benchmark$init$();
    Out$init$();
    som$Vector$6226d61315$init$();
    som$Vector$6184042aef$init$();
    som$IdentitySet$6226d61315$init$();
    som$IdentitySet$2b688abfab$init$();
    som$Vector$d944f549ff$init$();
    som$Vector$2b688abfab$init$();
    som$Set$04445da84e$init$();
    som$Vector$aa9eee315e$init$();
    som$Vector$04445da84e$init$();
    som$Vector$bccc871b36$init$();
    som$IdentityDictionary$84b2aa0859$init$();
}
OBX$Cmd Havlak$cmd$(const char* name) {
    if( name == 0 ) return Havlak$init$;
    return 0;
}
