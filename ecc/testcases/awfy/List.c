// Generated by Oberon+ IDE (Mono) 0.9.106 on 2024-07-13T01:26:30

#include "List.h"

void List$Element$init$(struct List$Element* inst){
    inst->class$ = &List$Element$class$;
}
void List$List$init$(struct List$List* inst){
    inst->class$ = &List$List$class$;
}
int32_t List$Element$length(void* this) {
    struct List$Element* this$ = this;
    void* $t0;
    int32_t (* $t1)(void*);
    if( ((void*)(*this$).next == (void*)0) ) {
        return 1;
    } else {
        return (1 + ($t1 = ((struct List$Element *)($t0 = &(*(*this$).next)))->class$->length, $t1($t0)));
    }
    return 0;
}

struct List$Element * List$List$makeList(void* this, int32_t length) {
    struct List$List* this$ = this;
    struct List$Element * e;
    void* $t0;
    struct List$Element * (* $t1)(void*, int32_t);
    e = 0;
    if( (length == 0) ) {
        return 0;
    } else {
        e = List$createElem(length);
        (*e).next = ($t1 = ((struct List$List *)($t0 = &(*this$)))->class$->makeList, $t1($t0, (length - 1)));
        return e;
    }
    return 0;
}

uint8_t List$List$isShorterThan(void* this, struct List$Element * x, struct List$Element * y) {
    struct List$List* this$ = this;
    struct List$Element * xTail;
    struct List$Element * yTail;
    xTail = 0;
    yTail = 0;
    xTail = x;
    yTail = y;
    while(1) {
        if( ((void*)yTail != (void*)0) ) {
            if( ((void*)xTail == (void*)0) ) {
                return 1;
            } 
            xTail = (*xTail).next;
            yTail = (*yTail).next;
        } else {
            break;
        }
    }
    return 0;
}

struct List$Element * List$List$tail(void* this, struct List$Element * x, struct List$Element * y, struct List$Element * z) {
    struct List$List* this$ = this;
    void* $t0;
    uint8_t (* $t1)(void*, struct List$Element *, struct List$Element *);
    void* $t2;
    struct List$Element * (* $t3)(void*, struct List$Element *, struct List$Element *, struct List$Element *);
    void* $t4;
    struct List$Element * (* $t5)(void*, struct List$Element *, struct List$Element *, struct List$Element *);
    void* $t6;
    struct List$Element * (* $t7)(void*, struct List$Element *, struct List$Element *, struct List$Element *);
    void* $t8;
    struct List$Element * (* $t9)(void*, struct List$Element *, struct List$Element *, struct List$Element *);
    if( ($t1 = ((struct List$List *)($t0 = &(*this$)))->class$->isShorterThan, $t1($t0, y, x)) ) {
        return ($t3 = ((struct List$List *)($t2 = &(*this$)))->class$->tail, $t3($t2, ($t5 = ((struct List$List *)($t4 = &(*this$)))->class$->tail, $t5($t4, (*x).next, y, z)), ($t7 = ((struct List$List *)($t6 = &(*this$)))->class$->tail, $t7($t6, (*y).next, z, x)), ($t9 = ((struct List$List *)($t8 = &(*this$)))->class$->tail, $t9($t8, (*z).next, x, y))));
    } else {
        return z;
    }
    return 0;
}

struct List$Element * List$createElem(int32_t val) {
    struct List$Element * e;
    struct List$Element * $t0;
    e = 0;
    $t0 = OBX$Alloc(sizeof(struct List$Element));
    memset($t0,0,sizeof(struct List$Element));
    e = $t0;
    List$Element$init$($t0);
    (*e).val = val;
    return e;
}

struct List$List * List$create() {
    struct List$List * b;
    struct List$List * $t0;
    b = 0;
    $t0 = OBX$Alloc(sizeof(struct List$List));
    memset($t0,0,sizeof(struct List$List));
    b = $t0;
    List$List$init$($t0);
    return b;
}

struct Benchmark$Result * List$List$benchmark(void* this) {
    struct List$List* this$ = this;
    struct List$Element * result;
    struct Benchmark$IntResult * res;
    void* $t0;
    struct List$Element * (* $t1)(void*, struct List$Element *, struct List$Element *, struct List$Element *);
    void* $t2;
    struct List$Element * (* $t3)(void*, int32_t);
    void* $t4;
    struct List$Element * (* $t5)(void*, int32_t);
    void* $t6;
    struct List$Element * (* $t7)(void*, int32_t);
    struct Benchmark$IntResult * $t8;
    int32_t (* $t9)(void*);
    result = 0;
    res = 0;
    result = ($t1 = ((struct List$List *)($t0 = &(*this$)))->class$->tail, $t1($t0, ($t3 = ((struct List$List *)($t2 = &(*this$)))->class$->makeList, $t3($t2, 15)), ($t5 = ((struct List$List *)($t4 = &(*this$)))->class$->makeList, $t5($t4, 10)), ($t7 = ((struct List$List *)($t6 = &(*this$)))->class$->makeList, $t7($t6, 6))));
    $t8 = OBX$Alloc(sizeof(struct Benchmark$IntResult));
    memset($t8,0,sizeof(struct Benchmark$IntResult));
    res = $t8;
    Benchmark$IntResult$init$($t8);
    (*res).res = ($t9 = ((struct List$Element *)($t0 = &(*result)))->class$->length, $t9($t0));
    return ((struct Benchmark$Result *)res);
}

uint8_t List$List$verifyResult(void* this, struct Benchmark$Result * result) {
    struct List$List* this$ = this;
    return ((*((struct Benchmark$IntResult*)result)).res == 10);
}

struct List$Element$Class$ List$Element$class$ = { 
    0,
    List$Element$length,
};

struct List$List$Class$ List$List$class$ = { 
    &Benchmark$Benchmark$class$,
    List$List$benchmark,
    List$List$verifyResult,
    Benchmark$Benchmark$innerBenchmarkLoop,
    List$List$makeList,
    List$List$isShorterThan,
    List$List$tail,
};

static int initDone$ = 0;
void List$init$(void) {
    if(initDone$) return; else initDone$ = 1;
    Benchmark$init$();
}
OBX$Cmd List$cmd$(const char* name) {
    if( name == 0 ) return List$init$;
    return 0;
}
