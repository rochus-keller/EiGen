// Generated by Oberon+ IDE (Mono) 0.9.106 on 2024-07-13T01:26:30

#include "Richards.h"

void Richards$TaskControlBlock$init$(struct Richards$TaskControlBlock* inst){
    inst->class$ = &Richards$TaskControlBlock$class$;
}
void Richards$Scheduler$createWorker$PF$init$(struct Richards$Scheduler$createWorker$PF* inst){
    inst->class$ = &Richards$Scheduler$createWorker$PF$class$;
}
void Richards$HandlerTaskDataRecord$init$(struct Richards$HandlerTaskDataRecord* inst){
    inst->class$ = &Richards$HandlerTaskDataRecord$class$;
}
void Richards$DeviceTaskDataRecord$init$(struct Richards$DeviceTaskDataRecord* inst){
    inst->class$ = &Richards$DeviceTaskDataRecord$class$;
}
void Richards$Richards$init$(struct Richards$Richards* inst){
    inst->class$ = &Richards$Richards$class$;
}
void Richards$Scheduler$createIdler$PF$init$(struct Richards$Scheduler$createIdler$PF* inst){
    inst->class$ = &Richards$Scheduler$createIdler$PF$class$;
}
void Richards$WorkerTaskDataRecord$init$(struct Richards$WorkerTaskDataRecord* inst){
    inst->class$ = &Richards$WorkerTaskDataRecord$class$;
}
void Richards$RBObject$init$(struct Richards$RBObject* inst){
    inst->class$ = &Richards$RBObject$class$;
}
void Richards$TaskState$init$(struct Richards$TaskState* inst){
    inst->class$ = &Richards$TaskState$class$;
}
void Richards$Scheduler$createDevice$PF$init$(struct Richards$Scheduler$createDevice$PF* inst){
    inst->class$ = &Richards$Scheduler$createDevice$PF$class$;
}
void Richards$Scheduler$createHandler$PF$init$(struct Richards$Scheduler$createHandler$PF* inst){
    inst->class$ = &Richards$Scheduler$createHandler$PF$class$;
}
void Richards$Scheduler$init$(struct Richards$Scheduler* inst){
    inst->class$ = &Richards$Scheduler$class$;
}
void Richards$Packet$init$(struct Richards$Packet* inst){
    inst->class$ = &Richards$Packet$class$;
}
void Richards$ProcessFunction$init$(struct Richards$ProcessFunction* inst){
    inst->class$ = &Richards$ProcessFunction$class$;
}
void Richards$IdleTaskDataRecord$init$(struct Richards$IdleTaskDataRecord* inst){
    inst->class$ = &Richards$IdleTaskDataRecord$class$;
}
uint8_t Richards$TRACING = 0;
struct Richards$Richards * Richards$create() {
    struct Richards$Richards * r;
    struct Richards$Richards * $t0;
    r = 0;
    $t0 = OBX$Alloc(sizeof(struct Richards$Richards));
    memset($t0,0,sizeof(struct Richards$Richards));
    r = $t0;
    Richards$Richards$init$($t0);
    return r;
}

struct Benchmark$Result * Richards$Richards$benchmark(void* this) {
    struct Richards$Richards* this$ = this;
    struct Benchmark$BoolResult * res;
    struct Richards$Scheduler * s;
    struct Richards$Scheduler * $t0;
    struct Benchmark$BoolResult * $t1;
    void* $t2;
    uint8_t (* $t3)(void*);
    res = 0;
    s = 0;
    $t0 = OBX$Alloc(sizeof(struct Richards$Scheduler));
    memset($t0,0,sizeof(struct Richards$Scheduler));
    s = $t0;
    Richards$Scheduler$init$($t0);
    $t1 = OBX$Alloc(sizeof(struct Benchmark$BoolResult));
    memset($t1,0,sizeof(struct Benchmark$BoolResult));
    res = $t1;
    Benchmark$BoolResult$init$($t1);
    (*res).res = ($t3 = ((struct Richards$Scheduler *)($t2 = &(*s)))->class$->start, $t3($t2));
    return ((struct Benchmark$Result *)res);
}

uint8_t Richards$Richards$verifyResult(void* this, struct Benchmark$Result * result) {
    struct Richards$Richards* this$ = this;
    return (*((struct Benchmark$BoolResult*)result)).res;
}

struct Richards$Packet * Richards$RBObject$append(void* this, struct Richards$Packet * packet, struct Richards$Packet * queueHead) {
    struct Richards$RBObject* this$ = this;
    struct Richards$Packet * mouse;
    struct Richards$Packet * link;
    mouse = 0;
    link = 0;
    (*packet).link = 0;
    if( ((void*)0 == (void*)queueHead) ) {
        return packet;
    } 
    mouse = queueHead;
    link = (*mouse).link;
    while(1) {
        if( ((void*)0 != (void*)link) ) {
            mouse = link;
            link = (*mouse).link;
        } else {
            break;
        }
    }
    (*mouse).link = packet;
    return queueHead;
}

struct Richards$Packet * Richards$createPacket(struct Richards$Packet * link, int identity, int kind) {
    struct Richards$Packet * p;
    struct Richards$Packet * $t0;
    p = 0;
    $t0 = OBX$Alloc(sizeof(struct Richards$Packet));
    memset($t0,0,sizeof(struct Richards$Packet));
    p = $t0;
    Richards$Packet$init$($t0);
    (*p).link = link;
    (*p).identity = identity;
    (*p).kind = kind;
    return p;
}

void Richards$TaskState$pending(void* this) {
    struct Richards$TaskState* this$ = this;
    (*this$).packetPending = 1;
    (*this$).taskWaiting = 0;
    (*this$).taskHolding = 0;
}

void Richards$TaskState$running(void* this) {
    struct Richards$TaskState* this$ = this;
    (*this$).packetPending = 0;
    (*this$).taskWaiting = 0;
    (*this$).taskHolding = 0;
}

void Richards$TaskState$waiting(void* this) {
    struct Richards$TaskState* this$ = this;
    (*this$).packetPending = 0;
    (*this$).taskWaiting = 1;
    (*this$).taskHolding = 0;
}

void Richards$TaskState$waitingWithPacket(void* this) {
    struct Richards$TaskState* this$ = this;
    (*this$).packetPending = 1;
    (*this$).taskWaiting = 1;
    (*this$).taskHolding = 0;
}

uint8_t Richards$TaskState$isRunning(void* this) {
    struct Richards$TaskState* this$ = this;
    return (((!(*this$).packetPending) && (!(*this$).taskWaiting)) && (!(*this$).taskHolding));
}

uint8_t Richards$TaskState$isTaskHoldingOrWaiting(void* this) {
    struct Richards$TaskState* this$ = this;
    return ((*this$).taskHolding || ((!(*this$).packetPending) && (*this$).taskWaiting));
}

uint8_t Richards$TaskState$isWaiting(void* this) {
    struct Richards$TaskState* this$ = this;
    return (((!(*this$).packetPending) && (*this$).taskWaiting) && (!(*this$).taskHolding));
}

uint8_t Richards$TaskState$isWaitingWithPacket(void* this) {
    struct Richards$TaskState* this$ = this;
    return (((*this$).packetPending && (*this$).taskWaiting) && (!(*this$).taskHolding));
}

struct Richards$TaskState * Richards$createPacketPending() {
    struct Richards$TaskState * t;
    struct Richards$TaskState * $t0;
    void* $t1;
    void (* $t2)(void*);
    t = 0;
    $t0 = OBX$Alloc(sizeof(struct Richards$TaskState));
    memset($t0,0,sizeof(struct Richards$TaskState));
    t = $t0;
    Richards$TaskState$init$($t0);
    ($t2 = ((struct Richards$TaskState *)($t1 = &(*t)))->class$->pending, $t2($t1));
    return t;
}

struct Richards$TaskState * Richards$createRunning() {
    struct Richards$TaskState * t;
    struct Richards$TaskState * $t0;
    void* $t1;
    void (* $t2)(void*);
    t = 0;
    $t0 = OBX$Alloc(sizeof(struct Richards$TaskState));
    memset($t0,0,sizeof(struct Richards$TaskState));
    t = $t0;
    Richards$TaskState$init$($t0);
    ($t2 = ((struct Richards$TaskState *)($t1 = &(*t)))->class$->running, $t2($t1));
    return t;
}

struct Richards$TaskState * Richards$createWaiting() {
    struct Richards$TaskState * t;
    struct Richards$TaskState * $t0;
    void* $t1;
    void (* $t2)(void*);
    t = 0;
    $t0 = OBX$Alloc(sizeof(struct Richards$TaskState));
    memset($t0,0,sizeof(struct Richards$TaskState));
    t = $t0;
    Richards$TaskState$init$($t0);
    ($t2 = ((struct Richards$TaskState *)($t1 = &(*t)))->class$->waiting, $t2($t1));
    return t;
}

struct Richards$TaskState * Richards$createWaitingWithPacket() {
    struct Richards$TaskState * t;
    struct Richards$TaskState * $t0;
    void* $t1;
    void (* $t2)(void*);
    t = 0;
    $t0 = OBX$Alloc(sizeof(struct Richards$TaskState));
    memset($t0,0,sizeof(struct Richards$TaskState));
    t = $t0;
    Richards$TaskState$init$($t0);
    ($t2 = ((struct Richards$TaskState *)($t1 = &(*t)))->class$->waitingWithPacket, $t2($t1));
    return t;
}

struct Richards$TaskControlBlock * Richards$ProcessFunction$apply(void* this, struct Richards$Packet * work, struct Richards$RBObject * word) {
    struct Richards$ProcessFunction* this$ = this;
    return 0;
}

struct Richards$TaskControlBlock * Richards$createTaskControlBlock(struct Richards$TaskControlBlock * aLink, int anIdentity, int32_t aPriority, struct Richards$Packet * anInitialWorkQueue, struct Richards$TaskState * anInitialState, struct Richards$ProcessFunction * aBlock, struct Richards$RBObject * aPrivateData) {
    struct Richards$TaskControlBlock * t;
    struct Richards$TaskControlBlock * $t0;
    t = 0;
    $t0 = OBX$Alloc(sizeof(struct Richards$TaskControlBlock));
    memset($t0,0,sizeof(struct Richards$TaskControlBlock));
    t = $t0;
    Richards$TaskControlBlock$init$($t0);
    (*t).link = aLink;
    (*t).identity = anIdentity;
    (*t).priority = aPriority;
    (*t).input = anInitialWorkQueue;
    (*t).packetPending = (*anInitialState).packetPending;
    (*t).taskWaiting = (*anInitialState).taskWaiting;
    (*t).taskHolding = (*anInitialState).taskHolding;
    (*t).function = aBlock;
    (*t).handle = aPrivateData;
    return t;
}

struct Richards$TaskControlBlock * Richards$TaskControlBlock$addInputAndCheckPriority(void* this, struct Richards$Packet * packet, struct Richards$TaskControlBlock * oldTask) {
    struct Richards$TaskControlBlock* this$ = this;
    void* $t0;
    struct Richards$Packet * (* $t1)(void*, struct Richards$Packet *, struct Richards$Packet *);
    if( ((void*)0 == (void*)(*this$).input) ) {
        (*this$).input = packet;
        (*this$).packetPending = 1;
        if( ((*this$).priority > (*oldTask).priority) ) {
            return this$;
        } 
    } else {
        (*this$).input = ($t1 = ((struct Richards$RBObject *)($t0 = &(*this$)))->class$->append, $t1($t0, packet, (*this$).input));
    }
    return oldTask;
}

struct Richards$TaskControlBlock * Richards$TaskControlBlock$runTask(void* this) {
    struct Richards$TaskControlBlock* this$ = this;
    struct Richards$Packet * message;
    void* $t0;
    uint8_t (* $t1)(void*);
    void (* $t2)(void*);
    struct Richards$TaskControlBlock * (* $t3)(void*, struct Richards$Packet *, struct Richards$RBObject *);
    message = 0;
    if( ($t1 = ((struct Richards$TaskState *)($t0 = &(*this$)))->class$->isWaitingWithPacket, $t1($t0)) ) {
        message = (*this$).input;
        (*this$).input = (*message).link;
        if( ((void*)0 == (void*)(*this$).input) ) {
            ($t2 = ((struct Richards$TaskState *)($t0 = &(*this$)))->class$->running, $t2($t0));
        } else {
            ($t2 = ((struct Richards$TaskState *)($t0 = &(*this$)))->class$->pending, $t2($t0));
        }
    } else {
        message = 0;
    }
    return ($t3 = ((struct Richards$ProcessFunction *)($t0 = &(*(*this$).function)))->class$->apply, $t3($t0, message, (*this$).handle));
}

struct Richards$DeviceTaskDataRecord * Richards$createDeviceTaskDataRecord() {
    struct Richards$DeviceTaskDataRecord * r;
    struct Richards$DeviceTaskDataRecord * $t0;
    r = 0;
    $t0 = OBX$Alloc(sizeof(struct Richards$DeviceTaskDataRecord));
    memset($t0,0,sizeof(struct Richards$DeviceTaskDataRecord));
    r = $t0;
    Richards$DeviceTaskDataRecord$init$($t0);
    (*r).pending = 0;
    return r;
}

struct Richards$HandlerTaskDataRecord * Richards$createHandlerTaskDataRecord() {
    struct Richards$HandlerTaskDataRecord * r;
    struct Richards$HandlerTaskDataRecord * $t0;
    r = 0;
    $t0 = OBX$Alloc(sizeof(struct Richards$HandlerTaskDataRecord));
    memset($t0,0,sizeof(struct Richards$HandlerTaskDataRecord));
    r = $t0;
    Richards$HandlerTaskDataRecord$init$($t0);
    (*r).workIn = 0;
    (*r).deviceIn = 0;
    return r;
}

void Richards$HandlerTaskDataRecord$deviceInAdd(void* this, struct Richards$Packet * packet) {
    struct Richards$HandlerTaskDataRecord* this$ = this;
    void* $t0;
    struct Richards$Packet * (* $t1)(void*, struct Richards$Packet *, struct Richards$Packet *);
    (*this$).deviceIn = ($t1 = ((struct Richards$RBObject *)($t0 = &(*this$)))->class$->append, $t1($t0, packet, (*this$).deviceIn));
}

void Richards$HandlerTaskDataRecord$workInAdd(void* this, struct Richards$Packet * packet) {
    struct Richards$HandlerTaskDataRecord* this$ = this;
    void* $t0;
    struct Richards$Packet * (* $t1)(void*, struct Richards$Packet *, struct Richards$Packet *);
    (*this$).workIn = ($t1 = ((struct Richards$RBObject *)($t0 = &(*this$)))->class$->append, $t1($t0, packet, (*this$).workIn));
}

struct Richards$IdleTaskDataRecord * Richards$createIdleTaskDataRecord() {
    struct Richards$IdleTaskDataRecord * r;
    struct Richards$IdleTaskDataRecord * $t0;
    r = 0;
    $t0 = OBX$Alloc(sizeof(struct Richards$IdleTaskDataRecord));
    memset($t0,0,sizeof(struct Richards$IdleTaskDataRecord));
    r = $t0;
    Richards$IdleTaskDataRecord$init$($t0);
    (*r).count = 10000;
    (*r).control = 1;
    return r;
}

struct Richards$WorkerTaskDataRecord * Richards$createWorkerTaskDataRecord() {
    struct Richards$WorkerTaskDataRecord * r;
    struct Richards$WorkerTaskDataRecord * $t0;
    r = 0;
    $t0 = OBX$Alloc(sizeof(struct Richards$WorkerTaskDataRecord));
    memset($t0,0,sizeof(struct Richards$WorkerTaskDataRecord));
    r = $t0;
    Richards$WorkerTaskDataRecord$init$($t0);
    (*r).destination = 2;
    (*r).count = 0;
    return r;
}

struct Richards$Scheduler * Richards$createScheduler() {
    struct Richards$Scheduler * s;
    int32_t i;
    struct Richards$Scheduler * $t0;
    struct OBX$Array$1* $t1;
    s = 0;
    i = 0;
    $t0 = OBX$Alloc(sizeof(struct Richards$Scheduler));
    memset($t0,0,sizeof(struct Richards$Scheduler));
    s = $t0;
    Richards$Scheduler$init$($t0);
    (*s).layout = 0;
    (*s).queuePacketCount = 0;
    (*s).holdCount = 0;
    (*s).taskList = 0;
    i = 0;
    while(1) {
        if( (i <= (6 - 1)) ) {
            (((struct Richards$TaskControlBlock * *)((struct OBX$Array$1){6,1,(*s).taskTable}).$a)[i]) = 0;
            i = (i + 1);
        } else {
            break;
        }
    }
    return s;
}

void Richards$Scheduler$createTask(void* this, int identity, int32_t priority, struct Richards$Packet * work, struct Richards$TaskState * state, struct Richards$ProcessFunction * aBlock, struct Richards$RBObject * data) {
    struct Richards$Scheduler* this$ = this;
    struct Richards$TaskControlBlock * t;
    struct OBX$Array$1* $t0;
    t = 0;
    t = Richards$createTaskControlBlock((*this$).taskList, identity, priority, work, state, aBlock, data);
    (*this$).taskList = t;
    (((struct Richards$TaskControlBlock * *)((struct OBX$Array$1){6,1,(*this$).taskTable}).$a)[identity]) = t;
}

void Richards$Scheduler$createDevice(void* this, int identity, int32_t priority, struct Richards$Packet * workPacket, struct Richards$TaskState * state) {
    struct Richards$Scheduler* this$ = this;
    struct Richards$DeviceTaskDataRecord * data;
    struct Richards$Scheduler$createDevice$PF * func;
    struct Richards$Scheduler$createDevice$PF * $t0;
    void* $t1;
    void (* $t2)(void*, int, int32_t, struct Richards$Packet *, struct Richards$TaskState *, struct Richards$ProcessFunction *, struct Richards$RBObject *);
    data = 0;
    func = 0;
    data = Richards$createDeviceTaskDataRecord();
    $t0 = OBX$Alloc(sizeof(struct Richards$Scheduler$createDevice$PF));
    memset($t0,0,sizeof(struct Richards$Scheduler$createDevice$PF));
    func = $t0;
    Richards$Scheduler$createDevice$PF$init$($t0);
    (*func).s = this$;
    ($t2 = ((struct Richards$Scheduler *)($t1 = &(*this$)))->class$->createTask, $t2($t1, identity, priority, workPacket, state, ((struct Richards$ProcessFunction *)func), ((struct Richards$RBObject *)data)));
}

struct Richards$TaskControlBlock * Richards$Scheduler$createDevice$PF$apply(void* this, struct Richards$Packet * packet, struct Richards$RBObject * wordArg) {
    struct Richards$Scheduler$createDevice$PF* this$ = this;
    struct Richards$DeviceTaskDataRecord * dataRecord;
    struct Richards$Packet * functionWork;
    void* $t0;
    struct Richards$TaskControlBlock * (* $t1)(void*);
    struct Richards$TaskControlBlock * (* $t2)(void*, struct Richards$Packet *);
    void (* $t3)(void*, int32_t);
    dataRecord = 0;
    functionWork = 0;
    dataRecord = ((struct Richards$DeviceTaskDataRecord*)wordArg);
    functionWork = packet;
    if( ((void*)0 == (void*)functionWork) ) {
        functionWork = (*dataRecord).pending;
        if( ((void*)0 == (void*)functionWork) ) {
            return ($t1 = ((struct Richards$Scheduler *)($t0 = &(*(*this$).s)))->class$->markWaiting, $t1($t0));
        } else {
            (*dataRecord).pending = 0;
            return ($t2 = ((struct Richards$Scheduler *)($t0 = &(*(*this$).s)))->class$->queuePacket, $t2($t0, functionWork));
        }
    } else {
        (*dataRecord).pending = functionWork;
        if( Richards$TRACING ) {
            ($t3 = ((struct Richards$Scheduler *)($t0 = &(*(*this$).s)))->class$->trace, $t3($t0, (*functionWork).datum));
        } 
        return ($t1 = ((struct Richards$Scheduler *)($t0 = &(*(*this$).s)))->class$->holdSelf, $t1($t0));
    }
    return 0;
}

void Richards$Scheduler$createHandler(void* this, int identity, int32_t priority, struct Richards$Packet * workPacket, struct Richards$TaskState * state) {
    struct Richards$Scheduler* this$ = this;
    struct Richards$HandlerTaskDataRecord * data;
    struct Richards$Scheduler$createHandler$PF * func;
    struct Richards$Scheduler$createHandler$PF * $t0;
    void* $t1;
    void (* $t2)(void*, int, int32_t, struct Richards$Packet *, struct Richards$TaskState *, struct Richards$ProcessFunction *, struct Richards$RBObject *);
    data = 0;
    func = 0;
    data = Richards$createHandlerTaskDataRecord();
    $t0 = OBX$Alloc(sizeof(struct Richards$Scheduler$createHandler$PF));
    memset($t0,0,sizeof(struct Richards$Scheduler$createHandler$PF));
    func = $t0;
    Richards$Scheduler$createHandler$PF$init$($t0);
    (*func).s = this$;
    ($t2 = ((struct Richards$Scheduler *)($t1 = &(*this$)))->class$->createTask, $t2($t1, identity, priority, workPacket, state, ((struct Richards$ProcessFunction *)func), ((struct Richards$RBObject *)data)));
}

struct Richards$TaskControlBlock * Richards$Scheduler$createHandler$PF$apply(void* this, struct Richards$Packet * work, struct Richards$RBObject * word) {
    struct Richards$Scheduler$createHandler$PF* this$ = this;
    struct Richards$HandlerTaskDataRecord * dataRecord;
    struct Richards$Packet * workPacket;
    struct Richards$Packet * devicePacket;
    int32_t count;
    void* $t0;
    void (* $t1)(void*, struct Richards$Packet *);
    struct Richards$TaskControlBlock * (* $t2)(void*);
    struct Richards$TaskControlBlock * (* $t3)(void*, struct Richards$Packet *);
    struct OBX$Array$1* $t4;
    dataRecord = 0;
    workPacket = 0;
    devicePacket = 0;
    count = 0;
    dataRecord = ((struct Richards$HandlerTaskDataRecord*)word);
    if( ((void*)0 != (void*)work) ) {
        if( ((*work).kind == 1) ) {
            ($t1 = ((struct Richards$HandlerTaskDataRecord *)($t0 = &(*dataRecord)))->class$->workInAdd, $t1($t0, work));
        } else {
            ($t1 = ((struct Richards$HandlerTaskDataRecord *)($t0 = &(*dataRecord)))->class$->deviceInAdd, $t1($t0, work));
        }
    } 
    workPacket = (*dataRecord).workIn;
    if( ((void*)workPacket == (void*)0) ) {
        return ($t2 = ((struct Richards$Scheduler *)($t0 = &(*(*this$).s)))->class$->markWaiting, $t2($t0));
    } else {
        count = (*workPacket).datum;
        if( (count >= 4) ) {
            (*dataRecord).workIn = (*workPacket).link;
            return ($t3 = ((struct Richards$Scheduler *)($t0 = &(*(*this$).s)))->class$->queuePacket, $t3($t0, workPacket));
        } else {
            devicePacket = (*dataRecord).deviceIn;
            if( ((void*)devicePacket == (void*)0) ) {
                return ($t2 = ((struct Richards$Scheduler *)($t0 = &(*(*this$).s)))->class$->markWaiting, $t2($t0));
            } else {
                (*dataRecord).deviceIn = (*devicePacket).link;
                (*devicePacket).datum = (((int32_t *)((struct OBX$Array$1){4,1,(*workPacket).data}).$a)[count]);
                (*workPacket).datum = (count + 1);
                return ($t3 = ((struct Richards$Scheduler *)($t0 = &(*(*this$).s)))->class$->queuePacket, $t3($t0, devicePacket));
            }
        }
    }
    return 0;
}

void Richards$Scheduler$createIdler(void* this, int identity, int32_t priority, struct Richards$Packet * workPacket, struct Richards$TaskState * state) {
    struct Richards$Scheduler* this$ = this;
    struct Richards$IdleTaskDataRecord * data;
    struct Richards$Scheduler$createIdler$PF * func;
    struct Richards$Scheduler$createIdler$PF * $t0;
    void* $t1;
    void (* $t2)(void*, int, int32_t, struct Richards$Packet *, struct Richards$TaskState *, struct Richards$ProcessFunction *, struct Richards$RBObject *);
    data = 0;
    func = 0;
    data = Richards$createIdleTaskDataRecord();
    $t0 = OBX$Alloc(sizeof(struct Richards$Scheduler$createIdler$PF));
    memset($t0,0,sizeof(struct Richards$Scheduler$createIdler$PF));
    func = $t0;
    Richards$Scheduler$createIdler$PF$init$($t0);
    (*func).s = this$;
    ($t2 = ((struct Richards$Scheduler *)($t1 = &(*this$)))->class$->createTask, $t2($t1, identity, priority, workPacket, state, ((struct Richards$ProcessFunction *)func), ((struct Richards$RBObject *)data)));
}

struct Richards$TaskControlBlock * Richards$Scheduler$createIdler$PF$apply(void* this, struct Richards$Packet * workArg, struct Richards$RBObject * wordArg) {
    struct Richards$Scheduler$createIdler$PF* this$ = this;
    struct Richards$IdleTaskDataRecord * dataRecord;
    void* $t0;
    struct Richards$TaskControlBlock * (* $t1)(void*);
    struct Richards$TaskControlBlock * (* $t2)(void*, int);
    dataRecord = 0;
    dataRecord = ((struct Richards$IdleTaskDataRecord*)wordArg);
    (*dataRecord).count--;
    if( ((*dataRecord).count <= 0) ) {
        return ($t1 = ((struct Richards$Scheduler *)($t0 = &(*(*this$).s)))->class$->holdSelf, $t1($t0));
    } else {
        if( (0 == ((*dataRecord).control & 1)) ) {
            (*dataRecord).control = OBX$Div32((*dataRecord).control,2);
            return ($t2 = ((struct Richards$Scheduler *)($t0 = &(*(*this$).s)))->class$->release, $t2($t0, 4));
        } else {
            (*dataRecord).control = (OBX$Div32((*dataRecord).control,2) ^ 53256);
            return ($t2 = ((struct Richards$Scheduler *)($t0 = &(*(*this$).s)))->class$->release, $t2($t0, 5));
        }
    }
    return 0;
}

void Richards$Scheduler$createWorker(void* this, int identity, int32_t priority, struct Richards$Packet * workPacket, struct Richards$TaskState * state) {
    struct Richards$Scheduler* this$ = this;
    struct Richards$WorkerTaskDataRecord * dataRecord;
    struct Richards$Scheduler$createWorker$PF * func;
    struct Richards$Scheduler$createWorker$PF * $t0;
    void* $t1;
    void (* $t2)(void*, int, int32_t, struct Richards$Packet *, struct Richards$TaskState *, struct Richards$ProcessFunction *, struct Richards$RBObject *);
    dataRecord = 0;
    func = 0;
    dataRecord = Richards$createWorkerTaskDataRecord();
    $t0 = OBX$Alloc(sizeof(struct Richards$Scheduler$createWorker$PF));
    memset($t0,0,sizeof(struct Richards$Scheduler$createWorker$PF));
    func = $t0;
    Richards$Scheduler$createWorker$PF$init$($t0);
    (*func).s = this$;
    ($t2 = ((struct Richards$Scheduler *)($t1 = &(*this$)))->class$->createTask, $t2($t1, identity, priority, workPacket, state, ((struct Richards$ProcessFunction *)func), ((struct Richards$RBObject *)dataRecord)));
}

struct Richards$TaskControlBlock * Richards$Scheduler$createWorker$PF$apply(void* this, struct Richards$Packet * packet, struct Richards$RBObject * word) {
    struct Richards$Scheduler$createWorker$PF* this$ = this;
    struct Richards$WorkerTaskDataRecord * data;
    int32_t i;
    void* $t0;
    struct Richards$TaskControlBlock * (* $t1)(void*);
    struct OBX$Array$1* $t2;
    struct Richards$TaskControlBlock * (* $t3)(void*, struct Richards$Packet *);
    data = 0;
    i = 0;
    data = ((struct Richards$WorkerTaskDataRecord*)word);
    if( ((void*)0 == (void*)packet) ) {
        return ($t1 = ((struct Richards$Scheduler *)($t0 = &(*(*this$).s)))->class$->markWaiting, $t1($t0));
    } else {
        if( (2 == (*data).destination) ) {
            (*data).destination = 3;
        } else {
            (*data).destination = 2;
        }
        (*packet).identity = (*data).destination;
        (*packet).datum = 0;
        i = 0;
        while(1) {
            if( (i <= (4 - 1)) ) {
                (*data).count++;
                if( ((*data).count > 26) ) {
                    (*data).count = 1;
                } 
                (((int32_t *)((struct OBX$Array$1){4,1,(*packet).data}).$a)[i]) = ((65 + (*data).count) - 1);
                i = (i + 1);
            } else {
                break;
            }
        }
        return ($t3 = ((struct Richards$Scheduler *)($t0 = &(*(*this$).s)))->class$->queuePacket, $t3($t0, packet));
    }
    return 0;
}

uint8_t Richards$Scheduler$start(void* this) {
    struct Richards$Scheduler* this$ = this;
    struct Richards$Packet * workQ;
    void* $t0;
    void (* $t1)(void*, int, int32_t, struct Richards$Packet *, struct Richards$TaskState *);
    void (* $t2)(void*);
    workQ = 0;
    ($t1 = ((struct Richards$Scheduler *)($t0 = &(*this$)))->class$->createIdler, $t1($t0, 0, 0, 0, Richards$createRunning()));
    workQ = Richards$createPacket(0, 1, 1);
    workQ = Richards$createPacket(workQ, 1, 1);
    ($t1 = ((struct Richards$Scheduler *)($t0 = &(*this$)))->class$->createWorker, $t1($t0, 1, 1000, workQ, Richards$createWaitingWithPacket()));
    workQ = Richards$createPacket(0, 4, 0);
    workQ = Richards$createPacket(workQ, 4, 0);
    workQ = Richards$createPacket(workQ, 4, 0);
    ($t1 = ((struct Richards$Scheduler *)($t0 = &(*this$)))->class$->createHandler, $t1($t0, 2, 2000, workQ, Richards$createWaitingWithPacket()));
    workQ = Richards$createPacket(0, 5, 0);
    workQ = Richards$createPacket(workQ, 5, 0);
    workQ = Richards$createPacket(workQ, 5, 0);
    ($t1 = ((struct Richards$Scheduler *)($t0 = &(*this$)))->class$->createHandler, $t1($t0, 3, 3000, workQ, Richards$createWaitingWithPacket()));
    ($t1 = ((struct Richards$Scheduler *)($t0 = &(*this$)))->class$->createDevice, $t1($t0, 4, 4000, 0, Richards$createWaiting()));
    ($t1 = ((struct Richards$Scheduler *)($t0 = &(*this$)))->class$->createDevice, $t1($t0, 5, 5000, 0, Richards$createWaiting()));
    ($t2 = ((struct Richards$Scheduler *)($t0 = &(*this$)))->class$->schedule, $t2($t0));
    return (((*this$).queuePacketCount == 23246) && ((*this$).holdCount == 9297));
}

struct Richards$TaskControlBlock * Richards$Scheduler$findTask(void* this, int identity) {
    struct Richards$Scheduler* this$ = this;
    struct Richards$TaskControlBlock * t;
    struct OBX$Array$1* $t0;
    t = 0;
    t = (((struct Richards$TaskControlBlock * *)((struct OBX$Array$1){6,1,(*this$).taskTable}).$a)[identity]);
    if( ((void*)0 == (void*)t) ) {
        assert(0);
    } 
    return t;
}

struct Richards$TaskControlBlock * Richards$Scheduler$holdSelf(void* this) {
    struct Richards$Scheduler* this$ = this;
    (*this$).holdCount++;
    (*(*this$).currentTask).taskHolding = 1;
    return (*(*this$).currentTask).link;
}

struct Richards$TaskControlBlock * Richards$Scheduler$queuePacket(void* this, struct Richards$Packet * packet) {
    struct Richards$Scheduler* this$ = this;
    struct Richards$TaskControlBlock * t;
    void* $t0;
    struct Richards$TaskControlBlock * (* $t1)(void*, int);
    struct Richards$TaskControlBlock * (* $t2)(void*, struct Richards$Packet *, struct Richards$TaskControlBlock *);
    t = 0;
    t = ($t1 = ((struct Richards$Scheduler *)($t0 = &(*this$)))->class$->findTask, $t1($t0, (*packet).identity));
    if( ((void*)0 == (void*)t) ) {
        return 0;
    } 
    (*this$).queuePacketCount++;
    (*packet).link = 0;
    (*packet).identity = (*this$).currentTaskIdentity;
    return ($t2 = ((struct Richards$TaskControlBlock *)($t0 = &(*t)))->class$->addInputAndCheckPriority, $t2($t0, packet, (*this$).currentTask));
}

struct Richards$TaskControlBlock * Richards$Scheduler$release(void* this, int identity) {
    struct Richards$Scheduler* this$ = this;
    struct Richards$TaskControlBlock * t;
    void* $t0;
    struct Richards$TaskControlBlock * (* $t1)(void*, int);
    t = 0;
    t = ($t1 = ((struct Richards$Scheduler *)($t0 = &(*this$)))->class$->findTask, $t1($t0, identity));
    if( ((void*)0 == (void*)t) ) {
        return 0;
    } 
    (*t).taskHolding = 0;
    if( ((*t).priority > (*(*this$).currentTask).priority) ) {
        return t;
    } else {
        return (*this$).currentTask;
    }
    return 0;
}

void Richards$Scheduler$trace(void* this, int32_t id) {
    struct Richards$Scheduler* this$ = this;
    (*this$).layout--;
    if( (0 >= (*this$).layout) ) {
        Out$Ln();
        (*this$).layout = 50;
    } 
    Out$Int(id, 0);
}

struct Richards$TaskControlBlock * Richards$Scheduler$markWaiting(void* this) {
    struct Richards$Scheduler* this$ = this;
    (*(*this$).currentTask).taskWaiting = 1;
    return (*this$).currentTask;
}

void Richards$Scheduler$schedule(void* this) {
    struct Richards$Scheduler* this$ = this;
    void* $t0;
    uint8_t (* $t1)(void*);
    void (* $t2)(void*, int32_t);
    struct Richards$TaskControlBlock * (* $t3)(void*);
    (*this$).currentTask = (*this$).taskList;
    while(1) {
        if( ((void*)0 != (void*)(*this$).currentTask) ) {
            if( ($t1 = ((struct Richards$TaskState *)($t0 = &(*(*this$).currentTask)))->class$->isTaskHoldingOrWaiting, $t1($t0)) ) {
                (*this$).currentTask = (*(*this$).currentTask).link;
            } else {
                (*this$).currentTaskIdentity = (*(*this$).currentTask).identity;
                if( Richards$TRACING ) {
                    ($t2 = ((struct Richards$Scheduler *)($t0 = &(*this$)))->class$->trace, $t2($t0, (*this$).currentTaskIdentity));
                } 
                (*this$).currentTask = ($t3 = ((struct Richards$TaskControlBlock *)($t0 = &(*(*this$).currentTask)))->class$->runTask, $t3($t0));
            }
        } else {
            break;
        }
    }
}

struct Richards$TaskControlBlock$Class$ Richards$TaskControlBlock$class$ = { 
    &Richards$TaskState$class$,
    Richards$RBObject$append,
    Richards$TaskState$pending,
    Richards$TaskState$running,
    Richards$TaskState$waiting,
    Richards$TaskState$waitingWithPacket,
    Richards$TaskState$isRunning,
    Richards$TaskState$isTaskHoldingOrWaiting,
    Richards$TaskState$isWaiting,
    Richards$TaskState$isWaitingWithPacket,
    Richards$TaskControlBlock$addInputAndCheckPriority,
    Richards$TaskControlBlock$runTask,
};

struct Richards$Scheduler$createWorker$PF$Class$ Richards$Scheduler$createWorker$PF$class$ = { 
    &Richards$ProcessFunction$class$,
    Richards$Scheduler$createWorker$PF$apply,
};

struct Richards$HandlerTaskDataRecord$Class$ Richards$HandlerTaskDataRecord$class$ = { 
    &Richards$RBObject$class$,
    Richards$RBObject$append,
    Richards$HandlerTaskDataRecord$deviceInAdd,
    Richards$HandlerTaskDataRecord$workInAdd,
};

struct Richards$DeviceTaskDataRecord$Class$ Richards$DeviceTaskDataRecord$class$ = { 
    &Richards$RBObject$class$,
    Richards$RBObject$append,
};

struct Richards$Richards$Class$ Richards$Richards$class$ = { 
    &Benchmark$Benchmark$class$,
    Richards$Richards$benchmark,
    Richards$Richards$verifyResult,
    Benchmark$Benchmark$innerBenchmarkLoop,
};

struct Richards$Scheduler$createIdler$PF$Class$ Richards$Scheduler$createIdler$PF$class$ = { 
    &Richards$ProcessFunction$class$,
    Richards$Scheduler$createIdler$PF$apply,
};

struct Richards$WorkerTaskDataRecord$Class$ Richards$WorkerTaskDataRecord$class$ = { 
    &Richards$RBObject$class$,
    Richards$RBObject$append,
};

struct Richards$RBObject$Class$ Richards$RBObject$class$ = { 
    0,
    Richards$RBObject$append,
};

struct Richards$TaskState$Class$ Richards$TaskState$class$ = { 
    &Richards$RBObject$class$,
    Richards$RBObject$append,
    Richards$TaskState$pending,
    Richards$TaskState$running,
    Richards$TaskState$waiting,
    Richards$TaskState$waitingWithPacket,
    Richards$TaskState$isRunning,
    Richards$TaskState$isTaskHoldingOrWaiting,
    Richards$TaskState$isWaiting,
    Richards$TaskState$isWaitingWithPacket,
};

struct Richards$Scheduler$createDevice$PF$Class$ Richards$Scheduler$createDevice$PF$class$ = { 
    &Richards$ProcessFunction$class$,
    Richards$Scheduler$createDevice$PF$apply,
};

struct Richards$Scheduler$createHandler$PF$Class$ Richards$Scheduler$createHandler$PF$class$ = { 
    &Richards$ProcessFunction$class$,
    Richards$Scheduler$createHandler$PF$apply,
};

struct Richards$Scheduler$Class$ Richards$Scheduler$class$ = { 
    &Richards$RBObject$class$,
    Richards$RBObject$append,
    Richards$Scheduler$createTask,
    Richards$Scheduler$createDevice,
    Richards$Scheduler$createHandler,
    Richards$Scheduler$createIdler,
    Richards$Scheduler$createWorker,
    Richards$Scheduler$start,
    Richards$Scheduler$findTask,
    Richards$Scheduler$holdSelf,
    Richards$Scheduler$queuePacket,
    Richards$Scheduler$release,
    Richards$Scheduler$trace,
    Richards$Scheduler$markWaiting,
    Richards$Scheduler$schedule,
};

struct Richards$Packet$Class$ Richards$Packet$class$ = { 
    &Richards$RBObject$class$,
    Richards$RBObject$append,
};

struct Richards$ProcessFunction$Class$ Richards$ProcessFunction$class$ = { 
    0,
    Richards$ProcessFunction$apply,
};

struct Richards$IdleTaskDataRecord$Class$ Richards$IdleTaskDataRecord$class$ = { 
    &Richards$RBObject$class$,
    Richards$RBObject$append,
};

static int initDone$ = 0;
void Richards$init$(void) {
    if(initDone$) return; else initDone$ = 1;
    Benchmark$init$();
    Out$init$();
    Richards$TRACING = 0;
}
OBX$Cmd Richards$cmd$(const char* name) {
    if( name == 0 ) return Richards$init$;
    return 0;
}
