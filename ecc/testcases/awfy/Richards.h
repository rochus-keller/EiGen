#ifndef _RICHARDS_
#define _RICHARDS_

// Generated by Oberon+ IDE (Mono) 0.9.106 on 2024-07-13T01:26:30

#include "OBX.Runtime.h"
#include "Benchmark.h"
#include "Out.h"

// Declaration of module Richards

struct Richards$TaskControlBlock$Class$;
struct Richards$TaskControlBlock;
struct Richards$Scheduler$createWorker$PF$Class$;
struct Richards$Scheduler$createWorker$PF;
struct Richards$HandlerTaskDataRecord$Class$;
struct Richards$HandlerTaskDataRecord;
struct Richards$DeviceTaskDataRecord$Class$;
struct Richards$DeviceTaskDataRecord;
struct Richards$Richards$Class$;
struct Richards$Richards;
struct Richards$Scheduler$createIdler$PF$Class$;
struct Richards$Scheduler$createIdler$PF;
struct Richards$WorkerTaskDataRecord$Class$;
struct Richards$WorkerTaskDataRecord;
struct Richards$RBObject$Class$;
struct Richards$RBObject;
struct Richards$TaskState$Class$;
struct Richards$TaskState;
struct Richards$Scheduler$createDevice$PF$Class$;
struct Richards$Scheduler$createDevice$PF;
struct Richards$Scheduler$createHandler$PF$Class$;
struct Richards$Scheduler$createHandler$PF;
struct Richards$Scheduler$Class$;
struct Richards$Scheduler;
struct Richards$Packet$Class$;
struct Richards$Packet;
struct Richards$ProcessFunction$Class$;
struct Richards$ProcessFunction;
struct Richards$IdleTaskDataRecord$Class$;
struct Richards$IdleTaskDataRecord;
struct Richards$TaskControlBlock {
    struct Richards$TaskControlBlock$Class$* class$;
    uint8_t packetPending;
    uint8_t taskWaiting;
    uint8_t taskHolding;
    struct Richards$TaskControlBlock * link;
    int identity;
    int32_t priority;
    struct Richards$Packet * input;
    struct Richards$ProcessFunction * function;
    struct Richards$RBObject * handle;
};

extern void Richards$TaskControlBlock$init$(struct Richards$TaskControlBlock*);
struct Richards$Scheduler$createWorker$PF {
    struct Richards$Scheduler$createWorker$PF$Class$* class$;
    struct Richards$Scheduler * s;
};

extern void Richards$Scheduler$createWorker$PF$init$(struct Richards$Scheduler$createWorker$PF*);
struct Richards$HandlerTaskDataRecord {
    struct Richards$HandlerTaskDataRecord$Class$* class$;
    struct Richards$Packet * workIn;
    struct Richards$Packet * deviceIn;
};

extern void Richards$HandlerTaskDataRecord$init$(struct Richards$HandlerTaskDataRecord*);
struct Richards$DeviceTaskDataRecord {
    struct Richards$DeviceTaskDataRecord$Class$* class$;
    struct Richards$Packet * pending;
};

extern void Richards$DeviceTaskDataRecord$init$(struct Richards$DeviceTaskDataRecord*);
struct Richards$Richards {
    struct Richards$Richards$Class$* class$;
};

extern void Richards$Richards$init$(struct Richards$Richards*);
struct Richards$Scheduler$createIdler$PF {
    struct Richards$Scheduler$createIdler$PF$Class$* class$;
    struct Richards$Scheduler * s;
};

extern void Richards$Scheduler$createIdler$PF$init$(struct Richards$Scheduler$createIdler$PF*);
struct Richards$WorkerTaskDataRecord {
    struct Richards$WorkerTaskDataRecord$Class$* class$;
    int32_t count;
    int destination;
};

extern void Richards$WorkerTaskDataRecord$init$(struct Richards$WorkerTaskDataRecord*);
struct Richards$RBObject {
    struct Richards$RBObject$Class$* class$;
};

extern void Richards$RBObject$init$(struct Richards$RBObject*);
struct Richards$TaskState {
    struct Richards$TaskState$Class$* class$;
    uint8_t packetPending;
    uint8_t taskWaiting;
    uint8_t taskHolding;
};

extern void Richards$TaskState$init$(struct Richards$TaskState*);
struct Richards$Scheduler$createDevice$PF {
    struct Richards$Scheduler$createDevice$PF$Class$* class$;
    struct Richards$Scheduler * s;
};

extern void Richards$Scheduler$createDevice$PF$init$(struct Richards$Scheduler$createDevice$PF*);
struct Richards$Scheduler$createHandler$PF {
    struct Richards$Scheduler$createHandler$PF$Class$* class$;
    struct Richards$Scheduler * s;
};

extern void Richards$Scheduler$createHandler$PF$init$(struct Richards$Scheduler$createHandler$PF*);
struct Richards$Scheduler {
    struct Richards$Scheduler$Class$* class$;
    struct Richards$TaskControlBlock * taskList;
    struct Richards$TaskControlBlock * currentTask;
    int currentTaskIdentity;
    int32_t queuePacketCount;
    int32_t holdCount;
    int32_t layout;
    struct Richards$TaskControlBlock * taskTable[6];
};

extern void Richards$Scheduler$init$(struct Richards$Scheduler*);
struct Richards$Packet {
    struct Richards$Packet$Class$* class$;
    struct Richards$Packet * link;
    int identity;
    int kind;
    int32_t datum;
    int32_t data[4];
};

extern void Richards$Packet$init$(struct Richards$Packet*);
struct Richards$ProcessFunction {
    struct Richards$ProcessFunction$Class$* class$;
};

extern void Richards$ProcessFunction$init$(struct Richards$ProcessFunction*);
struct Richards$IdleTaskDataRecord {
    struct Richards$IdleTaskDataRecord$Class$* class$;
    int32_t control;
    int32_t count;
};

extern void Richards$IdleTaskDataRecord$init$(struct Richards$IdleTaskDataRecord*);
extern uint8_t Richards$TRACING;
struct Richards$Richards * Richards$create();
struct Benchmark$Result * Richards$Richards$benchmark(void* this);
uint8_t Richards$Richards$verifyResult(void* this, struct Benchmark$Result * result);
struct Richards$Packet * Richards$RBObject$append(void* this, struct Richards$Packet * packet, struct Richards$Packet * queueHead);
struct Richards$Packet * Richards$createPacket(struct Richards$Packet * link, int identity, int kind);
void Richards$TaskState$pending(void* this);
void Richards$TaskState$running(void* this);
void Richards$TaskState$waiting(void* this);
void Richards$TaskState$waitingWithPacket(void* this);
uint8_t Richards$TaskState$isRunning(void* this);
uint8_t Richards$TaskState$isTaskHoldingOrWaiting(void* this);
uint8_t Richards$TaskState$isWaiting(void* this);
uint8_t Richards$TaskState$isWaitingWithPacket(void* this);
struct Richards$TaskState * Richards$createPacketPending();
struct Richards$TaskState * Richards$createRunning();
struct Richards$TaskState * Richards$createWaiting();
struct Richards$TaskState * Richards$createWaitingWithPacket();
struct Richards$TaskControlBlock * Richards$ProcessFunction$apply(void* this, struct Richards$Packet * work, struct Richards$RBObject * word);
struct Richards$TaskControlBlock * Richards$createTaskControlBlock(struct Richards$TaskControlBlock * aLink, int anIdentity, int32_t aPriority, struct Richards$Packet * anInitialWorkQueue, struct Richards$TaskState * anInitialState, struct Richards$ProcessFunction * aBlock, struct Richards$RBObject * aPrivateData);
struct Richards$TaskControlBlock * Richards$TaskControlBlock$addInputAndCheckPriority(void* this, struct Richards$Packet * packet, struct Richards$TaskControlBlock * oldTask);
struct Richards$TaskControlBlock * Richards$TaskControlBlock$runTask(void* this);
struct Richards$DeviceTaskDataRecord * Richards$createDeviceTaskDataRecord();
struct Richards$HandlerTaskDataRecord * Richards$createHandlerTaskDataRecord();
void Richards$HandlerTaskDataRecord$deviceInAdd(void* this, struct Richards$Packet * packet);
void Richards$HandlerTaskDataRecord$workInAdd(void* this, struct Richards$Packet * packet);
struct Richards$IdleTaskDataRecord * Richards$createIdleTaskDataRecord();
struct Richards$WorkerTaskDataRecord * Richards$createWorkerTaskDataRecord();
struct Richards$Scheduler * Richards$createScheduler();
void Richards$Scheduler$createTask(void* this, int identity, int32_t priority, struct Richards$Packet * work, struct Richards$TaskState * state, struct Richards$ProcessFunction * aBlock, struct Richards$RBObject * data);
void Richards$Scheduler$createDevice(void* this, int identity, int32_t priority, struct Richards$Packet * workPacket, struct Richards$TaskState * state);
struct Richards$TaskControlBlock * Richards$Scheduler$createDevice$PF$apply(void* this, struct Richards$Packet * packet, struct Richards$RBObject * wordArg);
void Richards$Scheduler$createHandler(void* this, int identity, int32_t priority, struct Richards$Packet * workPacket, struct Richards$TaskState * state);
struct Richards$TaskControlBlock * Richards$Scheduler$createHandler$PF$apply(void* this, struct Richards$Packet * work, struct Richards$RBObject * word);
void Richards$Scheduler$createIdler(void* this, int identity, int32_t priority, struct Richards$Packet * workPacket, struct Richards$TaskState * state);
struct Richards$TaskControlBlock * Richards$Scheduler$createIdler$PF$apply(void* this, struct Richards$Packet * workArg, struct Richards$RBObject * wordArg);
void Richards$Scheduler$createWorker(void* this, int identity, int32_t priority, struct Richards$Packet * workPacket, struct Richards$TaskState * state);
struct Richards$TaskControlBlock * Richards$Scheduler$createWorker$PF$apply(void* this, struct Richards$Packet * packet, struct Richards$RBObject * word);
uint8_t Richards$Scheduler$start(void* this);
struct Richards$TaskControlBlock * Richards$Scheduler$findTask(void* this, int identity);
struct Richards$TaskControlBlock * Richards$Scheduler$holdSelf(void* this);
struct Richards$TaskControlBlock * Richards$Scheduler$queuePacket(void* this, struct Richards$Packet * packet);
struct Richards$TaskControlBlock * Richards$Scheduler$release(void* this, int identity);
void Richards$Scheduler$trace(void* this, int32_t id);
struct Richards$TaskControlBlock * Richards$Scheduler$markWaiting(void* this);
void Richards$Scheduler$schedule(void* this);
struct Richards$TaskControlBlock$Class$ {
    struct Richards$TaskState$Class$* super$;
    struct Richards$Packet * (*append)(void* this, struct Richards$Packet * packet, struct Richards$Packet * queueHead);
    void (*pending)(void* this);
    void (*running)(void* this);
    void (*waiting)(void* this);
    void (*waitingWithPacket)(void* this);
    uint8_t (*isRunning)(void* this);
    uint8_t (*isTaskHoldingOrWaiting)(void* this);
    uint8_t (*isWaiting)(void* this);
    uint8_t (*isWaitingWithPacket)(void* this);
    struct Richards$TaskControlBlock * (*addInputAndCheckPriority)(void* this, struct Richards$Packet * packet, struct Richards$TaskControlBlock * oldTask);
    struct Richards$TaskControlBlock * (*runTask)(void* this);
};
extern struct Richards$TaskControlBlock$Class$ Richards$TaskControlBlock$class$;

struct Richards$Scheduler$createWorker$PF$Class$ {
    struct Richards$ProcessFunction$Class$* super$;
    struct Richards$TaskControlBlock * (*apply)(void* this, struct Richards$Packet * packet, struct Richards$RBObject * word);
};
extern struct Richards$Scheduler$createWorker$PF$Class$ Richards$Scheduler$createWorker$PF$class$;

struct Richards$HandlerTaskDataRecord$Class$ {
    struct Richards$RBObject$Class$* super$;
    struct Richards$Packet * (*append)(void* this, struct Richards$Packet * packet, struct Richards$Packet * queueHead);
    void (*deviceInAdd)(void* this, struct Richards$Packet * packet);
    void (*workInAdd)(void* this, struct Richards$Packet * packet);
};
extern struct Richards$HandlerTaskDataRecord$Class$ Richards$HandlerTaskDataRecord$class$;

struct Richards$DeviceTaskDataRecord$Class$ {
    struct Richards$RBObject$Class$* super$;
    struct Richards$Packet * (*append)(void* this, struct Richards$Packet * packet, struct Richards$Packet * queueHead);
};
extern struct Richards$DeviceTaskDataRecord$Class$ Richards$DeviceTaskDataRecord$class$;

struct Richards$Richards$Class$ {
    struct Benchmark$Benchmark$Class$* super$;
    struct Benchmark$Result * (*benchmark)(void* this);
    uint8_t (*verifyResult)(void* this, struct Benchmark$Result * result);
    uint8_t (*innerBenchmarkLoop)(void* this, int32_t innerIterations);
};
extern struct Richards$Richards$Class$ Richards$Richards$class$;

struct Richards$Scheduler$createIdler$PF$Class$ {
    struct Richards$ProcessFunction$Class$* super$;
    struct Richards$TaskControlBlock * (*apply)(void* this, struct Richards$Packet * workArg, struct Richards$RBObject * wordArg);
};
extern struct Richards$Scheduler$createIdler$PF$Class$ Richards$Scheduler$createIdler$PF$class$;

struct Richards$WorkerTaskDataRecord$Class$ {
    struct Richards$RBObject$Class$* super$;
    struct Richards$Packet * (*append)(void* this, struct Richards$Packet * packet, struct Richards$Packet * queueHead);
};
extern struct Richards$WorkerTaskDataRecord$Class$ Richards$WorkerTaskDataRecord$class$;

struct Richards$RBObject$Class$ {
    struct Richards$RBObject$Class$* super$;
    struct Richards$Packet * (*append)(void* this, struct Richards$Packet * packet, struct Richards$Packet * queueHead);
};
extern struct Richards$RBObject$Class$ Richards$RBObject$class$;

struct Richards$TaskState$Class$ {
    struct Richards$RBObject$Class$* super$;
    struct Richards$Packet * (*append)(void* this, struct Richards$Packet * packet, struct Richards$Packet * queueHead);
    void (*pending)(void* this);
    void (*running)(void* this);
    void (*waiting)(void* this);
    void (*waitingWithPacket)(void* this);
    uint8_t (*isRunning)(void* this);
    uint8_t (*isTaskHoldingOrWaiting)(void* this);
    uint8_t (*isWaiting)(void* this);
    uint8_t (*isWaitingWithPacket)(void* this);
};
extern struct Richards$TaskState$Class$ Richards$TaskState$class$;

struct Richards$Scheduler$createDevice$PF$Class$ {
    struct Richards$ProcessFunction$Class$* super$;
    struct Richards$TaskControlBlock * (*apply)(void* this, struct Richards$Packet * packet, struct Richards$RBObject * wordArg);
};
extern struct Richards$Scheduler$createDevice$PF$Class$ Richards$Scheduler$createDevice$PF$class$;

struct Richards$Scheduler$createHandler$PF$Class$ {
    struct Richards$ProcessFunction$Class$* super$;
    struct Richards$TaskControlBlock * (*apply)(void* this, struct Richards$Packet * work, struct Richards$RBObject * word);
};
extern struct Richards$Scheduler$createHandler$PF$Class$ Richards$Scheduler$createHandler$PF$class$;

struct Richards$Scheduler$Class$ {
    struct Richards$RBObject$Class$* super$;
    struct Richards$Packet * (*append)(void* this, struct Richards$Packet * packet, struct Richards$Packet * queueHead);
    void (*createTask)(void* this, int identity, int32_t priority, struct Richards$Packet * work, struct Richards$TaskState * state, struct Richards$ProcessFunction * aBlock, struct Richards$RBObject * data);
    void (*createDevice)(void* this, int identity, int32_t priority, struct Richards$Packet * workPacket, struct Richards$TaskState * state);
    void (*createHandler)(void* this, int identity, int32_t priority, struct Richards$Packet * workPacket, struct Richards$TaskState * state);
    void (*createIdler)(void* this, int identity, int32_t priority, struct Richards$Packet * workPacket, struct Richards$TaskState * state);
    void (*createWorker)(void* this, int identity, int32_t priority, struct Richards$Packet * workPacket, struct Richards$TaskState * state);
    uint8_t (*start)(void* this);
    struct Richards$TaskControlBlock * (*findTask)(void* this, int identity);
    struct Richards$TaskControlBlock * (*holdSelf)(void* this);
    struct Richards$TaskControlBlock * (*queuePacket)(void* this, struct Richards$Packet * packet);
    struct Richards$TaskControlBlock * (*release)(void* this, int identity);
    void (*trace)(void* this, int32_t id);
    struct Richards$TaskControlBlock * (*markWaiting)(void* this);
    void (*schedule)(void* this);
};
extern struct Richards$Scheduler$Class$ Richards$Scheduler$class$;

struct Richards$Packet$Class$ {
    struct Richards$RBObject$Class$* super$;
    struct Richards$Packet * (*append)(void* this, struct Richards$Packet * packet, struct Richards$Packet * queueHead);
};
extern struct Richards$Packet$Class$ Richards$Packet$class$;

struct Richards$ProcessFunction$Class$ {
    struct Richards$ProcessFunction$Class$* super$;
    struct Richards$TaskControlBlock * (*apply)(void* this, struct Richards$Packet * work, struct Richards$RBObject * word);
};
extern struct Richards$ProcessFunction$Class$ Richards$ProcessFunction$class$;

struct Richards$IdleTaskDataRecord$Class$ {
    struct Richards$RBObject$Class$* super$;
    struct Richards$Packet * (*append)(void* this, struct Richards$Packet * packet, struct Richards$Packet * queueHead);
};
extern struct Richards$IdleTaskDataRecord$Class$ Richards$IdleTaskDataRecord$class$;

extern void Richards$init$(void);
extern OBX$Cmd Richards$cmd$(const char* name);
#endif
