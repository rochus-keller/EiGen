// Generated by Oberon+ IDE (Mono) 0.9.106 on 2024-07-13T01:26:30

#include "Sieve.h"

void Sieve$Sieve$init$(struct Sieve$Sieve* inst){
    inst->class$ = &Sieve$Sieve$class$;
}
struct Sieve$Sieve * Sieve$create() {
    struct Sieve$Sieve * s;
    struct Sieve$Sieve * $t0;
    s = 0;
    $t0 = OBX$Alloc(sizeof(struct Sieve$Sieve));
    memset($t0,0,sizeof(struct Sieve$Sieve));
    s = $t0;
    Sieve$Sieve$init$($t0);
    return s;
}

struct Benchmark$Result * Sieve$Sieve$benchmark(void* this) {
    struct Sieve$Sieve* this$ = this;
    uint8_t flags[5000];
    int32_t i;
    int32_t result;
    struct Benchmark$IntResult * res;
    struct OBX$Array$1* $t0;
    void* $t1;
    int32_t (* $t2)(void*, struct OBX$Array$1, int32_t);
    struct Benchmark$IntResult * $t3;
    memset(&flags,0,sizeof(flags));
    i = 0;
    result = 0;
    res = 0;
    i = 0;
    while(1) {
        if( (i <= (5000 - 1)) ) {
            (((uint8_t *)((struct OBX$Array$1){5000,1,flags}).$a)[i]) = 1;
            i = (i + 1);
        } else {
            break;
        }
    }
    result = ($t2 = ((struct Sieve$Sieve *)($t1 = &(*this$)))->class$->sieve, $t2($t1, (struct OBX$Array$1){5000,1,flags}, 5000));
    $t3 = OBX$Alloc(sizeof(struct Benchmark$IntResult));
    memset($t3,0,sizeof(struct Benchmark$IntResult));
    res = $t3;
    Benchmark$IntResult$init$($t3);
    (*res).res = result;
    return ((struct Benchmark$Result *)res);
}

int32_t Sieve$Sieve$sieve(void* this, struct OBX$Array$1 flags, int32_t size) {
    struct Sieve$Sieve* this$ = this;
    int32_t primeCount;
    int32_t i;
    int32_t k;
    struct OBX$Array$1* $t0;
    primeCount = 0;
    i = 0;
    k = 0;
    primeCount = 0;
    i = 2;
    while(1) {
        if( (i <= size) ) {
            if( (*($t0 = (&flags),&((uint8_t *)$t0->$a)[(i - 1)])) ) {
                primeCount++;
                k = (i + i);
                while(1) {
                    if( (k <= size) ) {
                        (*($t0 = (&flags),&((uint8_t *)$t0->$a)[(k - 1)])) = 0;
                        k = (k + i);
                    } else {
                        break;
                    }
                }
            } 
            i = (i + 1);
        } else {
            break;
        }
    }
    return primeCount;
}

uint8_t Sieve$Sieve$verifyResult(void* this, struct Benchmark$Result * result) {
    struct Sieve$Sieve* this$ = this;
    return ((*((struct Benchmark$IntResult*)result)).res == 669);
}

struct Sieve$Sieve$Class$ Sieve$Sieve$class$ = { 
    &Benchmark$Benchmark$class$,
    Sieve$Sieve$benchmark,
    Sieve$Sieve$verifyResult,
    Benchmark$Benchmark$innerBenchmarkLoop,
    Sieve$Sieve$sieve,
};

static int initDone$ = 0;
void Sieve$init$(void) {
    if(initDone$) return; else initDone$ = 1;
    Benchmark$init$();
}
OBX$Cmd Sieve$cmd$(const char* name) {
    if( name == 0 ) return Sieve$init$;
    return 0;
}
