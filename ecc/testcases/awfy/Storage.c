// Generated by Oberon+ IDE (Mono) 0.9.106 on 2024-07-13T01:26:30

#include "Storage.h"

void Storage$Storage$init$(struct Storage$Storage* inst){
    inst->class$ = &Storage$Storage$class$;
}
struct Storage$Storage * Storage$create() {
    struct Storage$Storage * s;
    struct Storage$Storage * $t0;
    s = 0;
    $t0 = OBX$Alloc(sizeof(struct Storage$Storage));
    memset($t0,0,sizeof(struct Storage$Storage));
    s = $t0;
    Storage$Storage$init$($t0);
    return s;
}

struct Benchmark$Result * Storage$Storage$benchmark(void* this) {
    struct Storage$Storage* this$ = this;
    struct Benchmark$IntResult * res;
    struct OBX$Array$1 obj;
    void* $t0;
    struct OBX$Array$1 (* $t1)(void*, int32_t);
    struct Benchmark$IntResult * $t2;
    res = 0;
    memset(&obj,0,sizeof(obj));
    som$Random$reset();
    (*this$).count = 0;
    obj = ($t1 = ((struct Storage$Storage *)($t0 = &(*this$)))->class$->buildTreeDepth, $t1($t0, 7));
    $t2 = OBX$Alloc(sizeof(struct Benchmark$IntResult));
    memset($t2,0,sizeof(struct Benchmark$IntResult));
    res = $t2;
    Benchmark$IntResult$init$($t2);
    (*res).res = (*this$).count;
    return ((struct Benchmark$Result *)res);
}

struct OBX$Array$1 Storage$Storage$buildTreeDepth(void* this, int32_t depth) {
    struct Storage$Storage* this$ = this;
    struct OBX$Array$1 obj;
    int32_t i;
    struct OBX$Array$1 * $t0;
    struct OBX$Array$1* $t1;
    void* $t2;
    struct OBX$Array$1 (* $t3)(void*, int32_t);
    memset(&obj,0,sizeof(obj));
    i = 0;
    (*this$).count++;
    if( (depth == 1) ) {
        {int $0 = (OBX$Mod32(som$Random$next(),10) + 1), $n = $0, $s=sizeof(struct OBX$Array$1); $t0 = OBX$Alloc($s*$n); memset($t0,0,$s*$n); obj = (struct OBX$Array$1){$0, 1, $t0};};
    } else {
        {int $0 = 4, $n = $0, $s=sizeof(struct OBX$Array$1); $t0 = OBX$Alloc($s*$n); memset($t0,0,$s*$n); obj = (struct OBX$Array$1){$0, 1, $t0};};
        i = 0;
        while(1) {
            if( (i <= (4 - 1)) ) {
                (*($t1 = (&obj),&((struct OBX$Array$1 *)$t1->$a)[i])) = ($t3 = ((struct Storage$Storage *)($t2 = &(*this$)))->class$->buildTreeDepth, $t3($t2, (depth - 1)));
                i = (i + 1);
            } else {
                break;
            }
        }
    }
    return obj;
}

uint8_t Storage$Storage$verifyResult(void* this, struct Benchmark$Result * result) {
    struct Storage$Storage* this$ = this;
    return ((*((struct Benchmark$IntResult*)result)).res == 5461);
}

struct Storage$Storage$Class$ Storage$Storage$class$ = { 
    &Benchmark$Benchmark$class$,
    Storage$Storage$benchmark,
    Storage$Storage$verifyResult,
    Benchmark$Benchmark$innerBenchmarkLoop,
    Storage$Storage$buildTreeDepth,
};

static int initDone$ = 0;
void Storage$init$(void) {
    if(initDone$) return; else initDone$ = 1;
    som$Random$init$();
    Benchmark$init$();
}
OBX$Cmd Storage$cmd$(const char* name) {
    if( name == 0 ) return Storage$init$;
    return 0;
}
