// Generated by Oberon+ IDE (Mono) 0.9.106 on 2024-07-13T01:26:30

#include "Towers.h"

void Towers$TowersDisk$init$(struct Towers$TowersDisk* inst){
    inst->class$ = &Towers$TowersDisk$class$;
}
void Towers$Towers$init$(struct Towers$Towers* inst){
    inst->class$ = &Towers$Towers$class$;
}
struct Towers$Towers * Towers$create() {
    struct Towers$Towers * t;
    struct Towers$Towers * $t0;
    t = 0;
    $t0 = OBX$Alloc(sizeof(struct Towers$Towers));
    memset($t0,0,sizeof(struct Towers$Towers));
    t = $t0;
    Towers$Towers$init$($t0);
    return t;
}

struct Towers$TowersDisk * Towers$createDisk(int32_t s) {
    struct Towers$TowersDisk * d;
    struct Towers$TowersDisk * $t0;
    d = 0;
    $t0 = OBX$Alloc(sizeof(struct Towers$TowersDisk));
    memset($t0,0,sizeof(struct Towers$TowersDisk));
    d = $t0;
    Towers$TowersDisk$init$($t0);
    (*d).size = s;
    return d;
}

void Towers$Towers$pushDisk(void* this, struct Towers$TowersDisk * disk, int32_t pile) {
    struct Towers$Towers* this$ = this;
    struct Towers$TowersDisk * top;
    struct OBX$Array$1* $t0;
    top = 0;
    top = (*($t0 = (&(*this$).piles),&((struct Towers$TowersDisk * *)$t0->$a)[pile]));
    if( (((void*)top != (void*)0) && ((*disk).size >= (*top).size)) ) {
        Out$String((const struct OBX$Array$1){39,0,OBX$FromUtf("Cannot put a big disk on a smaller one",39,0)});
        Out$Ln();
    } 
    (*disk).next = top;
    (*($t0 = (&(*this$).piles),&((struct Towers$TowersDisk * *)$t0->$a)[pile])) = disk;
}

struct Towers$TowersDisk * Towers$Towers$popDiskFrom(void* this, int32_t pile) {
    struct Towers$Towers* this$ = this;
    struct Towers$TowersDisk * top;
    struct OBX$Array$1* $t0;
    top = 0;
    top = (*($t0 = (&(*this$).piles),&((struct Towers$TowersDisk * *)$t0->$a)[pile]));
    if( ((void*)top == (void*)0) ) {
        Out$String((const struct OBX$Array$1){47,0,OBX$FromUtf("Attempting to remove a disk from an empty pile",47,0)});
        Out$Ln();
    } 
    (*($t0 = (&(*this$).piles),&((struct Towers$TowersDisk * *)$t0->$a)[pile])) = (*top).next;
    (*top).next = 0;
    return top;
}

void Towers$Towers$moveTopDisk(void* this, int32_t fromPile, int32_t toPile) {
    struct Towers$Towers* this$ = this;
    struct Towers$TowersDisk * t;
    void* $t0;
    void (* $t1)(void*, struct Towers$TowersDisk *, int32_t);
    void* $t2;
    struct Towers$TowersDisk * (* $t3)(void*, int32_t);
    t = 0;
    ($t1 = ((struct Towers$Towers *)($t0 = &(*this$)))->class$->pushDisk, $t1($t0, ($t3 = ((struct Towers$Towers *)($t2 = &(*this$)))->class$->popDiskFrom, $t3($t2, fromPile)), toPile));
    (*this$).movesDone++;
}

void Towers$Towers$buildTowerAt(void* this, int32_t pile, int32_t disks) {
    struct Towers$Towers* this$ = this;
    int32_t i;
    void* $t0;
    void (* $t1)(void*, struct Towers$TowersDisk *, int32_t);
    i = 0;
    i = disks;
    while(1) {
        if( (i >= 0) ) {
            ($t1 = ((struct Towers$Towers *)($t0 = &(*this$)))->class$->pushDisk, $t1($t0, Towers$createDisk(i), pile));
            i = (i + (-1));
        } else {
            break;
        }
    }
}

void Towers$Towers$moveDisks(void* this, int32_t disks, int32_t fromPile, int32_t toPile) {
    struct Towers$Towers* this$ = this;
    int32_t otherPile;
    void* $t0;
    void (* $t1)(void*, int32_t, int32_t);
    void (* $t2)(void*, int32_t, int32_t, int32_t);
    otherPile = 0;
    if( (disks == 1) ) {
        ($t1 = ((struct Towers$Towers *)($t0 = &(*this$)))->class$->moveTopDisk, $t1($t0, fromPile, toPile));
    } else {
        otherPile = ((3 - fromPile) - toPile);
        ($t2 = ((struct Towers$Towers *)($t0 = &(*this$)))->class$->moveDisks, $t2($t0, (disks - 1), fromPile, otherPile));
        ($t1 = ((struct Towers$Towers *)($t0 = &(*this$)))->class$->moveTopDisk, $t1($t0, fromPile, toPile));
        ($t2 = ((struct Towers$Towers *)($t0 = &(*this$)))->class$->moveDisks, $t2($t0, (disks - 1), otherPile, toPile));
    }
}

struct Benchmark$Result * Towers$Towers$benchmark(void* this) {
    struct Towers$Towers* this$ = this;
    struct Benchmark$IntResult * res;
    struct Towers$TowersDisk * * $t0;
    void* $t1;
    void (* $t2)(void*, int32_t, int32_t);
    void (* $t3)(void*, int32_t, int32_t, int32_t);
    struct Benchmark$IntResult * $t4;
    res = 0;
    {int $0 = 3, $n = $0, $s=sizeof(struct Towers$TowersDisk *); $t0 = OBX$Alloc($s*$n); memset($t0,0,$s*$n); (*this$).piles = (struct OBX$Array$1){$0, 1, $t0};};
    ($t2 = ((struct Towers$Towers *)($t1 = &(*this$)))->class$->buildTowerAt, $t2($t1, 0, 13));
    (*this$).movesDone = 0;
    ($t3 = ((struct Towers$Towers *)($t1 = &(*this$)))->class$->moveDisks, $t3($t1, 13, 0, 1));
    $t4 = OBX$Alloc(sizeof(struct Benchmark$IntResult));
    memset($t4,0,sizeof(struct Benchmark$IntResult));
    res = $t4;
    Benchmark$IntResult$init$($t4);
    (*res).res = (*this$).movesDone;
    return ((struct Benchmark$Result *)res);
}

uint8_t Towers$Towers$verifyResult(void* this, struct Benchmark$Result * result) {
    struct Towers$Towers* this$ = this;
    return ((*((struct Benchmark$IntResult*)result)).res == 8191);
}

struct Towers$TowersDisk$Class$ Towers$TowersDisk$class$ = { 
    0,
};

struct Towers$Towers$Class$ Towers$Towers$class$ = { 
    &Benchmark$Benchmark$class$,
    Towers$Towers$benchmark,
    Towers$Towers$verifyResult,
    Benchmark$Benchmark$innerBenchmarkLoop,
    Towers$Towers$pushDisk,
    Towers$Towers$popDiskFrom,
    Towers$Towers$moveTopDisk,
    Towers$Towers$buildTowerAt,
    Towers$Towers$moveDisks,
};

static int initDone$ = 0;
void Towers$init$(void) {
    if(initDone$) return; else initDone$ = 1;
    Benchmark$init$();
    Out$init$();
}
OBX$Cmd Towers$cmd$(const char* name) {
    if( name == 0 ) return Towers$init$;
    return 0;
}
