// Generated by Oberon+ IDE (Mono) 0.9.106 on 2024-07-13T01:26:30

#include "som.Dictionary.84b2aa0859.h"
#include "som.IdentityDictionary.84b2aa0859.h"

void som$Dictionary$84b2aa0859$Dictionary$init$(struct som$Dictionary$84b2aa0859$Dictionary* inst){
    inst->class$ = &som$Dictionary$84b2aa0859$Dictionary$class$;
}
void som$Dictionary$84b2aa0859$Entry$init$(struct som$Dictionary$84b2aa0859$Entry* inst){
    inst->class$ = &som$Dictionary$84b2aa0859$Entry$class$;
}
struct som$Dictionary$84b2aa0859$Entry * som$Dictionary$84b2aa0859$createEntry(int32_t hash, struct Havlak$BasicBlock * key, int32_t value, struct som$Dictionary$84b2aa0859$Entry * next) {
    struct som$Dictionary$84b2aa0859$Entry * e;
    struct som$Dictionary$84b2aa0859$Entry * $t0;
    e = 0;
    $t0 = OBX$Alloc(sizeof(struct som$Dictionary$84b2aa0859$Entry));
    memset($t0,0,sizeof(struct som$Dictionary$84b2aa0859$Entry));
    e = $t0;
    som$Dictionary$84b2aa0859$Entry$init$($t0);
    (*e).hash = hash;
    (*e).key = key;
    (*e).value = value;
    (*e).next = next;
    return e;
}

uint8_t som$Dictionary$84b2aa0859$Entry$match(void* this, int32_t hash, struct Havlak$BasicBlock * key) {
    struct som$Dictionary$84b2aa0859$Entry* this$ = this;
    return ((hash == (*this$).hash) && ((void*)key == (void*)(*this$).key));
}

struct som$Dictionary$84b2aa0859$Dictionary * som$Dictionary$84b2aa0859$create(int32_t (*hf)(struct Havlak$BasicBlock * *)) {
    return som$Dictionary$84b2aa0859$createWithSize(16, hf);
}

struct som$Dictionary$84b2aa0859$Dictionary * som$Dictionary$84b2aa0859$createWithSize(int32_t size, int32_t (*hf)(struct Havlak$BasicBlock * *)) {
    struct som$Dictionary$84b2aa0859$Dictionary * d;
    struct som$Dictionary$84b2aa0859$Dictionary * $t0;
    struct som$Dictionary$84b2aa0859$Entry * * $t1;
    d = 0;
    $t0 = OBX$Alloc(sizeof(struct som$Dictionary$84b2aa0859$Dictionary));
    memset($t0,0,sizeof(struct som$Dictionary$84b2aa0859$Dictionary));
    d = $t0;
    som$Dictionary$84b2aa0859$Dictionary$init$($t0);
    {int $0 = size, $n = $0, $s=sizeof(struct som$Dictionary$84b2aa0859$Entry *); $t1 = OBX$Alloc($s*$n); memset($t1,0,$s*$n); (*d).buckets = (struct OBX$Array$1){$0, 1, $t1};};
    (*d).size = 0;
    (*d).hf = hf;
    return d;
}

int32_t som$Dictionary$84b2aa0859$Dictionary$hash(void* this, struct Havlak$BasicBlock * * key) {
    struct som$Dictionary$84b2aa0859$Dictionary* this$ = this;
    int32_t h;
    h = 0;
    if( ((void*)(*this$).hf != (void*)0) ) {
        h = (*this$).hf(&(*key));
    } else {
        h = 0;
    }
    return (h ^ OBX$Ror32(h,16));
}

int32_t som$Dictionary$84b2aa0859$Dictionary$getSize(void* this) {
    struct som$Dictionary$84b2aa0859$Dictionary* this$ = this;
    return (*this$).size;
}

uint8_t som$Dictionary$84b2aa0859$Dictionary$isEmpty(void* this) {
    struct som$Dictionary$84b2aa0859$Dictionary* this$ = this;
    return ((*this$).size == 0);
}

int32_t som$Dictionary$84b2aa0859$Dictionary$getBucketIdx(void* this, int32_t hash) {
    struct som$Dictionary$84b2aa0859$Dictionary* this$ = this;
    return ((((*this$).buckets).$1 - 1) & hash);
}

struct som$Dictionary$84b2aa0859$Entry * som$Dictionary$84b2aa0859$Dictionary$getBucket(void* this, int32_t hash) {
    struct som$Dictionary$84b2aa0859$Dictionary* this$ = this;
    struct OBX$Array$1* $t0;
    void* $t1;
    int32_t (* $t2)(void*, int32_t);
    return (*($t0 = (&(*this$).buckets),&((struct som$Dictionary$84b2aa0859$Entry * *)$t0->$a)[($t2 = ((struct som$Dictionary$84b2aa0859$Dictionary *)($t1 = &(*this$)))->class$->getBucketIdx, $t2($t1, hash))]));
}

int32_t som$Dictionary$84b2aa0859$Dictionary$at(void* this, struct Havlak$BasicBlock * * key) {
    struct som$Dictionary$84b2aa0859$Dictionary* this$ = this;
    int32_t h;
    struct som$Dictionary$84b2aa0859$Entry * e;
    void* $t0;
    int32_t (* $t1)(void*, struct Havlak$BasicBlock * *);
    struct som$Dictionary$84b2aa0859$Entry * (* $t2)(void*, int32_t);
    uint8_t (* $t3)(void*, int32_t, struct Havlak$BasicBlock *);
    h = 0;
    e = 0;
    h = ($t1 = ((struct som$Dictionary$84b2aa0859$Dictionary *)($t0 = &(*this$)))->class$->hash, $t1($t0, &(*key)));
    e = ($t2 = ((struct som$Dictionary$84b2aa0859$Dictionary *)($t0 = &(*this$)))->class$->getBucket, $t2($t0, h));
    while(1) {
        if( ((void*)e != (void*)0) ) {
            if( ($t3 = ((struct som$Dictionary$84b2aa0859$Entry *)($t0 = &(*e)))->class$->match, $t3($t0, h, (*key))) ) {
                return (*e).value;
            } 
            e = (*e).next;
        } else {
            break;
        }
    }
    return 0;
}

uint8_t som$Dictionary$84b2aa0859$Dictionary$containsKey(void* this, struct Havlak$BasicBlock * * key) {
    struct som$Dictionary$84b2aa0859$Dictionary* this$ = this;
    int32_t h;
    struct som$Dictionary$84b2aa0859$Entry * e;
    void* $t0;
    int32_t (* $t1)(void*, struct Havlak$BasicBlock * *);
    struct som$Dictionary$84b2aa0859$Entry * (* $t2)(void*, int32_t);
    uint8_t (* $t3)(void*, int32_t, struct Havlak$BasicBlock *);
    h = 0;
    e = 0;
    h = ($t1 = ((struct som$Dictionary$84b2aa0859$Dictionary *)($t0 = &(*this$)))->class$->hash, $t1($t0, &(*key)));
    e = ($t2 = ((struct som$Dictionary$84b2aa0859$Dictionary *)($t0 = &(*this$)))->class$->getBucket, $t2($t0, h));
    while(1) {
        if( ((void*)e != (void*)0) ) {
            if( ($t3 = ((struct som$Dictionary$84b2aa0859$Entry *)($t0 = &(*e)))->class$->match, $t3($t0, h, (*key))) ) {
                return 1;
            } 
            e = (*e).next;
        } else {
            break;
        }
    }
    return 0;
}

void som$Dictionary$84b2aa0859$Dictionary$atPut(void* this, struct Havlak$BasicBlock * * key, int32_t * value) {
    struct som$Dictionary$84b2aa0859$Dictionary* this$ = this;
    int32_t h;
    int32_t i;
    struct som$Dictionary$84b2aa0859$Entry * current;
    void* $t0;
    int32_t (* $t1)(void*, struct Havlak$BasicBlock * *);
    int32_t (* $t2)(void*, int32_t);
    struct OBX$Array$1* $t3;
    struct som$Dictionary$84b2aa0859$Entry * (* $t4)(void*, struct Havlak$BasicBlock * *, int32_t *, int32_t);
    void (* $t5)(void*, struct Havlak$BasicBlock * *, int32_t *, int32_t, struct som$Dictionary$84b2aa0859$Entry *);
    void (* $t6)(void*);
    h = 0;
    i = 0;
    current = 0;
    h = ($t1 = ((struct som$Dictionary$84b2aa0859$Dictionary *)($t0 = &(*this$)))->class$->hash, $t1($t0, &(*key)));
    i = ($t2 = ((struct som$Dictionary$84b2aa0859$Dictionary *)($t0 = &(*this$)))->class$->getBucketIdx, $t2($t0, h));
    current = (*($t3 = (&(*this$).buckets),&((struct som$Dictionary$84b2aa0859$Entry * *)$t3->$a)[i]));
    if( ((void*)current == (void*)0) ) {
        (*($t3 = (&(*this$).buckets),&((struct som$Dictionary$84b2aa0859$Entry * *)$t3->$a)[i])) = ($t4 = ((struct som$Dictionary$84b2aa0859$Dictionary *)($t0 = &(*this$)))->class$->newEntry, $t4($t0, &(*key), &(*value), h));
        (*this$).size++;
    } else {
        ($t5 = ((struct som$Dictionary$84b2aa0859$Dictionary *)($t0 = &(*this$)))->class$->insertBucketEntry, $t5($t0, &(*key), &(*value), h, current));
    }
    if( ((*this$).size > ((*this$).buckets).$1) ) {
        ($t6 = ((struct som$Dictionary$84b2aa0859$Dictionary *)($t0 = &(*this$)))->class$->resize, $t6($t0));
    } 
}

struct som$Dictionary$84b2aa0859$Entry * som$Dictionary$84b2aa0859$Dictionary$newEntry(void* this, struct Havlak$BasicBlock * * key, int32_t * value, int32_t hash) {
    struct som$Dictionary$84b2aa0859$Dictionary* this$ = this;
    return som$Dictionary$84b2aa0859$createEntry(hash, (*key), (*value), 0);
}

void som$Dictionary$84b2aa0859$Dictionary$insertBucketEntry(void* this, struct Havlak$BasicBlock * * key, int32_t * value, int32_t hash, struct som$Dictionary$84b2aa0859$Entry * head) {
    struct som$Dictionary$84b2aa0859$Dictionary* this$ = this;
    struct som$Dictionary$84b2aa0859$Entry * current;
    void* $t0;
    uint8_t (* $t1)(void*, int32_t, struct Havlak$BasicBlock *);
    struct som$Dictionary$84b2aa0859$Entry * (* $t2)(void*, struct Havlak$BasicBlock * *, int32_t *, int32_t);
    current = 0;
    current = head;
    while(1) {
        if( 1 ) {
            if( ($t1 = ((struct som$Dictionary$84b2aa0859$Entry *)($t0 = &(*current)))->class$->match, $t1($t0, hash, (*key))) ) {
                (*current).value = (*value);
                return ;
            } 
            if( ((void*)(*current).next == (void*)0) ) {
                (*this$).size++;
                (*current).next = ($t2 = ((struct som$Dictionary$84b2aa0859$Dictionary *)($t0 = &(*this$)))->class$->newEntry, $t2($t0, &(*key), &(*value), hash));
                return ;
            } 
            current = (*current).next;
        } else {
            break;
        }
    }
}

void som$Dictionary$84b2aa0859$Dictionary$resize(void* this) {
    struct som$Dictionary$84b2aa0859$Dictionary* this$ = this;
    struct OBX$Array$1 oldStorage;
    struct OBX$Array$1 newStorage;
    struct som$Dictionary$84b2aa0859$Entry * * $t0;
    void* $t1;
    void (* $t2)(void*, struct OBX$Array$1);
    memset(&oldStorage,0,sizeof(oldStorage));
    memset(&newStorage,0,sizeof(newStorage));
    oldStorage = (*this$).buckets;
    {int $0 = ((oldStorage).$1 * 2), $n = $0, $s=sizeof(struct som$Dictionary$84b2aa0859$Entry *); $t0 = OBX$Alloc($s*$n); memset($t0,0,$s*$n); newStorage = (struct OBX$Array$1){$0, 1, $t0};};
    (*this$).buckets = newStorage;
    ($t2 = ((struct som$Dictionary$84b2aa0859$Dictionary *)($t1 = &(*this$)))->class$->transferEntries, $t2($t1, oldStorage));
}

void som$Dictionary$84b2aa0859$Dictionary$transferEntries(void* this, struct OBX$Array$1 oldStorage) {
    struct som$Dictionary$84b2aa0859$Dictionary* this$ = this;
    int32_t i;
    struct som$Dictionary$84b2aa0859$Entry * current;
    struct OBX$Array$1* $t0;
    void* $t1;
    void (* $t2)(void*, struct OBX$Array$1, int32_t, struct som$Dictionary$84b2aa0859$Entry *);
    i = 0;
    current = 0;
    i = 0;
    while(1) {
        if( (i <= ((oldStorage).$1 - 1)) ) {
            current = (*($t0 = (&oldStorage),&((struct som$Dictionary$84b2aa0859$Entry * *)$t0->$a)[i]));
            if( ((void*)current != (void*)0) ) {
                (*($t0 = (&oldStorage),&((struct som$Dictionary$84b2aa0859$Entry * *)$t0->$a)[i])) = 0;
                if( ((void*)(*current).next == (void*)0) ) {
                    (*($t0 = (&(*this$).buckets),&((struct som$Dictionary$84b2aa0859$Entry * *)$t0->$a)[((*current).hash & (((*this$).buckets).$1 - 1))])) = current;
                } else {
                    ($t2 = ((struct som$Dictionary$84b2aa0859$Dictionary *)($t1 = &(*this$)))->class$->splitBucket, $t2($t1, oldStorage, i, current));
                }
            } 
            i = (i + 1);
        } else {
            break;
        }
    }
}

void som$Dictionary$84b2aa0859$Dictionary$splitBucket(void* this, struct OBX$Array$1 oldStorage, int32_t i, struct som$Dictionary$84b2aa0859$Entry * head) {
    struct som$Dictionary$84b2aa0859$Dictionary* this$ = this;
    struct som$Dictionary$84b2aa0859$Entry * loHead;
    struct som$Dictionary$84b2aa0859$Entry * loTail;
    struct som$Dictionary$84b2aa0859$Entry * hiHead;
    struct som$Dictionary$84b2aa0859$Entry * hiTail;
    struct som$Dictionary$84b2aa0859$Entry * current;
    struct OBX$Array$1* $t0;
    loHead = 0;
    loTail = 0;
    hiHead = 0;
    hiTail = 0;
    current = 0;
    current = head;
    while(1) {
        if( ((void*)current != (void*)0) ) {
            if( (((*current).hash & (oldStorage).$1) == 0) ) {
                if( ((void*)loTail == (void*)0) ) {
                    loHead = current;
                } else {
                    (*loTail).next = current;
                }
                loTail = current;
            } else {
                if( ((void*)hiTail == (void*)0) ) {
                    hiHead = current;
                } else {
                    (*hiTail).next = current;
                }
                hiTail = current;
            }
            current = (*current).next;
        } else {
            break;
        }
    }
    if( ((void*)loTail != (void*)0) ) {
        (*loTail).next = 0;
        (*($t0 = (&(*this$).buckets),&((struct som$Dictionary$84b2aa0859$Entry * *)$t0->$a)[i])) = loHead;
    } 
    if( ((void*)hiTail != (void*)0) ) {
        (*hiTail).next = 0;
        (*($t0 = (&(*this$).buckets),&((struct som$Dictionary$84b2aa0859$Entry * *)$t0->$a)[(i + (oldStorage).$1)])) = hiHead;
    } 
}

void som$Dictionary$84b2aa0859$Dictionary$removeAll(void* this) {
    struct som$Dictionary$84b2aa0859$Dictionary* this$ = this;
    struct som$Dictionary$84b2aa0859$Entry * * $t0;
    {int $0 = ((*this$).buckets).$1, $n = $0, $s=sizeof(struct som$Dictionary$84b2aa0859$Entry *); $t0 = OBX$Alloc($s*$n); memset($t0,0,$s*$n); (*this$).buckets = (struct OBX$Array$1){$0, 1, $t0};};
    (*this$).size = 0;
}

struct som$Vector$6226d61315$Vector * som$Dictionary$84b2aa0859$Dictionary$getKeys(void* this) {
    struct som$Dictionary$84b2aa0859$Dictionary* this$ = this;
    struct som$Vector$6226d61315$Vector * keys;
    int32_t i;
    struct som$Dictionary$84b2aa0859$Entry * current;
    struct OBX$Array$1* $t0;
    void* $t1;
    void (* $t2)(void*, struct Havlak$BasicBlock * *);
    keys = 0;
    i = 0;
    current = 0;
    keys = som$Vector$6226d61315$createWithSize((*this$).size);
    i = 0;
    while(1) {
        if( (i <= (((*this$).buckets).$1 - 1)) ) {
            current = (*($t0 = (&(*this$).buckets),&((struct som$Dictionary$84b2aa0859$Entry * *)$t0->$a)[i]));
            while(1) {
                if( ((void*)current != (void*)0) ) {
                    ($t2 = ((struct som$Vector$6226d61315$Vector *)($t1 = &(*keys)))->class$->append, $t2($t1, &(*current).key));
                    current = (*current).next;
                } else {
                    break;
                }
            }
            i = (i + 1);
        } else {
            break;
        }
    }
    return keys;
}

struct som$Vector$04445da84e$Vector * som$Dictionary$84b2aa0859$Dictionary$getValues(void* this) {
    struct som$Dictionary$84b2aa0859$Dictionary* this$ = this;
    struct som$Vector$04445da84e$Vector * values;
    int32_t i;
    struct som$Dictionary$84b2aa0859$Entry * current;
    struct OBX$Array$1* $t0;
    void* $t1;
    void (* $t2)(void*, int32_t *);
    values = 0;
    i = 0;
    current = 0;
    values = som$Vector$04445da84e$createWithSize((*this$).size);
    i = 0;
    while(1) {
        if( (i <= (((*this$).buckets).$1 - 1)) ) {
            current = (*($t0 = (&(*this$).buckets),&((struct som$Dictionary$84b2aa0859$Entry * *)$t0->$a)[i]));
            while(1) {
                if( ((void*)current != (void*)0) ) {
                    ($t2 = ((struct som$Vector$04445da84e$Vector *)($t1 = &(*values)))->class$->append, $t2($t1, &(*current).value));
                    current = (*current).next;
                } else {
                    break;
                }
            }
            i = (i + 1);
        } else {
            break;
        }
    }
    return values;
}

struct som$Dictionary$84b2aa0859$Dictionary$Class$ som$Dictionary$84b2aa0859$Dictionary$class$ = { 
    0,
    som$Dictionary$84b2aa0859$Dictionary$hash,
    som$Dictionary$84b2aa0859$Dictionary$getSize,
    som$Dictionary$84b2aa0859$Dictionary$isEmpty,
    som$Dictionary$84b2aa0859$Dictionary$getBucketIdx,
    som$Dictionary$84b2aa0859$Dictionary$getBucket,
    som$Dictionary$84b2aa0859$Dictionary$at,
    som$Dictionary$84b2aa0859$Dictionary$containsKey,
    som$Dictionary$84b2aa0859$Dictionary$atPut,
    som$Dictionary$84b2aa0859$Dictionary$newEntry,
    som$Dictionary$84b2aa0859$Dictionary$insertBucketEntry,
    som$Dictionary$84b2aa0859$Dictionary$resize,
    som$Dictionary$84b2aa0859$Dictionary$transferEntries,
    som$Dictionary$84b2aa0859$Dictionary$splitBucket,
    som$Dictionary$84b2aa0859$Dictionary$removeAll,
    som$Dictionary$84b2aa0859$Dictionary$getKeys,
    som$Dictionary$84b2aa0859$Dictionary$getValues,
};

struct som$Dictionary$84b2aa0859$Entry$Class$ som$Dictionary$84b2aa0859$Entry$class$ = { 
    0,
    som$Dictionary$84b2aa0859$Entry$match,
};

static int initDone$ = 0;
void som$Dictionary$84b2aa0859$init$(void) {
    if(initDone$) return; else initDone$ = 1;
    som$Vector$6226d61315$init$();
    som$Vector$04445da84e$init$();
}
OBX$Cmd som$Dictionary$84b2aa0859$cmd$(const char* name) {
    if( name == 0 ) return som$Dictionary$84b2aa0859$init$;
    return 0;
}
