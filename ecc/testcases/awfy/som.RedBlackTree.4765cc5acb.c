// Generated by Oberon+ IDE (Mono) 0.9.106 on 2024-07-13T01:26:30

#include "som.RedBlackTree.4765cc5acb.h"
#include "Tester.h"

void som$RedBlackTree$4765cc5acb$Entry$init$(struct som$RedBlackTree$4765cc5acb$Entry* inst){
    inst->class$ = &som$RedBlackTree$4765cc5acb$Entry$class$;
}
void som$RedBlackTree$4765cc5acb$InsertResult$init$(struct som$RedBlackTree$4765cc5acb$InsertResult* inst){
    inst->class$ = &som$RedBlackTree$4765cc5acb$InsertResult$class$;
}
void som$RedBlackTree$4765cc5acb$Node$init$(struct som$RedBlackTree$4765cc5acb$Node* inst){
    inst->class$ = &som$RedBlackTree$4765cc5acb$Node$class$;
}
void som$RedBlackTree$4765cc5acb$RedBlackTree$init$(struct som$RedBlackTree$4765cc5acb$RedBlackTree* inst){
    inst->class$ = &som$RedBlackTree$4765cc5acb$RedBlackTree$class$;
}
struct som$RedBlackTree$4765cc5acb$Node * som$RedBlackTree$4765cc5acb$createNode(int32_t * key, struct OBX$Array$1 value) {
    struct som$RedBlackTree$4765cc5acb$Node * n;
    struct som$RedBlackTree$4765cc5acb$Node * $t0;
    n = 0;
    $t0 = OBX$Alloc(sizeof(struct som$RedBlackTree$4765cc5acb$Node));
    memset($t0,0,sizeof(struct som$RedBlackTree$4765cc5acb$Node));
    n = $t0;
    som$RedBlackTree$4765cc5acb$Node$init$($t0);
    (*n).key = (*key);
    OBX$StrCopy(&(struct OBX$Array$1){32,1,(*n).value},0,&value,0);
    (*n).color = 0;
    return n;
}

struct som$RedBlackTree$4765cc5acb$Node * som$RedBlackTree$4765cc5acb$treeMinimum(struct som$RedBlackTree$4765cc5acb$Node * x) {
    struct som$RedBlackTree$4765cc5acb$Node * current;
    current = 0;
    current = x;
    while(1) {
        if( ((void*)(*current).left != (void*)0) ) {
            current = (*current).left;
        } else {
            break;
        }
    }
    return current;
}

struct som$RedBlackTree$4765cc5acb$Node * som$RedBlackTree$4765cc5acb$Node$successor(void* this) {
    struct som$RedBlackTree$4765cc5acb$Node* this$ = this;
    struct som$RedBlackTree$4765cc5acb$Node * x;
    struct som$RedBlackTree$4765cc5acb$Node * y;
    x = 0;
    y = 0;
    x = this$;
    if( ((void*)(*x).right != (void*)0) ) {
        return som$RedBlackTree$4765cc5acb$treeMinimum((*x).right);
    } 
    y = (*x).parent;
    while(1) {
        if( (((void*)y != (void*)0) && ((void*)x == (void*)(*y).right)) ) {
            x = y;
            y = (*y).parent;
        } else {
            break;
        }
    }
    return y;
}

struct som$RedBlackTree$4765cc5acb$RedBlackTree * som$RedBlackTree$4765cc5acb$create(int32_t (*func)(int32_t *, int32_t *)) {
    struct som$RedBlackTree$4765cc5acb$RedBlackTree * t;
    struct som$RedBlackTree$4765cc5acb$RedBlackTree * $t0;
    t = 0;
    $t0 = OBX$Alloc(sizeof(struct som$RedBlackTree$4765cc5acb$RedBlackTree));
    memset($t0,0,sizeof(struct som$RedBlackTree$4765cc5acb$RedBlackTree));
    t = $t0;
    som$RedBlackTree$4765cc5acb$RedBlackTree$init$($t0);
    assert(((void*)func != (void*)0));
    (*t).compare = func;
    return t;
}

struct OBX$Array$1 som$RedBlackTree$4765cc5acb$RedBlackTree$put(void* this, int32_t * key, struct OBX$Array$1 value) {
    struct som$RedBlackTree$4765cc5acb$RedBlackTree* this$ = this;
    uint8_t newEntry;
    void* $t0;
    struct OBX$Array$1 (* $t1)(void*, int32_t *, struct OBX$Array$1, uint8_t *);
    newEntry = 0;
    return ($t1 = ((struct som$RedBlackTree$4765cc5acb$RedBlackTree *)($t0 = &(*this$)))->class$->putChecked, $t1($t0, &(*key), value, &newEntry));
}

struct OBX$Array$1 som$RedBlackTree$4765cc5acb$RedBlackTree$putChecked(void* this, int32_t * key, struct OBX$Array$1 value, uint8_t * newEntry) {
    struct som$RedBlackTree$4765cc5acb$RedBlackTree* this$ = this;
    struct som$RedBlackTree$4765cc5acb$InsertResult insertionResult;
    struct som$RedBlackTree$4765cc5acb$Node * x;
    struct som$RedBlackTree$4765cc5acb$Node * y;
    void* $t0;
    void (* $t1)(void*, int32_t *, struct OBX$Array$1, struct som$RedBlackTree$4765cc5acb$InsertResult *);
    void (* $t2)(void*, struct som$RedBlackTree$4765cc5acb$Node *);
    memset(&insertionResult,0,sizeof(insertionResult));
    som$RedBlackTree$4765cc5acb$InsertResult$init$(&insertionResult);
    x = 0;
    y = 0;
    ($t1 = ((struct som$RedBlackTree$4765cc5acb$RedBlackTree *)($t0 = &(*this$)))->class$->treeInsert, $t1($t0, &(*key), value, &insertionResult));
    if( (!insertionResult.isNewEntry) ) {
        (*newEntry) = 0;
        return (struct OBX$Array$1){32,1,insertionResult.oldValue};
    } 
    x = insertionResult.newNode;
    while(1) {
        if( (((void*)x != (void*)(*this$).root) && ((*(*x).parent).color == 0)) ) {
            if( ((void*)(*x).parent == (void*)(*(*(*x).parent).parent).left) ) {
                y = (*(*(*x).parent).parent).right;
                if( (((void*)y != (void*)0) && ((*y).color == 0)) ) {
                    (*(*x).parent).color = 1;
                    (*y).color = 1;
                    (*(*(*x).parent).parent).color = 0;
                    x = (*(*x).parent).parent;
                } else {
                    if( ((void*)x == (void*)(*(*x).parent).right) ) {
                        x = (*x).parent;
                        ($t2 = ((struct som$RedBlackTree$4765cc5acb$RedBlackTree *)($t0 = &(*this$)))->class$->leftRotate, $t2($t0, x));
                    } 
                    (*(*x).parent).color = 1;
                    (*(*(*x).parent).parent).color = 0;
                    ($t2 = ((struct som$RedBlackTree$4765cc5acb$RedBlackTree *)($t0 = &(*this$)))->class$->rightRotate, $t2($t0, (*(*x).parent).parent));
                }
            } else {
                y = (*(*(*x).parent).parent).left;
                if( (((void*)y != (void*)0) && ((*y).color == 0)) ) {
                    (*(*x).parent).color = 1;
                    (*y).color = 1;
                    (*(*(*x).parent).parent).color = 0;
                    x = (*(*x).parent).parent;
                } else {
                    if( ((void*)x == (void*)(*(*x).parent).left) ) {
                        x = (*x).parent;
                        ($t2 = ((struct som$RedBlackTree$4765cc5acb$RedBlackTree *)($t0 = &(*this$)))->class$->rightRotate, $t2($t0, x));
                    } 
                    (*(*x).parent).color = 1;
                    (*(*(*x).parent).parent).color = 0;
                    ($t2 = ((struct som$RedBlackTree$4765cc5acb$RedBlackTree *)($t0 = &(*this$)))->class$->leftRotate, $t2($t0, (*(*x).parent).parent));
                }
            }
        } else {
            break;
        }
    }
    (*(*this$).root).color = 1;
    (*newEntry) = 1;
    return (struct OBX$Array$1){1,1,&(char[1]){0}};
}

struct OBX$Array$1 som$RedBlackTree$4765cc5acb$RedBlackTree$remove(void* this, int32_t * key) {
    struct som$RedBlackTree$4765cc5acb$RedBlackTree* this$ = this;
    struct som$RedBlackTree$4765cc5acb$Node * x;
    struct som$RedBlackTree$4765cc5acb$Node * y;
    struct som$RedBlackTree$4765cc5acb$Node * z;
    struct som$RedBlackTree$4765cc5acb$Node * xParent;
    void* $t0;
    struct som$RedBlackTree$4765cc5acb$Node * (* $t1)(void*, int32_t *);
    struct som$RedBlackTree$4765cc5acb$Node * (* $t2)(void*);
    void (* $t3)(void*, struct som$RedBlackTree$4765cc5acb$Node *, struct som$RedBlackTree$4765cc5acb$Node *);
    x = 0;
    y = 0;
    z = 0;
    xParent = 0;
    z = ($t1 = ((struct som$RedBlackTree$4765cc5acb$RedBlackTree *)($t0 = &(*this$)))->class$->findNode, $t1($t0, &(*key)));
    if( ((void*)z == (void*)0) ) {
        return (struct OBX$Array$1){1,1,&(char[1]){0}};
    } 
    if( (((void*)(*z).left == (void*)0) || ((void*)(*z).right == (void*)0)) ) {
        y = z;
    } else {
        y = ($t2 = ((struct som$RedBlackTree$4765cc5acb$Node *)($t0 = &(*z)))->class$->successor, $t2($t0));
    }
    if( ((void*)(*y).left != (void*)0) ) {
        x = (*y).left;
    } else {
        x = (*y).right;
    }
    if( ((void*)x != (void*)0) ) {
        (*x).parent = (*y).parent;
        xParent = (*x).parent;
    } else {
        xParent = (*y).parent;
    }
    if( ((void*)(*y).parent == (void*)0) ) {
        (*this$).root = x;
    } else {
        if( ((void*)y == (void*)(*(*y).parent).left) ) {
            (*(*y).parent).left = x;
        } else {
            (*(*y).parent).right = x;
        }
    }
    if( ((void*)y != (void*)z) ) {
        if( ((*y).color == 1) ) {
            ($t3 = ((struct som$RedBlackTree$4765cc5acb$RedBlackTree *)($t0 = &(*this$)))->class$->removeFixup, $t3($t0, x, xParent));
        } 
        (*y).parent = (*z).parent;
        (*y).color = (*z).color;
        (*y).left = (*z).left;
        (*y).right = (*z).right;
        if( ((void*)(*z).left != (void*)0) ) {
            (*(*z).left).parent = y;
        } 
        if( ((void*)(*z).right != (void*)0) ) {
            (*(*z).right).parent = y;
        } 
        if( ((void*)(*z).parent != (void*)0) ) {
            if( ((void*)(*(*z).parent).left == (void*)z) ) {
                (*(*z).parent).left = y;
            } else {
                (*(*z).parent).right = y;
            }
        } else {
            (*this$).root = y;
        }
    } else if( ((*y).color == 1) ) {
        ($t3 = ((struct som$RedBlackTree$4765cc5acb$RedBlackTree *)($t0 = &(*this$)))->class$->removeFixup, $t3($t0, x, xParent));
    } 
    return (struct OBX$Array$1){32,1,(*z).value};
}

struct OBX$Array$1 som$RedBlackTree$4765cc5acb$RedBlackTree$get(void* this, int32_t * key) {
    struct som$RedBlackTree$4765cc5acb$RedBlackTree* this$ = this;
    struct som$RedBlackTree$4765cc5acb$Node * node;
    void* $t0;
    struct som$RedBlackTree$4765cc5acb$Node * (* $t1)(void*, int32_t *);
    node = 0;
    node = ($t1 = ((struct som$RedBlackTree$4765cc5acb$RedBlackTree *)($t0 = &(*this$)))->class$->findNode, $t1($t0, &(*key)));
    if( ((void*)node == (void*)0) ) {
        return (struct OBX$Array$1){1,1,&(char[1]){0}};
    } 
    return (struct OBX$Array$1){32,1,(*node).value};
}

void som$RedBlackTree$4765cc5acb$RedBlackTree$forEach(void* this, struct som$Interfaces$53de0d3f29$ForEachInterface * fn) {
    struct som$RedBlackTree$4765cc5acb$RedBlackTree* this$ = this;
    struct som$RedBlackTree$4765cc5acb$Node * current;
    struct som$RedBlackTree$4765cc5acb$Entry e;
    void* $t0;
    void (* $t1)(void*, struct som$RedBlackTree$4765cc5acb$Entry *);
    struct som$RedBlackTree$4765cc5acb$Node * (* $t2)(void*);
    current = 0;
    memset(&e,0,sizeof(e));
    som$RedBlackTree$4765cc5acb$Entry$init$(&e);
    if( ((void*)(*this$).root == (void*)0) ) {
        return ;
    } 
    current = som$RedBlackTree$4765cc5acb$treeMinimum((*this$).root);
    while(1) {
        if( ((void*)current != (void*)0) ) {
            e.key = (*current).key;
            OBX$StrCopy(&(struct OBX$Array$1){32,1,e.value},0,&(struct OBX$Array$1){32,1,(*current).value},0);
            ($t1 = ((struct som$Interfaces$53de0d3f29$ForEachInterface *)($t0 = &(*fn)))->class$->apply, $t1($t0, &e));
            current = ($t2 = ((struct som$RedBlackTree$4765cc5acb$Node *)($t0 = &(*current)))->class$->successor, $t2($t0));
        } else {
            break;
        }
    }
}

struct som$RedBlackTree$4765cc5acb$Node * som$RedBlackTree$4765cc5acb$RedBlackTree$findNode(void* this, int32_t * key) {
    struct som$RedBlackTree$4765cc5acb$RedBlackTree* this$ = this;
    struct som$RedBlackTree$4765cc5acb$Node * current;
    int32_t comparisonResult;
    current = 0;
    comparisonResult = 0;
    current = (*this$).root;
    while(1) {
        if( ((void*)current != (void*)0) ) {
            comparisonResult = (*this$).compare(&(*key), &(*current).key);
            if( (comparisonResult == 0) ) {
                return current;
            } else if( (comparisonResult < 0) ) {
                current = (*current).left;
            } else {
                current = (*current).right;
            }
        } else {
            break;
        }
    }
    return 0;
}

void som$RedBlackTree$4765cc5acb$RedBlackTree$treeInsert(void* this, int32_t * key, struct OBX$Array$1 value, struct som$RedBlackTree$4765cc5acb$InsertResult * res) {
    struct som$RedBlackTree$4765cc5acb$RedBlackTree* this$ = this;
    struct som$RedBlackTree$4765cc5acb$Node * x;
    struct som$RedBlackTree$4765cc5acb$Node * y;
    struct som$RedBlackTree$4765cc5acb$Node * z;
    int32_t comparisonResult;
    x = 0;
    y = 0;
    z = 0;
    comparisonResult = 0;
    x = (*this$).root;
    while(1) {
        if( ((void*)x != (void*)0) ) {
            y = x;
            comparisonResult = (*this$).compare(&(*key), &(*x).key);
            if( (comparisonResult < 0) ) {
                x = (*x).left;
            } else if( (comparisonResult > 0) ) {
                x = (*x).right;
            } else {
                (*res).isNewEntry = 0;
                OBX$StrCopy(&(struct OBX$Array$1){32,1,(*res).oldValue},0,&(struct OBX$Array$1){32,1,(*x).value},0);
                OBX$StrCopy(&(struct OBX$Array$1){32,1,(*x).value},0,&value,0);
                return ;
            }
        } else {
            break;
        }
    }
    z = som$RedBlackTree$4765cc5acb$createNode(&(*key), value);
    (*z).parent = y;
    if( ((void*)y == (void*)0) ) {
        (*this$).root = z;
    } else {
        if( ((*this$).compare(&(*key), &(*y).key) < 0) ) {
            (*y).left = z;
        } else {
            (*y).right = z;
        }
    }
    (*res).isNewEntry = 1;
    (*res).newNode = z;
}

void som$RedBlackTree$4765cc5acb$RedBlackTree$leftRotate(void* this, struct som$RedBlackTree$4765cc5acb$Node * x) {
    struct som$RedBlackTree$4765cc5acb$RedBlackTree* this$ = this;
    struct som$RedBlackTree$4765cc5acb$Node * y;
    y = 0;
    y = (*x).right;
    (*x).right = (*y).left;
    if( ((void*)(*y).left != (void*)0) ) {
        (*(*y).left).parent = x;
    } 
    (*y).parent = (*x).parent;
    if( ((void*)(*x).parent == (void*)0) ) {
        (*this$).root = y;
    } else {
        if( ((void*)x == (void*)(*(*x).parent).left) ) {
            (*(*x).parent).left = y;
        } else {
            (*(*x).parent).right = y;
        }
    }
    (*y).left = x;
    (*x).parent = y;
}

void som$RedBlackTree$4765cc5acb$RedBlackTree$rightRotate(void* this, struct som$RedBlackTree$4765cc5acb$Node * y) {
    struct som$RedBlackTree$4765cc5acb$RedBlackTree* this$ = this;
    struct som$RedBlackTree$4765cc5acb$Node * x;
    x = 0;
    x = (*y).left;
    (*y).left = (*x).right;
    if( ((void*)(*x).right != (void*)0) ) {
        (*(*x).right).parent = y;
    } 
    (*x).parent = (*y).parent;
    if( ((void*)(*y).parent == (void*)0) ) {
        (*this$).root = x;
    } else {
        if( ((void*)y == (void*)(*(*y).parent).left) ) {
            (*(*y).parent).left = x;
        } else {
            (*(*y).parent).right = x;
        }
    }
    (*x).right = y;
    (*y).parent = x;
}

void som$RedBlackTree$4765cc5acb$RedBlackTree$removeFixup(void* this, struct som$RedBlackTree$4765cc5acb$Node * x, struct som$RedBlackTree$4765cc5acb$Node * xParent) {
    struct som$RedBlackTree$4765cc5acb$RedBlackTree* this$ = this;
    struct som$RedBlackTree$4765cc5acb$Node * w;
    void* $t0;
    void (* $t1)(void*, struct som$RedBlackTree$4765cc5acb$Node *);
    w = 0;
    while(1) {
        if( (((void*)x != (void*)(*this$).root) && (((void*)x == (void*)0) || ((*x).color == 1))) ) {
            if( ((void*)x == (void*)(*xParent).left) ) {
                w = (*xParent).right;
                if( ((*w).color == 0) ) {
                    (*w).color = 1;
                    (*xParent).color = 0;
                    ($t1 = ((struct som$RedBlackTree$4765cc5acb$RedBlackTree *)($t0 = &(*this$)))->class$->leftRotate, $t1($t0, xParent));
                    w = (*xParent).right;
                } 
                if( ((((void*)(*w).left == (void*)0) || ((*(*w).left).color == 1)) && (((void*)(*w).right == (void*)0) || ((*(*w).right).color == 1))) ) {
                    (*w).color = 0;
                    x = xParent;
                    xParent = (*x).parent;
                } else {
                    if( (((void*)(*w).right == (void*)0) || ((*(*w).right).color == 1)) ) {
                        (*(*w).left).color = 1;
                        (*w).color = 0;
                        ($t1 = ((struct som$RedBlackTree$4765cc5acb$RedBlackTree *)($t0 = &(*this$)))->class$->rightRotate, $t1($t0, w));
                        w = (*xParent).right;
                    } 
                    (*w).color = (*xParent).color;
                    (*xParent).color = 1;
                    if( ((void*)(*w).right != (void*)0) ) {
                        (*(*w).right).color = 1;
                    } 
                    ($t1 = ((struct som$RedBlackTree$4765cc5acb$RedBlackTree *)($t0 = &(*this$)))->class$->leftRotate, $t1($t0, xParent));
                    x = (*this$).root;
                    xParent = (*x).parent;
                }
            } else {
                w = (*xParent).left;
                if( ((*w).color == 0) ) {
                    (*w).color = 1;
                    (*xParent).color = 0;
                    ($t1 = ((struct som$RedBlackTree$4765cc5acb$RedBlackTree *)($t0 = &(*this$)))->class$->rightRotate, $t1($t0, xParent));
                    w = (*xParent).left;
                } 
                if( ((((void*)(*w).right == (void*)0) || ((*(*w).right).color == 1)) && (((void*)(*w).left == (void*)0) || ((*(*w).left).color == 1))) ) {
                    (*w).color = 0;
                    x = xParent;
                    xParent = (*x).parent;
                } else {
                    if( (((void*)(*w).left == (void*)0) || ((*(*w).left).color == 1)) ) {
                        (*(*w).right).color = 1;
                        (*w).color = 0;
                        ($t1 = ((struct som$RedBlackTree$4765cc5acb$RedBlackTree *)($t0 = &(*this$)))->class$->leftRotate, $t1($t0, w));
                        w = (*xParent).left;
                    } 
                    (*w).color = (*xParent).color;
                    (*xParent).color = 1;
                    if( ((void*)(*w).left != (void*)0) ) {
                        (*(*w).left).color = 1;
                    } 
                    ($t1 = ((struct som$RedBlackTree$4765cc5acb$RedBlackTree *)($t0 = &(*this$)))->class$->rightRotate, $t1($t0, xParent));
                    x = (*this$).root;
                    xParent = (*x).parent;
                }
            }
        } else {
            break;
        }
    }
    if( ((void*)x != (void*)0) ) {
        (*x).color = 1;
    } 
}

struct som$RedBlackTree$4765cc5acb$Entry$Class$ som$RedBlackTree$4765cc5acb$Entry$class$ = { 
    0,
};

struct som$RedBlackTree$4765cc5acb$InsertResult$Class$ som$RedBlackTree$4765cc5acb$InsertResult$class$ = { 
    0,
};

struct som$RedBlackTree$4765cc5acb$Node$Class$ som$RedBlackTree$4765cc5acb$Node$class$ = { 
    0,
    som$RedBlackTree$4765cc5acb$Node$successor,
};

struct som$RedBlackTree$4765cc5acb$RedBlackTree$Class$ som$RedBlackTree$4765cc5acb$RedBlackTree$class$ = { 
    0,
    som$RedBlackTree$4765cc5acb$RedBlackTree$put,
    som$RedBlackTree$4765cc5acb$RedBlackTree$putChecked,
    som$RedBlackTree$4765cc5acb$RedBlackTree$remove,
    som$RedBlackTree$4765cc5acb$RedBlackTree$get,
    som$RedBlackTree$4765cc5acb$RedBlackTree$forEach,
    som$RedBlackTree$4765cc5acb$RedBlackTree$findNode,
    som$RedBlackTree$4765cc5acb$RedBlackTree$treeInsert,
    som$RedBlackTree$4765cc5acb$RedBlackTree$leftRotate,
    som$RedBlackTree$4765cc5acb$RedBlackTree$rightRotate,
    som$RedBlackTree$4765cc5acb$RedBlackTree$removeFixup,
};

static int initDone$ = 0;
void som$RedBlackTree$4765cc5acb$init$(void) {
    if(initDone$) return; else initDone$ = 1;
    som$Interfaces$53de0d3f29$init$();
}
OBX$Cmd som$RedBlackTree$4765cc5acb$cmd$(const char* name) {
    if( name == 0 ) return som$RedBlackTree$4765cc5acb$init$;
    return 0;
}
