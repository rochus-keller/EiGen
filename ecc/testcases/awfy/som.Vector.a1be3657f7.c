// Generated by Oberon+ IDE (Mono) 0.9.106 on 2024-07-13T01:26:30

#include "som.Vector.a1be3657f7.h"
#include "CD.h"

void som$Vector$a1be3657f7$Vector$init$(struct som$Vector$a1be3657f7$Vector* inst){
    inst->class$ = &som$Vector$a1be3657f7$Vector$class$;
}
struct som$Vector$a1be3657f7$Vector * som$Vector$a1be3657f7$createWithSize(int32_t siz) {
    struct som$Vector$a1be3657f7$Vector * v;
    struct som$Vector$a1be3657f7$Vector * $t0;
    struct CD$CallSign * $t1;
    v = 0;
    $t0 = OBX$Alloc(sizeof(struct som$Vector$a1be3657f7$Vector));
    memset($t0,0,sizeof(struct som$Vector$a1be3657f7$Vector));
    v = $t0;
    som$Vector$a1be3657f7$Vector$init$($t0);
    {int $0 = siz, $n = $0, $s=sizeof(struct CD$CallSign); $t1 = OBX$Alloc($s*$n); memset($t1,0,$s*$n); (*v).storage = (struct OBX$Array$1){$0, 1, $t1};for(int $i = 0; $i < $n; $i++) CD$CallSign$init$(&$t1[$i]); };
    (*v).firstIdx = 0;
    (*v).lastIdx = 0;
    return v;
}

struct som$Vector$a1be3657f7$Vector * som$Vector$a1be3657f7$create() {
    return som$Vector$a1be3657f7$createWithSize(50);
}

struct som$Vector$a1be3657f7$Vector * som$Vector$a1be3657f7$createWithElement(struct CD$CallSign * elem) {
    struct som$Vector$a1be3657f7$Vector * v;
    void* $t0;
    void (* $t1)(void*, struct CD$CallSign *);
    v = 0;
    v = som$Vector$a1be3657f7$createWithSize(1);
    ($t1 = ((struct som$Vector$a1be3657f7$Vector *)($t0 = &(*v)))->class$->append, $t1($t0, &(*(struct CD$CallSign *)&(*elem))));
    return v;
}

struct CD$CallSign som$Vector$a1be3657f7$Vector$at(void* this, int32_t idx) {
    struct som$Vector$a1be3657f7$Vector* this$ = this;
    struct CD$CallSign * $t0;
    struct OBX$Array$1* $t1;
    if( (idx >= ((*this$).storage).$1) ) {
        return ($t0= &(struct CD$CallSign){0}, $t0->class$ = &CD$CallSign$class$, *$t0);
    } 
    return (*($t1 = (&(*this$).storage),&((struct CD$CallSign *)$t1->$a)[idx]));
}

void som$Vector$a1be3657f7$Vector$resize(void* this, int32_t newLength) {
    struct som$Vector$a1be3657f7$Vector* this$ = this;
    struct OBX$Array$1 storage;
    int32_t oldLength;
    int32_t i;
    struct CD$CallSign * $t0;
    struct OBX$Array$1* $t1;
    struct OBX$Array$1* $t2;
    memset(&storage,0,sizeof(storage));
    oldLength = 0;
    i = 0;
    {int $0 = newLength, $n = $0, $s=sizeof(struct CD$CallSign); $t0 = OBX$Alloc($s*$n); memset($t0,0,$s*$n); storage = (struct OBX$Array$1){$0, 1, $t0};for(int $i = 0; $i < $n; $i++) CD$CallSign$init$(&$t0[$i]); };
    i = 0;
    while(1) {
        if( (i <= (((*this$).storage).$1 - 1)) ) {
            (*($t1 = (&storage),&((struct CD$CallSign *)$t1->$a)[i])) = (*($t2 = (&(*this$).storage),&((struct CD$CallSign *)$t2->$a)[i]));
            i = (i + 1);
        } else {
            break;
        }
    }
    (*this$).storage = storage;
}

void som$Vector$a1be3657f7$Vector$atPut(void* this, int32_t idx, struct CD$CallSign * elem) {
    struct som$Vector$a1be3657f7$Vector* this$ = this;
    int32_t length;
    void* $t0;
    void (* $t1)(void*, int32_t);
    struct OBX$Array$1* $t2;
    length = 0;
    length = ((*this$).storage).$1;
    if( (idx >= length) ) {
        while(1) {
            if( (length <= idx) ) {
                length = (length * 2);
            } else {
                break;
            }
        }
        ($t1 = ((struct som$Vector$a1be3657f7$Vector *)($t0 = &(*this$)))->class$->resize, $t1($t0, length));
    } 
    (*($t2 = (&(*this$).storage),&((struct CD$CallSign *)$t2->$a)[idx])) = (*(struct CD$CallSign *)&(*elem));
    if( ((*this$).lastIdx < (idx + 1)) ) {
        (*this$).lastIdx = (idx + 1);
    } 
}

void som$Vector$a1be3657f7$Vector$append(void* this, struct CD$CallSign * elem) {
    struct som$Vector$a1be3657f7$Vector* this$ = this;
    int32_t lenght;
    void* $t0;
    void (* $t1)(void*, int32_t);
    struct OBX$Array$1* $t2;
    lenght = 0;
    lenght = ((*this$).storage).$1;
    if( ((*this$).lastIdx >= lenght) ) {
        lenght = (lenght * 2);
        ($t1 = ((struct som$Vector$a1be3657f7$Vector *)($t0 = &(*this$)))->class$->resize, $t1($t0, lenght));
    } 
    (*($t2 = (&(*this$).storage),&((struct CD$CallSign *)$t2->$a)[(*this$).lastIdx])) = (*(struct CD$CallSign *)&(*elem));
    (*this$).lastIdx = ((*this$).lastIdx + 1);
}

uint8_t som$Vector$a1be3657f7$Vector$isEmpty(void* this) {
    struct som$Vector$a1be3657f7$Vector* this$ = this;
    return ((*this$).lastIdx == (*this$).firstIdx);
}

struct CD$CallSign som$Vector$a1be3657f7$Vector$first(void* this) {
    struct som$Vector$a1be3657f7$Vector* this$ = this;
    void* $t0;
    uint8_t (* $t1)(void*);
    struct CD$CallSign * $t2;
    struct OBX$Array$1* $t3;
    if( ($t1 = ((struct som$Vector$a1be3657f7$Vector *)($t0 = &(*this$)))->class$->isEmpty, $t1($t0)) ) {
        return ($t2= &(struct CD$CallSign){0}, $t2->class$ = &CD$CallSign$class$, *$t2);
    } 
    return (*($t3 = (&(*this$).storage),&((struct CD$CallSign *)$t3->$a)[(*this$).firstIdx]));
}

struct CD$CallSign som$Vector$a1be3657f7$Vector$removeFirst(void* this) {
    struct som$Vector$a1be3657f7$Vector* this$ = this;
    void* $t0;
    uint8_t (* $t1)(void*);
    struct CD$CallSign * $t2;
    struct OBX$Array$1* $t3;
    if( ($t1 = ((struct som$Vector$a1be3657f7$Vector *)($t0 = &(*this$)))->class$->isEmpty, $t1($t0)) ) {
        return ($t2= &(struct CD$CallSign){0}, $t2->class$ = &CD$CallSign$class$, *$t2);
    } 
    (*this$).firstIdx = ((*this$).firstIdx + 1);
    return (*($t3 = (&(*this$).storage),&((struct CD$CallSign *)$t3->$a)[((*this$).firstIdx - 1)]));
}

void som$Vector$a1be3657f7$Vector$removeAll(void* this) {
    struct som$Vector$a1be3657f7$Vector* this$ = this;
    (*this$).firstIdx = 0;
    (*this$).lastIdx = 0;
}

int32_t som$Vector$a1be3657f7$Vector$getSize(void* this) {
    struct som$Vector$a1be3657f7$Vector* this$ = this;
    return ((*this$).lastIdx - (*this$).firstIdx);
}

int32_t som$Vector$a1be3657f7$Vector$capacity(void* this) {
    struct som$Vector$a1be3657f7$Vector* this$ = this;
    return ((*this$).storage).$1;
}

void som$Vector$a1be3657f7$Vector$forEach(void* this, struct som$Interfaces$a1be3657f7$ForEachInterface * fn) {
    struct som$Vector$a1be3657f7$Vector* this$ = this;
    int32_t i;
    void* $t0;
    void (* $t1)(void*, struct CD$CallSign *);
    struct OBX$Array$1* $t2;
    i = 0;
    i = (*this$).firstIdx;
    while(1) {
        if( (i <= ((*this$).lastIdx - 1)) ) {
            ($t1 = ((struct som$Interfaces$a1be3657f7$ForEachInterface *)($t0 = &(*fn)))->class$->apply, $t1($t0, &(*($t2 = (&(*this$).storage),&((struct CD$CallSign *)$t2->$a)[i]))));
            i = (i + 1);
        } else {
            break;
        }
    }
}

uint8_t som$Vector$a1be3657f7$Vector$hasSome(void* this, struct som$Interfaces$a1be3657f7$TestInterface * fn) {
    struct som$Vector$a1be3657f7$Vector* this$ = this;
    int32_t i;
    void* $t0;
    uint8_t (* $t1)(void*, struct CD$CallSign *);
    struct OBX$Array$1* $t2;
    i = 0;
    i = (*this$).firstIdx;
    while(1) {
        if( (i <= ((*this$).lastIdx - 1)) ) {
            if( ($t1 = ((struct som$Interfaces$a1be3657f7$TestInterface *)($t0 = &(*fn)))->class$->test, $t1($t0, &(*($t2 = (&(*this$).storage),&((struct CD$CallSign *)$t2->$a)[i])))) ) {
                return 1;
            } 
            i = (i + 1);
        } else {
            break;
        }
    }
    return 0;
}

uint8_t som$Vector$a1be3657f7$Vector$getOne(void* this, struct som$Interfaces$a1be3657f7$TestInterface * fn, struct CD$CallSign * out) {
    struct som$Vector$a1be3657f7$Vector* this$ = this;
    int32_t i;
    void* $t0;
    uint8_t (* $t1)(void*, struct CD$CallSign *);
    struct OBX$Array$1* $t2;
    struct OBX$Array$1* $t3;
    i = 0;
    i = (*this$).firstIdx;
    while(1) {
        if( (i <= ((*this$).lastIdx - 1)) ) {
            if( ($t1 = ((struct som$Interfaces$a1be3657f7$TestInterface *)($t0 = &(*fn)))->class$->test, $t1($t0, &(*($t2 = (&(*this$).storage),&((struct CD$CallSign *)$t2->$a)[i])))) ) {
                (*(struct CD$CallSign *)&(*out)) = (*($t3 = (&(*this$).storage),&((struct CD$CallSign *)$t3->$a)[i]));
                return 1;
            } 
            i = (i + 1);
        } else {
            break;
        }
    }
    return 0;
}

uint8_t som$Vector$a1be3657f7$Vector$remove(void* this, struct CD$CallSign * obj, uint8_t (*eq)(struct CD$CallSign *, struct CD$CallSign *)) {
    struct som$Vector$a1be3657f7$Vector* this$ = this;
    struct OBX$Array$1 newArray;
    int32_t i;
    int32_t newLast;
    uint8_t found;
    void* $t0;
    int32_t (* $t1)(void*);
    struct CD$CallSign * $t2;
    struct OBX$Array$1* $t3;
    struct OBX$Array$1* $t4;
    memset(&newArray,0,sizeof(newArray));
    i = 0;
    newLast = 0;
    found = 0;
    {int $0 = ($t1 = ((struct som$Vector$a1be3657f7$Vector *)($t0 = &(*this$)))->class$->capacity, $t1($t0)), $n = $0, $s=sizeof(struct CD$CallSign); $t2 = OBX$Alloc($s*$n); memset($t2,0,$s*$n); newArray = (struct OBX$Array$1){$0, 1, $t2};for(int $i = 0; $i < $n; $i++) CD$CallSign$init$(&$t2[$i]); };
    newLast = 0;
    found = 0;
    i = (*this$).firstIdx;
    while(1) {
        if( (i <= ((*this$).lastIdx - 1)) ) {
            if( eq(&(*($t3 = (&(*this$).storage),&((struct CD$CallSign *)$t3->$a)[i])), &(*(struct CD$CallSign *)&(*obj))) ) {
                found = 1;
            } else {
                (*($t3 = (&newArray),&((struct CD$CallSign *)$t3->$a)[newLast])) = (*($t4 = (&(*this$).storage),&((struct CD$CallSign *)$t4->$a)[i]));
                newLast++;
            }
            i = (i + 1);
        } else {
            break;
        }
    }
    (*this$).storage = newArray;
    (*this$).lastIdx = newLast;
    (*this$).firstIdx = 0;
    return found;
}

void som$Vector$a1be3657f7$Vector$sort(void* this, struct som$Interfaces$a1be3657f7$Comparator * c) {
    struct som$Vector$a1be3657f7$Vector* this$ = this;
    void* $t0;
    int32_t (* $t1)(void*);
    void* $t2;
    void (* $t3)(void*, int32_t, int32_t, struct som$Interfaces$a1be3657f7$Comparator *);
    if( (($t1 = ((struct som$Vector$a1be3657f7$Vector *)($t0 = &(*this$)))->class$->getSize, $t1($t0)) > 0) ) {
        ($t3 = ((struct som$Vector$a1be3657f7$Vector *)($t2 = &(*this$)))->class$->sortImp, $t3($t2, (*this$).firstIdx, ((*this$).lastIdx - 1), &(*c)));
    } 
}

void som$Vector$a1be3657f7$Vector$sortImp(void* this, int32_t i, int32_t j, struct som$Interfaces$a1be3657f7$Comparator * c) {
    struct som$Vector$a1be3657f7$Vector* this$ = this;
    int32_t n;
    int32_t ij;
    int32_t k;
    int32_t l;
    struct CD$CallSign di;
    struct CD$CallSign dj;
    struct CD$CallSign tt;
    struct CD$CallSign dij;
    struct OBX$Array$1* $t0;
    void* $t1;
    int32_t (* $t2)(void*, struct CD$CallSign *, struct CD$CallSign *);
    void* $t3;
    int32_t (* $t4)(void*, struct CD$CallSign *, struct CD$CallSign *);
    void (* $t5)(void*, int32_t, int32_t, struct som$Interfaces$a1be3657f7$Comparator *);
    n = 0;
    ij = 0;
    k = 0;
    l = 0;
    memset(&di,0,sizeof(di));
    CD$CallSign$init$(&di);
    memset(&dj,0,sizeof(dj));
    CD$CallSign$init$(&dj);
    memset(&tt,0,sizeof(tt));
    CD$CallSign$init$(&tt);
    memset(&dij,0,sizeof(dij));
    CD$CallSign$init$(&dij);
    n = ((j + 1) - i);
    if( (n <= 1) ) {
        return ;
    } 
    (*(struct CD$CallSign *)&di) = (*($t0 = (&(*this$).storage),&((struct CD$CallSign *)$t0->$a)[i]));
    (*(struct CD$CallSign *)&dj) = (*($t0 = (&(*this$).storage),&((struct CD$CallSign *)$t0->$a)[j]));
    if( (($t2 = ((struct som$Interfaces$a1be3657f7$Comparator *)($t1 = &(*c)))->class$->compare, $t2($t1, &(*(struct CD$CallSign *)&di), &(*(struct CD$CallSign *)&dj))) > 0) ) {
        som$Vector$a1be3657f7$swap((*this$).storage, i, j);
        (*(struct CD$CallSign *)&tt) = (*(struct CD$CallSign *)&di);
        (*(struct CD$CallSign *)&di) = (*(struct CD$CallSign *)&dj);
        (*(struct CD$CallSign *)&dj) = (*(struct CD$CallSign *)&tt);
    } 
    if( (n > 2) ) {
        ij = OBX$Div32((i + j),2);
        (*(struct CD$CallSign *)&dij) = (*($t0 = (&(*this$).storage),&((struct CD$CallSign *)$t0->$a)[ij]));
        if( (($t2 = ((struct som$Interfaces$a1be3657f7$Comparator *)($t1 = &(*c)))->class$->compare, $t2($t1, &(*(struct CD$CallSign *)&di), &(*(struct CD$CallSign *)&dij))) <= 0) ) {
            if( (($t4 = ((struct som$Interfaces$a1be3657f7$Comparator *)($t3 = &(*c)))->class$->compare, $t4($t3, &(*(struct CD$CallSign *)&dij), &(*(struct CD$CallSign *)&dj))) > 0) ) {
                som$Vector$a1be3657f7$swap((*this$).storage, j, ij);
                (*(struct CD$CallSign *)&dij) = (*(struct CD$CallSign *)&dj);
            } 
        } else {
            som$Vector$a1be3657f7$swap((*this$).storage, i, ij);
            (*(struct CD$CallSign *)&dij) = (*(struct CD$CallSign *)&di);
        }
        if( (n > 3) ) {
            k = i;
            l = (j - 1);
            while(1) {
                while(1) {
                    if( ((k <= l) && (($t2 = ((struct som$Interfaces$a1be3657f7$Comparator *)($t1 = &(*c)))->class$->compare, $t2($t1, &(*(struct CD$CallSign *)&dij), &(*($t0 = (&(*this$).storage),&((struct CD$CallSign *)$t0->$a)[l])))) <= 0)) ) {
                        l = (l - 1);
                    } else {
                        break;
                    }
                }
                k = (k + 1);
                while(1) {
                    if( ((k <= l) && (($t2 = ((struct som$Interfaces$a1be3657f7$Comparator *)($t1 = &(*c)))->class$->compare, $t2($t1, &(*($t0 = (&(*this$).storage),&((struct CD$CallSign *)$t0->$a)[k])), &(*(struct CD$CallSign *)&dij))) <= 0)) ) {
                        k = (k + 1);
                    } else {
                        break;
                    }
                }
                if( (k > l) ) {
                    break;
                } 
                som$Vector$a1be3657f7$swap((*this$).storage, k, l);
            }
            ($t5 = ((struct som$Vector$a1be3657f7$Vector *)($t1 = &(*this$)))->class$->sortImp, $t5($t1, i, l, &(*c)));
            ($t5 = ((struct som$Vector$a1be3657f7$Vector *)($t1 = &(*this$)))->class$->sortImp, $t5($t1, k, j, &(*c)));
        } 
    } 
}

void som$Vector$a1be3657f7$swap(struct OBX$Array$1 storage2, int32_t i, int32_t j) {
    struct CD$CallSign temp;
    struct OBX$Array$1* $t0;
    struct OBX$Array$1* $t1;
    memset(&temp,0,sizeof(temp));
    CD$CallSign$init$(&temp);
    (*(struct CD$CallSign *)&temp) = (*($t0 = (&storage2),&((struct CD$CallSign *)$t0->$a)[i]));
    (*($t0 = (&storage2),&((struct CD$CallSign *)$t0->$a)[i])) = (*($t1 = (&storage2),&((struct CD$CallSign *)$t1->$a)[j]));
    (*($t0 = (&storage2),&((struct CD$CallSign *)$t0->$a)[j])) = (*(struct CD$CallSign *)&temp);
}

struct som$Vector$a1be3657f7$Vector$Class$ som$Vector$a1be3657f7$Vector$class$ = { 
    0,
    som$Vector$a1be3657f7$Vector$at,
    som$Vector$a1be3657f7$Vector$resize,
    som$Vector$a1be3657f7$Vector$atPut,
    som$Vector$a1be3657f7$Vector$append,
    som$Vector$a1be3657f7$Vector$isEmpty,
    som$Vector$a1be3657f7$Vector$first,
    som$Vector$a1be3657f7$Vector$removeFirst,
    som$Vector$a1be3657f7$Vector$removeAll,
    som$Vector$a1be3657f7$Vector$getSize,
    som$Vector$a1be3657f7$Vector$capacity,
    som$Vector$a1be3657f7$Vector$forEach,
    som$Vector$a1be3657f7$Vector$hasSome,
    som$Vector$a1be3657f7$Vector$getOne,
    som$Vector$a1be3657f7$Vector$remove,
    som$Vector$a1be3657f7$Vector$sort,
    som$Vector$a1be3657f7$Vector$sortImp,
};

static int initDone$ = 0;
void som$Vector$a1be3657f7$init$(void) {
    if(initDone$) return; else initDone$ = 1;
    som$Interfaces$a1be3657f7$init$();
}
OBX$Cmd som$Vector$a1be3657f7$cmd$(const char* name) {
    if( name == 0 ) return som$Vector$a1be3657f7$init$;
    return 0;
}
