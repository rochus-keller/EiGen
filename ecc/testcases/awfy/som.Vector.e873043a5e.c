// Generated by Oberon+ IDE (Mono) 0.9.106 on 2024-07-13T01:26:30

#include "som.Vector.e873043a5e.h"
#include "Tester.h"

void som$Vector$e873043a5e$Vector$init$(struct som$Vector$e873043a5e$Vector* inst){
    inst->class$ = &som$Vector$e873043a5e$Vector$class$;
}
struct som$Vector$e873043a5e$Vector * som$Vector$e873043a5e$createWithSize(int32_t siz) {
    struct som$Vector$e873043a5e$Vector * v;
    struct som$Vector$e873043a5e$Vector * $t0;
    char * $t1;
    v = 0;
    $t0 = OBX$Alloc(sizeof(struct som$Vector$e873043a5e$Vector));
    memset($t0,0,sizeof(struct som$Vector$e873043a5e$Vector));
    v = $t0;
    som$Vector$e873043a5e$Vector$init$($t0);
    {int $0 = siz, $1 = 32, $n = $0 * $1, $s=sizeof(char); $t1 = OBX$Alloc($s*$n); memset($t1,0,$s*$n); (*v).storage = (struct OBX$Array$2){$0, $1, 1, $t1};};
    (*v).firstIdx = 0;
    (*v).lastIdx = 0;
    return v;
}

struct som$Vector$e873043a5e$Vector * som$Vector$e873043a5e$create() {
    return som$Vector$e873043a5e$createWithSize(50);
}

struct som$Vector$e873043a5e$Vector * som$Vector$e873043a5e$createWithElement(struct OBX$Array$1 elem) {
    struct som$Vector$e873043a5e$Vector * v;
    void* $t0;
    void (* $t1)(void*, struct OBX$Array$1);
    v = 0;
    v = som$Vector$e873043a5e$createWithSize(1);
    ($t1 = ((struct som$Vector$e873043a5e$Vector *)($t0 = &(*v)))->class$->append, $t1($t0, elem));
    return v;
}

struct OBX$Array$1 som$Vector$e873043a5e$Vector$at(void* this, int32_t idx) {
    struct som$Vector$e873043a5e$Vector* this$ = this;
    struct OBX$Array$2* $t0;
    if( (idx >= ((*this$).storage).$1) ) {
        return (struct OBX$Array$1){1,1,&(char[1]){0}};
    } 
    return ($t0 = (&(*this$).storage),(struct OBX$Array$1){32,1,&((char *)$t0->$a)[idx*32]});
}

void som$Vector$e873043a5e$Vector$resize(void* this, int32_t newLength) {
    struct som$Vector$e873043a5e$Vector* this$ = this;
    struct OBX$Array$2 storage;
    int32_t oldLength;
    int32_t i;
    char * $t0;
    struct OBX$Array$2* $t1;
    struct OBX$Array$2* $t2;
    memset(&storage,0,sizeof(storage));
    oldLength = 0;
    i = 0;
    {int $0 = newLength, $1 = 32, $n = $0 * $1, $s=sizeof(char); $t0 = OBX$Alloc($s*$n); memset($t0,0,$s*$n); storage = (struct OBX$Array$2){$0, $1, 1, $t0};};
    i = 0;
    while(1) {
        if( (i <= (((*this$).storage).$1 - 1)) ) {
            OBX$StrCopy(($t1 = (&storage),&(struct OBX$Array$1){32,1,&((char *)$t1->$a)[i*32]}),0,($t2 = (&(*this$).storage),&(struct OBX$Array$1){32,1,&((char *)$t2->$a)[i*32]}),0);
            i = (i + 1);
        } else {
            break;
        }
    }
    (*this$).storage = storage;
}

void som$Vector$e873043a5e$Vector$atPut(void* this, int32_t idx, struct OBX$Array$1 elem) {
    struct som$Vector$e873043a5e$Vector* this$ = this;
    int32_t length;
    void* $t0;
    void (* $t1)(void*, int32_t);
    struct OBX$Array$2* $t2;
    length = 0;
    length = ((*this$).storage).$1;
    if( (idx >= length) ) {
        while(1) {
            if( (length <= idx) ) {
                length = (length * 2);
            } else {
                break;
            }
        }
        ($t1 = ((struct som$Vector$e873043a5e$Vector *)($t0 = &(*this$)))->class$->resize, $t1($t0, length));
    } 
    OBX$StrCopy(($t2 = (&(*this$).storage),&(struct OBX$Array$1){32,1,&((char *)$t2->$a)[idx*32]}),0,&elem,0);
    if( ((*this$).lastIdx < (idx + 1)) ) {
        (*this$).lastIdx = (idx + 1);
    } 
}

void som$Vector$e873043a5e$Vector$append(void* this, struct OBX$Array$1 elem) {
    struct som$Vector$e873043a5e$Vector* this$ = this;
    int32_t lenght;
    void* $t0;
    void (* $t1)(void*, int32_t);
    struct OBX$Array$2* $t2;
    lenght = 0;
    lenght = ((*this$).storage).$1;
    if( ((*this$).lastIdx >= lenght) ) {
        lenght = (lenght * 2);
        ($t1 = ((struct som$Vector$e873043a5e$Vector *)($t0 = &(*this$)))->class$->resize, $t1($t0, lenght));
    } 
    OBX$StrCopy(($t2 = (&(*this$).storage),&(struct OBX$Array$1){32,1,&((char *)$t2->$a)[(*this$).lastIdx*32]}),0,&elem,0);
    (*this$).lastIdx = ((*this$).lastIdx + 1);
}

uint8_t som$Vector$e873043a5e$Vector$isEmpty(void* this) {
    struct som$Vector$e873043a5e$Vector* this$ = this;
    return ((*this$).lastIdx == (*this$).firstIdx);
}

struct OBX$Array$1 som$Vector$e873043a5e$Vector$first(void* this) {
    struct som$Vector$e873043a5e$Vector* this$ = this;
    void* $t0;
    uint8_t (* $t1)(void*);
    struct OBX$Array$2* $t2;
    if( ($t1 = ((struct som$Vector$e873043a5e$Vector *)($t0 = &(*this$)))->class$->isEmpty, $t1($t0)) ) {
        return (struct OBX$Array$1){1,1,&(char[1]){0}};
    } 
    return ($t2 = (&(*this$).storage),(struct OBX$Array$1){32,1,&((char *)$t2->$a)[(*this$).firstIdx*32]});
}

struct OBX$Array$1 som$Vector$e873043a5e$Vector$removeFirst(void* this) {
    struct som$Vector$e873043a5e$Vector* this$ = this;
    void* $t0;
    uint8_t (* $t1)(void*);
    struct OBX$Array$2* $t2;
    if( ($t1 = ((struct som$Vector$e873043a5e$Vector *)($t0 = &(*this$)))->class$->isEmpty, $t1($t0)) ) {
        return (struct OBX$Array$1){1,1,&(char[1]){0}};
    } 
    (*this$).firstIdx = ((*this$).firstIdx + 1);
    return ($t2 = (&(*this$).storage),(struct OBX$Array$1){32,1,&((char *)$t2->$a)[((*this$).firstIdx - 1)*32]});
}

void som$Vector$e873043a5e$Vector$removeAll(void* this) {
    struct som$Vector$e873043a5e$Vector* this$ = this;
    (*this$).firstIdx = 0;
    (*this$).lastIdx = 0;
}

int32_t som$Vector$e873043a5e$Vector$getSize(void* this) {
    struct som$Vector$e873043a5e$Vector* this$ = this;
    return ((*this$).lastIdx - (*this$).firstIdx);
}

int32_t som$Vector$e873043a5e$Vector$capacity(void* this) {
    struct som$Vector$e873043a5e$Vector* this$ = this;
    return ((*this$).storage).$1;
}

void som$Vector$e873043a5e$Vector$forEach(void* this, struct som$Interfaces$e873043a5e$ForEachInterface * fn) {
    struct som$Vector$e873043a5e$Vector* this$ = this;
    int32_t i;
    void* $t0;
    void (* $t1)(void*, struct OBX$Array$1);
    struct OBX$Array$2* $t2;
    i = 0;
    i = (*this$).firstIdx;
    while(1) {
        if( (i <= ((*this$).lastIdx - 1)) ) {
            ($t1 = ((struct som$Interfaces$e873043a5e$ForEachInterface *)($t0 = &(*fn)))->class$->apply, $t1($t0, ($t2 = (&(*this$).storage),(struct OBX$Array$1){32,1,&((char *)$t2->$a)[i*32]})));
            i = (i + 1);
        } else {
            break;
        }
    }
}

uint8_t som$Vector$e873043a5e$Vector$hasSome(void* this, struct som$Interfaces$e873043a5e$TestInterface * fn) {
    struct som$Vector$e873043a5e$Vector* this$ = this;
    int32_t i;
    void* $t0;
    uint8_t (* $t1)(void*, struct OBX$Array$1);
    struct OBX$Array$2* $t2;
    i = 0;
    i = (*this$).firstIdx;
    while(1) {
        if( (i <= ((*this$).lastIdx - 1)) ) {
            if( ($t1 = ((struct som$Interfaces$e873043a5e$TestInterface *)($t0 = &(*fn)))->class$->test, $t1($t0, ($t2 = (&(*this$).storage),(struct OBX$Array$1){32,1,&((char *)$t2->$a)[i*32]}))) ) {
                return 1;
            } 
            i = (i + 1);
        } else {
            break;
        }
    }
    return 0;
}

uint8_t som$Vector$e873043a5e$Vector$getOne(void* this, struct som$Interfaces$e873043a5e$TestInterface * fn, struct OBX$Array$1 out) {
    struct som$Vector$e873043a5e$Vector* this$ = this;
    int32_t i;
    void* $t0;
    uint8_t (* $t1)(void*, struct OBX$Array$1);
    struct OBX$Array$2* $t2;
    struct OBX$Array$2* $t3;
    i = 0;
    i = (*this$).firstIdx;
    while(1) {
        if( (i <= ((*this$).lastIdx - 1)) ) {
            if( ($t1 = ((struct som$Interfaces$e873043a5e$TestInterface *)($t0 = &(*fn)))->class$->test, $t1($t0, ($t2 = (&(*this$).storage),(struct OBX$Array$1){32,1,&((char *)$t2->$a)[i*32]}))) ) {
                OBX$StrCopy(&out,0,($t3 = (&(*this$).storage),&(struct OBX$Array$1){32,1,&((char *)$t3->$a)[i*32]}),0);
                return 1;
            } 
            i = (i + 1);
        } else {
            break;
        }
    }
    return 0;
}

uint8_t som$Vector$e873043a5e$Vector$remove(void* this, struct OBX$Array$1 obj, uint8_t (*eq)(struct OBX$Array$1, struct OBX$Array$1)) {
    struct som$Vector$e873043a5e$Vector* this$ = this;
    struct OBX$Array$2 newArray;
    int32_t i;
    int32_t newLast;
    uint8_t found;
    void* $t0;
    int32_t (* $t1)(void*);
    char * $t2;
    struct OBX$Array$2* $t3;
    struct OBX$Array$2* $t4;
    memset(&newArray,0,sizeof(newArray));
    i = 0;
    newLast = 0;
    found = 0;
    {int $0 = ($t1 = ((struct som$Vector$e873043a5e$Vector *)($t0 = &(*this$)))->class$->capacity, $t1($t0)), $1 = 32, $n = $0 * $1, $s=sizeof(char); $t2 = OBX$Alloc($s*$n); memset($t2,0,$s*$n); newArray = (struct OBX$Array$2){$0, $1, 1, $t2};};
    newLast = 0;
    found = 0;
    i = (*this$).firstIdx;
    while(1) {
        if( (i <= ((*this$).lastIdx - 1)) ) {
            if( eq(($t3 = (&(*this$).storage),(struct OBX$Array$1){32,1,&((char *)$t3->$a)[i*32]}), obj) ) {
                found = 1;
            } else {
                OBX$StrCopy(($t3 = (&newArray),&(struct OBX$Array$1){32,1,&((char *)$t3->$a)[newLast*32]}),0,($t4 = (&(*this$).storage),&(struct OBX$Array$1){32,1,&((char *)$t4->$a)[i*32]}),0);
                newLast++;
            }
            i = (i + 1);
        } else {
            break;
        }
    }
    (*this$).storage = newArray;
    (*this$).lastIdx = newLast;
    (*this$).firstIdx = 0;
    return found;
}

void som$Vector$e873043a5e$Vector$sort(void* this, struct som$Interfaces$e873043a5e$Comparator * c) {
    struct som$Vector$e873043a5e$Vector* this$ = this;
    void* $t0;
    int32_t (* $t1)(void*);
    void* $t2;
    void (* $t3)(void*, int32_t, int32_t, struct som$Interfaces$e873043a5e$Comparator *);
    if( (($t1 = ((struct som$Vector$e873043a5e$Vector *)($t0 = &(*this$)))->class$->getSize, $t1($t0)) > 0) ) {
        ($t3 = ((struct som$Vector$e873043a5e$Vector *)($t2 = &(*this$)))->class$->sortImp, $t3($t2, (*this$).firstIdx, ((*this$).lastIdx - 1), &(*c)));
    } 
}

void som$Vector$e873043a5e$Vector$sortImp(void* this, int32_t i, int32_t j, struct som$Interfaces$e873043a5e$Comparator * c) {
    struct som$Vector$e873043a5e$Vector* this$ = this;
    int32_t n;
    int32_t ij;
    int32_t k;
    int32_t l;
    char di[32];
    char dj[32];
    char tt[32];
    char dij[32];
    struct OBX$Array$2* $t0;
    void* $t1;
    int32_t (* $t2)(void*, struct OBX$Array$1, struct OBX$Array$1);
    void* $t3;
    int32_t (* $t4)(void*, struct OBX$Array$1, struct OBX$Array$1);
    void (* $t5)(void*, int32_t, int32_t, struct som$Interfaces$e873043a5e$Comparator *);
    n = 0;
    ij = 0;
    k = 0;
    l = 0;
    memset(&di,0,sizeof(di));
    memset(&dj,0,sizeof(dj));
    memset(&tt,0,sizeof(tt));
    memset(&dij,0,sizeof(dij));
    n = ((j + 1) - i);
    if( (n <= 1) ) {
        return ;
    } 
    OBX$StrCopy(&(struct OBX$Array$1){32,1,di},0,($t0 = (&(*this$).storage),&(struct OBX$Array$1){32,1,&((char *)$t0->$a)[i*32]}),0);
    OBX$StrCopy(&(struct OBX$Array$1){32,1,dj},0,($t0 = (&(*this$).storage),&(struct OBX$Array$1){32,1,&((char *)$t0->$a)[j*32]}),0);
    if( (($t2 = ((struct som$Interfaces$e873043a5e$Comparator *)($t1 = &(*c)))->class$->compare, $t2($t1, (struct OBX$Array$1){32,1,di}, (struct OBX$Array$1){32,1,dj})) > 0) ) {
        som$Vector$e873043a5e$swap((*this$).storage, i, j);
        OBX$StrCopy(&(struct OBX$Array$1){32,1,tt},0,&(struct OBX$Array$1){32,1,di},0);
        OBX$StrCopy(&(struct OBX$Array$1){32,1,di},0,&(struct OBX$Array$1){32,1,dj},0);
        OBX$StrCopy(&(struct OBX$Array$1){32,1,dj},0,&(struct OBX$Array$1){32,1,tt},0);
    } 
    if( (n > 2) ) {
        ij = OBX$Div32((i + j),2);
        OBX$StrCopy(&(struct OBX$Array$1){32,1,dij},0,($t0 = (&(*this$).storage),&(struct OBX$Array$1){32,1,&((char *)$t0->$a)[ij*32]}),0);
        if( (($t2 = ((struct som$Interfaces$e873043a5e$Comparator *)($t1 = &(*c)))->class$->compare, $t2($t1, (struct OBX$Array$1){32,1,di}, (struct OBX$Array$1){32,1,dij})) <= 0) ) {
            if( (($t4 = ((struct som$Interfaces$e873043a5e$Comparator *)($t3 = &(*c)))->class$->compare, $t4($t3, (struct OBX$Array$1){32,1,dij}, (struct OBX$Array$1){32,1,dj})) > 0) ) {
                som$Vector$e873043a5e$swap((*this$).storage, j, ij);
                OBX$StrCopy(&(struct OBX$Array$1){32,1,dij},0,&(struct OBX$Array$1){32,1,dj},0);
            } 
        } else {
            som$Vector$e873043a5e$swap((*this$).storage, i, ij);
            OBX$StrCopy(&(struct OBX$Array$1){32,1,dij},0,&(struct OBX$Array$1){32,1,di},0);
        }
        if( (n > 3) ) {
            k = i;
            l = (j - 1);
            while(1) {
                while(1) {
                    if( ((k <= l) && (($t2 = ((struct som$Interfaces$e873043a5e$Comparator *)($t1 = &(*c)))->class$->compare, $t2($t1, (struct OBX$Array$1){32,1,dij}, ($t0 = (&(*this$).storage),(struct OBX$Array$1){32,1,&((char *)$t0->$a)[l*32]}))) <= 0)) ) {
                        l = (l - 1);
                    } else {
                        break;
                    }
                }
                k = (k + 1);
                while(1) {
                    if( ((k <= l) && (($t2 = ((struct som$Interfaces$e873043a5e$Comparator *)($t1 = &(*c)))->class$->compare, $t2($t1, ($t0 = (&(*this$).storage),(struct OBX$Array$1){32,1,&((char *)$t0->$a)[k*32]}), (struct OBX$Array$1){32,1,dij})) <= 0)) ) {
                        k = (k + 1);
                    } else {
                        break;
                    }
                }
                if( (k > l) ) {
                    break;
                } 
                som$Vector$e873043a5e$swap((*this$).storage, k, l);
            }
            ($t5 = ((struct som$Vector$e873043a5e$Vector *)($t1 = &(*this$)))->class$->sortImp, $t5($t1, i, l, &(*c)));
            ($t5 = ((struct som$Vector$e873043a5e$Vector *)($t1 = &(*this$)))->class$->sortImp, $t5($t1, k, j, &(*c)));
        } 
    } 
}

void som$Vector$e873043a5e$swap(struct OBX$Array$2 storage2, int32_t i, int32_t j) {
    char temp[32];
    struct OBX$Array$2* $t0;
    struct OBX$Array$2* $t1;
    memset(&temp,0,sizeof(temp));
    OBX$StrCopy(&(struct OBX$Array$1){32,1,temp},0,($t0 = (&storage2),&(struct OBX$Array$1){32,1,&((char *)$t0->$a)[i*32]}),0);
    OBX$StrCopy(($t0 = (&storage2),&(struct OBX$Array$1){32,1,&((char *)$t0->$a)[i*32]}),0,($t1 = (&storage2),&(struct OBX$Array$1){32,1,&((char *)$t1->$a)[j*32]}),0);
    OBX$StrCopy(($t0 = (&storage2),&(struct OBX$Array$1){32,1,&((char *)$t0->$a)[j*32]}),0,&(struct OBX$Array$1){32,1,temp},0);
}

struct som$Vector$e873043a5e$Vector$Class$ som$Vector$e873043a5e$Vector$class$ = { 
    0,
    som$Vector$e873043a5e$Vector$at,
    som$Vector$e873043a5e$Vector$resize,
    som$Vector$e873043a5e$Vector$atPut,
    som$Vector$e873043a5e$Vector$append,
    som$Vector$e873043a5e$Vector$isEmpty,
    som$Vector$e873043a5e$Vector$first,
    som$Vector$e873043a5e$Vector$removeFirst,
    som$Vector$e873043a5e$Vector$removeAll,
    som$Vector$e873043a5e$Vector$getSize,
    som$Vector$e873043a5e$Vector$capacity,
    som$Vector$e873043a5e$Vector$forEach,
    som$Vector$e873043a5e$Vector$hasSome,
    som$Vector$e873043a5e$Vector$getOne,
    som$Vector$e873043a5e$Vector$remove,
    som$Vector$e873043a5e$Vector$sort,
    som$Vector$e873043a5e$Vector$sortImp,
};

static int initDone$ = 0;
void som$Vector$e873043a5e$init$(void) {
    if(initDone$) return; else initDone$ = 1;
    som$Interfaces$e873043a5e$init$();
}
OBX$Cmd som$Vector$e873043a5e$cmd$(const char* name) {
    if( name == 0 ) return som$Vector$e873043a5e$init$;
    return 0;
}
