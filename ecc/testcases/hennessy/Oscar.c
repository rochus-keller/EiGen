// Generated by Oberon+ IDE (Mono) 0.9.107 on 2024-08-10T01:27:54

#include "Oscar.h"

void Oscar$complex$init$(struct Oscar$complex* inst){
    inst->class$ = &Oscar$complex$class$;
}
struct Oscar$complex Oscar$z[257];
struct Oscar$complex Oscar$w[257];
struct Oscar$complex Oscar$e[130];
double Oscar$zr = 0;
double Oscar$zi = 0;
double Oscar$Cos(double x) {
    int32_t i;
    int32_t factor;
    double result;
    double power;
    i = 0;
    factor = 0;
    result = 0;
    power = 0;
    result = 1.0000000e+00;
    factor = 1;
    power = x;
    i = 2;
    while(1) {
        if( (i <= 10) ) {
            factor = (factor * i);
            power = (power * x);
            if( (OBX$Mod32(i,2) == 0) ) {
                if( (OBX$Mod32(i,4) == 0) ) {
                    result = (result + (power / (double)factor));
                } else {
                    result = (result - (power / (double)factor));
                }
            } 
            i++;
        } else {
            break;
        }
    }
    return result;
}

int32_t Oscar$Min0(int32_t arg1, int32_t arg2) {
    int32_t res;
    res = 0;
    res = 0;
    if( (arg1 < arg2) ) {
        res = arg1;
    } else {
        res = arg2;
    }
    return res;
}

void Oscar$Uniform11(int32_t iy, double yfl) {
    iy = OBX$Mod32(((4855 * iy) + 1731),8192);
    yfl = ((double)iy / 8.1920000e+03);
}

void Oscar$Exptab(int32_t n, struct OBX$Array$1 e) {
    double theta;
    double divisor;
    double d3;
    double h[26];
    int32_t i;
    int32_t j;
    int32_t k;
    int32_t l;
    int32_t m;
    int32_t d1;
    int32_t d2;
    struct OBX$Array$1* $t0;
    struct OBX$Array$1* $t1;
    struct OBX$Array$1* $t2;
    theta = 0;
    divisor = 0;
    d3 = 0;
    memset(&h,0,sizeof(h));
    i = 0;
    j = 0;
    k = 0;
    l = 0;
    m = 0;
    d1 = 0;
    d2 = 0;
    theta = 3.1415926536000001e+00;
    divisor = 4.0000000e+00;
    i = 1;
    while(1) {
        if( (i <= 25) ) {
            (((double *)((struct OBX$Array$1){26,1,h}).$a)[i]) = (1.0000000e+00 / (2.0000000e+00 * Oscar$Cos((theta / divisor))));
            divisor = (divisor + divisor);
            i++;
        } else {
            break;
        }
    }
    m = OBX$Div32(n,2);
    l = OBX$Div32(m,2);
    j = 1;
    (((struct Oscar$complex *)(e).$a)[1]).rp = 1.0000000e+00;
    (((struct Oscar$complex *)(e).$a)[1]).ip = 0.0000000e+00;
    (((struct Oscar$complex *)(e).$a)[(l + 1)]).rp = 0.0000000e+00;
    (((struct Oscar$complex *)(e).$a)[(l + 1)]).ip = 1.0000000e+00;
    (((struct Oscar$complex *)(e).$a)[(m + 1)]).rp = (-1.0000000e+00);
    (((struct Oscar$complex *)(e).$a)[(m + 1)]).ip = 0.0000000e+00;
    do {
        i = OBX$Div32(l,2);
        k = i;
        do {
            d1 = ((k + i) + 1);
            d2 = ((k - i) + 1);
            d3 = (((struct Oscar$complex *)(e).$a)[d2]).rp;
            (((struct Oscar$complex *)(e).$a)[(k + 1)]).rp = ((((double *)((struct OBX$Array$1){26,1,h}).$a)[j]) * ((((struct Oscar$complex *)(e).$a)[d1]).rp + d3));
            d3 = (((struct Oscar$complex *)(e).$a)[d2]).ip;
            (((struct Oscar$complex *)(e).$a)[(k + 1)]).ip = ((((double *)((struct OBX$Array$1){26,1,h}).$a)[j]) * ((((struct Oscar$complex *)(e).$a)[d1]).ip + d3));
            k = (k + l);
        }while(!((k > m)));
        j = Oscar$Min0((j + 1), 25);
        l = i;
    }while(!((l <= 1)));
}

void Oscar$Fft(int32_t n, struct OBX$Array$1 z, struct OBX$Array$1 w, struct OBX$Array$1 e, double sqrinv) {
    int32_t i;
    int32_t j;
    int32_t k;
    int32_t l;
    int32_t m;
    int32_t index;
    double h;
    double d1;
    double d2;
    struct OBX$Array$1* $t0;
    struct OBX$Array$1* $t1;
    struct OBX$Array$1* $t2;
    i = 0;
    j = 0;
    k = 0;
    l = 0;
    m = 0;
    index = 0;
    h = 0;
    d1 = 0;
    d2 = 0;
    m = OBX$Div32(n,2);
    l = 1;
    do {
        k = 0;
        j = l;
        i = 1;
        do {
            do {
                (((struct Oscar$complex *)(w).$a)[(i + k)]).rp = ((((struct Oscar$complex *)(z).$a)[i]).rp + (((struct Oscar$complex *)(z).$a)[(m + i)]).rp);
                (((struct Oscar$complex *)(w).$a)[(i + k)]).ip = ((((struct Oscar$complex *)(z).$a)[i]).ip + (((struct Oscar$complex *)(z).$a)[(m + i)]).ip);
                h = ((((struct Oscar$complex *)(e).$a)[(k + 1)]).rp * ((((struct Oscar$complex *)(z).$a)[i]).rp - (((struct Oscar$complex *)(z).$a)[(i + m)]).rp));
                d1 = ((((struct Oscar$complex *)(z).$a)[i]).ip - (((struct Oscar$complex *)(z).$a)[(i + m)]).ip);
                (((struct Oscar$complex *)(w).$a)[(i + j)]).rp = (h - ((((struct Oscar$complex *)(e).$a)[(k + 1)]).ip * d1));
                h = ((((struct Oscar$complex *)(e).$a)[(k + 1)]).rp * ((((struct Oscar$complex *)(z).$a)[i]).ip - (((struct Oscar$complex *)(z).$a)[(i + m)]).ip));
                d1 = ((((struct Oscar$complex *)(z).$a)[i]).rp - (((struct Oscar$complex *)(z).$a)[(i + m)]).rp);
                (((struct Oscar$complex *)(w).$a)[(i + j)]).ip = (h + ((((struct Oscar$complex *)(e).$a)[(k + 1)]).ip * d1));
                i = (i + 1);
            }while(!((i > j)));
            k = j;
            j = (k + l);
        }while(!((j > m)));
        index = 1;
        do {
            (((struct Oscar$complex *)(z).$a)[index]) = (((struct Oscar$complex *)(w).$a)[index]);
            index = (index + 1);
        }while(!((index > n)));
        l = (l + l);
    }while(!((l > m)));
    i = 1;
    while(1) {
        if( (i <= n) ) {
            (((struct Oscar$complex *)(z).$a)[i]).rp = (sqrinv * (((struct Oscar$complex *)(z).$a)[i]).rp);
            (((struct Oscar$complex *)(z).$a)[i]).ip = (-(sqrinv * (((struct Oscar$complex *)(z).$a)[i]).ip));
            i++;
        } else {
            break;
        }
    }
}

void Oscar$Run() {
    int32_t i;
    struct OBX$Array$1* $t0;
    i = 0;
    Oscar$Exptab(256, (struct OBX$Array$1){130,1,Oscar$e});
    Util$seed = 5767;
    i = 1;
    while(1) {
        if( (i <= 256) ) {
            Oscar$Uniform11(Util$seed, Oscar$zr);
            Oscar$Uniform11(Util$seed, Oscar$zi);
            (((struct Oscar$complex *)((struct OBX$Array$1){257,1,Oscar$z}).$a)[i]).rp = ((2.0000000e+01 * Oscar$zr) - 1.0000000e+01);
            (((struct Oscar$complex *)((struct OBX$Array$1){257,1,Oscar$z}).$a)[i]).ip = ((2.0000000e+01 * Oscar$zi) - 1.0000000e+01);
            i++;
        } else {
            break;
        }
    }
    i = 1;
    while(1) {
        if( (i <= 20) ) {
            Oscar$Fft(256, (struct OBX$Array$1){257,1,Oscar$z}, (struct OBX$Array$1){257,1,Oscar$w}, (struct OBX$Array$1){130,1,Oscar$e}, 6.2500000e-02);
            i++;
        } else {
            break;
        }
    }
}

struct Oscar$complex$Class$ Oscar$complex$class$ = { 
    0,
};

static int initDone$ = 0;
void Oscar$init$(void) {
    if(initDone$) return; else initDone$ = 1;
    Util$init$();
    memset(&Oscar$z,0,sizeof(Oscar$z));
    for(int $i = 0; $i < (257); $i++) Oscar$complex$init$(&((struct Oscar$complex *)Oscar$z)[$i]);
    memset(&Oscar$w,0,sizeof(Oscar$w));
    for(int $i = 0; $i < (257); $i++) Oscar$complex$init$(&((struct Oscar$complex *)Oscar$w)[$i]);
    memset(&Oscar$e,0,sizeof(Oscar$e));
    for(int $i = 0; $i < (130); $i++) Oscar$complex$init$(&((struct Oscar$complex *)Oscar$e)[$i]);
    Oscar$zr = 0.0000000e+00;
    Oscar$zi = 0.0000000e+00;
}
OBX$Cmd Oscar$cmd$(const char* name) {
    if( name == 0 ) return Oscar$init$;
    if( strcmp(name,"Run") == 0 ) return Oscar$Run;
    return 0;
}
