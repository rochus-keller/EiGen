// Generated by Oberon+ IDE (Mono) 0.9.107 on 2024-08-10T01:27:54

#include "Trees.h"

void Trees$nodeDesc$init$(struct Trees$nodeDesc* inst){
    inst->class$ = &Trees$nodeDesc$class$;
}
int32_t Trees$sortlist[5001];
int32_t Trees$biggest = 0;
int32_t Trees$littlest = 0;
struct Trees$nodeDesc * Trees$tree = 0;
void Trees$tInitarr() {
    int32_t i;
    int32_t temp;
    struct OBX$Array$1* $t0;
    struct OBX$Array$1* $t1;
    i = 0;
    temp = 0;
    Util$Initrand();
    Trees$biggest = 0;
    Trees$littlest = 0;
    i = 1;
    while(1) {
        if( (i <= 5000) ) {
            temp = Util$Rand();
            (((int32_t *)((struct OBX$Array$1){5001,1,Trees$sortlist}).$a)[i]) = ((temp - (OBX$Div32(temp,100000) * 100000)) - 50000);
            if( ((((int32_t *)((struct OBX$Array$1){5001,1,Trees$sortlist}).$a)[i]) > Trees$biggest) ) {
                Trees$biggest = (((int32_t *)((struct OBX$Array$1){5001,1,Trees$sortlist}).$a)[i]);
            } else if( ((((int32_t *)((struct OBX$Array$1){5001,1,Trees$sortlist}).$a)[i]) < Trees$littlest) ) {
                Trees$littlest = (((int32_t *)((struct OBX$Array$1){5001,1,Trees$sortlist}).$a)[i]);
            } 
            i++;
        } else {
            break;
        }
    }
}

void Trees$CreateNode(struct Trees$nodeDesc * * t, int32_t n) {
    struct Trees$nodeDesc * $t0;
    $t0 = OBX$Alloc(sizeof(struct Trees$nodeDesc));
    memset($t0,0,sizeof(struct Trees$nodeDesc));
    (*t) = $t0;
    Trees$nodeDesc$init$($t0);
    (*(*t)).left = 0;
    (*(*t)).right = 0;
    (*(*t)).val_ = n;
}

void Trees$Insert(int32_t n, struct Trees$nodeDesc * t) {
    if( (n > (*t).val_) ) {
        if( ((void*)(*t).left == (void*)0) ) {
            Trees$CreateNode(&(*t).left, n);
        } else {
            Trees$Insert(n, (*t).left);
        }
    } else if( (n < (*t).val_) ) {
        if( ((void*)(*t).right == (void*)0) ) {
            Trees$CreateNode(&(*t).right, n);
        } else {
            Trees$Insert(n, (*t).right);
        }
    } 
}

uint8_t Trees$Checktree(struct Trees$nodeDesc * p) {
    uint8_t result;
    result = 0;
    result = 1;
    if( ((void*)(*p).left != (void*)0) ) {
        if( ((*(*p).left).val_ <= (*p).val_) ) {
            result = 0;
        } else {
            result = (Trees$Checktree((*p).left) && result);
        }
    } 
    if( ((void*)(*p).right != (void*)0) ) {
        if( ((*(*p).right).val_ >= (*p).val_) ) {
            result = 0;
        } else {
            result = (Trees$Checktree((*p).right) && result);
        }
    } 
    return result;
}

void Trees$Run() {
    int32_t i;
    struct Trees$nodeDesc * $t0;
    struct OBX$Array$1* $t1;
    i = 0;
    Trees$tInitarr();
    $t0 = OBX$Alloc(sizeof(struct Trees$nodeDesc));
    memset($t0,0,sizeof(struct Trees$nodeDesc));
    Trees$tree = $t0;
    Trees$nodeDesc$init$($t0);
    (*Trees$tree).left = 0;
    (*Trees$tree).right = 0;
    (*Trees$tree).val_ = (((int32_t *)((struct OBX$Array$1){5001,1,Trees$sortlist}).$a)[1]);
    i = 2;
    while(1) {
        if( (i <= 5000) ) {
            Trees$Insert((((int32_t *)((struct OBX$Array$1){5001,1,Trees$sortlist}).$a)[i]), Trees$tree);
            i++;
        } else {
            break;
        }
    }
    if( (!Trees$Checktree(Trees$tree)) ) {
        Util$Str((const struct OBX$Array$1){17,0,OBX$FromUtf(" Error in Tree.$",17,0)});
    } 
}

struct Trees$nodeDesc$Class$ Trees$nodeDesc$class$ = { 
    0,
};

static int initDone$ = 0;
void Trees$init$(void) {
    if(initDone$) return; else initDone$ = 1;
    Util$init$();
    memset(&Trees$sortlist,0,sizeof(Trees$sortlist));
}
OBX$Cmd Trees$cmd$(const char* name) {
    if( name == 0 ) return Trees$init$;
    if( strcmp(name,"tInitarr") == 0 ) return Trees$tInitarr;
    if( strcmp(name,"Run") == 0 ) return Trees$Run;
    return 0;
}
