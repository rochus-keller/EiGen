// This file was automatically generated by EbnfStudio; don't modify it!
#include "IrParser.h"
using namespace Ir;

static inline bool FIRST_Program(int tt) {
	switch(tt){
	case Tok_dot_initdata:
	case Tok_dot_type:
	case Tok_dot_data:
	case Tok_dot_const:
	case Tok_dot_code:
	case Tok_dot_initcode:
		return true;
	default: return false;
	}
}

static inline bool FIRST_Section(int tt) {
	switch(tt){
	case Tok_dot_initdata:
	case Tok_dot_type:
	case Tok_dot_data:
	case Tok_dot_const:
	case Tok_dot_code:
	case Tok_dot_initcode:
		return true;
	default: return false;
	}
}

static inline bool FIRST_code_section(int tt) {
	return tt == Tok_dot_code;
}

static inline bool FIRST_code(int tt) {
	switch(tt){
	case Tok_jump:
	case Tok_leave:
	case Tok_or:
	case Tok_ret:
	case Tok_conv:
	case Tok_pop:
	case Tok_breq:
	case Tok_copy:
	case Tok_brne:
	case Tok_br:
	case Tok_brge:
	case Tok_sub:
	case Tok_neg:
	case Tok_fill:
	case Tok_mul:
	case Tok_mod:
	case Tok_add:
	case Tok_trap:
	case Tok_mov:
	case Tok_alias:
	case Tok_brlt:
	case Tok_xor:
	case Tok_nop:
	case Tok_lsh:
	case Tok_rsh:
	case Tok_div:
	case Tok_not:
	case Tok_unfix:
	case Tok_req:
	case Tok_call:
	case Tok_push:
	case Tok_and:
	case Tok_fix:
	case Tok_enter:
		return true;
	default: return false;
	}
}

static inline bool FIRST_init_code_section(int tt) {
	return tt == Tok_dot_initcode;
}

static inline bool FIRST_data_section(int tt) {
	return tt == Tok_dot_data;
}

static inline bool FIRST_init_data_section(int tt) {
	return tt == Tok_dot_initdata;
}

static inline bool FIRST_const_section(int tt) {
	return tt == Tok_dot_const;
}

static inline bool FIRST_type_section(int tt) {
	return tt == Tok_dot_type;
}

static inline bool FIRST_data_management(int tt) {
	return tt == Tok_conv || tt == Tok_fill || tt == Tok_copy || tt == Tok_mov;
}

static inline bool FIRST_arithmetic(int tt) {
	switch(tt){
	case Tok_mod:
	case Tok_add:
	case Tok_sub:
	case Tok_neg:
	case Tok_div:
	case Tok_mul:
		return true;
	default: return false;
	}
}

static inline bool FIRST_bit_manipulation(int tt) {
	switch(tt){
	case Tok_xor:
	case Tok_and:
	case Tok_lsh:
	case Tok_or:
	case Tok_rsh:
	case Tok_not:
		return true;
	default: return false;
	}
}

static inline bool FIRST_function_call(int tt) {
	switch(tt){
	case Tok_pop:
	case Tok_push:
	case Tok_leave:
	case Tok_ret:
	case Tok_call:
	case Tok_enter:
		return true;
	default: return false;
	}
}

static inline bool FIRST_branching(int tt) {
	switch(tt){
	case Tok_breq:
	case Tok_jump:
	case Tok_br:
	case Tok_brlt:
	case Tok_brne:
	case Tok_brge:
		return true;
	default: return false;
	}
}

static inline bool FIRST_special(int tt) {
	return tt == Tok_fix || tt == Tok_nop || tt == Tok_unfix;
}

static inline bool FIRST_loc(int tt) {
	return tt == Tok_loc;
}

static inline bool FIRST_alias(int tt) {
	return tt == Tok_alias;
}

static inline bool FIRST_req(int tt) {
	return tt == Tok_req;
}

static inline bool FIRST_trap(int tt) {
	return tt == Tok_trap;
}

static inline bool FIRST_break_decl(int tt) {
	return tt == Tok_break;
}

static inline bool FIRST_Offset(int tt) {
	return tt == Tok_Minus || tt == Tok_Plus;
}

static inline bool FIRST_Size(int tt) {
	return tt == Tok_octal_integer || tt == Tok_hex_integer || tt == Tok_binary_integer || tt == Tok_decimal_integer;
}

static inline bool FIRST_type(int tt) {
	switch(tt){
	case Tok_rec:
	case Tok_ptr:
	case Tok_void:
	case Tok_array:
	case Tok_ref:
	case Tok_enum:
	case Tok_func:
	case Tok_type:
		return true;
	default: return false;
	}
}

static inline bool FIRST_typeref(int tt) {
	return tt == Tok_type;
}

static inline bool FIRST_rec_decl(int tt) {
	return tt == Tok_rec;
}

static inline bool FIRST_field_decl(int tt) {
	return tt == Tok_field;
}

static inline bool FIRST_field(int tt) {
	return tt == Tok_field;
}

static inline bool FIRST_array_decl(int tt) {
	return tt == Tok_array;
}

static inline bool FIRST_ptr_decl(int tt) {
	return tt == Tok_ptr;
}

static inline bool FIRST_ref_decl(int tt) {
	return tt == Tok_ref;
}

static inline bool FIRST_enum_decl(int tt) {
	return tt == Tok_enum;
}

static inline bool FIRST_enum_elem(int tt) {
	return tt == Tok_value;
}

static inline bool FIRST_value(int tt) {
	return tt == Tok_value;
}

static inline bool FIRST_func_decl(int tt) {
	return tt == Tok_func;
}

static inline bool FIRST_basic_type(int tt) {
	switch(tt){
	case Tok_s1:
	case Tok_ptr:
	case Tok_fun:
	case Tok_f4:
	case Tok_s2:
	case Tok_u2:
	case Tok_u4:
	case Tok_u8:
	case Tok_s8:
	case Tok_u1:
	case Tok_f8:
	case Tok_s4:
		return true;
	default: return false;
	}
}

static inline bool FIRST_data_decl(int tt) {
	return tt == Tok_loc;
}

static inline bool FIRST_def(int tt) {
	return tt == Tok_def;
}

static inline bool FIRST_res(int tt) {
	return tt == Tok_res;
}

static inline bool FIRST_sym_decl(int tt) {
	return tt == Tok_sym;
}

static inline bool FIRST_register_(int tt) {
	switch(tt){
	case Tok_dlr_2:
	case Tok_dlr_lnk:
	case Tok_dlr_sp:
	case Tok_dlr_5:
	case Tok_dlr_0:
	case Tok_dlr_fp:
	case Tok_dlr_7:
	case Tok_dlr_6:
	case Tok_dlr_res:
	case Tok_dlr_3:
	case Tok_dlr_4:
	case Tok_dlr_1:
		return true;
	default: return false;
	}
}

static inline bool FIRST_immediate_op(int tt) {
	switch(tt){
	case Tok_Minus:
	case Tok_octal_integer:
	case Tok_hex_integer:
	case Tok_Plus:
	case Tok_binary_integer:
	case Tok_real:
	case Tok_decimal_integer:
		return true;
	default: return false;
	}
}

static inline bool FIRST_register_op(int tt) {
	switch(tt){
	case Tok_dlr_2:
	case Tok_dlr_lnk:
	case Tok_dlr_sp:
	case Tok_dlr_5:
	case Tok_dlr_0:
	case Tok_dlr_fp:
	case Tok_dlr_7:
	case Tok_dlr_6:
	case Tok_dlr_res:
	case Tok_dlr_3:
	case Tok_dlr_4:
	case Tok_dlr_1:
		return true;
	default: return false;
	}
}

static inline bool FIRST_address_op(int tt) {
	return tt == Tok_At;
}

static inline bool FIRST_memory_op(int tt) {
	return tt == Tok_Lbrack;
}

static inline bool FIRST_ImmAdr(int tt) {
	switch(tt){
	case Tok_s1:
	case Tok_ptr:
	case Tok_fun:
	case Tok_f4:
	case Tok_u2:
	case Tok_s2:
	case Tok_u4:
	case Tok_u8:
	case Tok_s8:
	case Tok_u1:
	case Tok_f8:
	case Tok_s4:
		return true;
	default: return false;
	}
}

static inline bool FIRST_RegMem(int tt) {
	switch(tt){
	case Tok_s1:
	case Tok_ptr:
	case Tok_fun:
	case Tok_f4:
	case Tok_u2:
	case Tok_s2:
	case Tok_u4:
	case Tok_u8:
	case Tok_s8:
	case Tok_u1:
	case Tok_f8:
	case Tok_s4:
		return true;
	default: return false;
	}
}

static inline bool FIRST_ImmRegMem(int tt) {
	switch(tt){
	case Tok_s1:
	case Tok_ptr:
	case Tok_fun:
	case Tok_f4:
	case Tok_u2:
	case Tok_s2:
	case Tok_u4:
	case Tok_u8:
	case Tok_s8:
	case Tok_u1:
	case Tok_f8:
	case Tok_s4:
		return true;
	default: return false;
	}
}

static inline bool FIRST_ImmRegAdrMem(int tt) {
	switch(tt){
	case Tok_s1:
	case Tok_ptr:
	case Tok_fun:
	case Tok_f4:
	case Tok_u2:
	case Tok_s2:
	case Tok_u4:
	case Tok_u8:
	case Tok_s8:
	case Tok_u1:
	case Tok_f8:
	case Tok_s4:
		return true;
	default: return false;
	}
}

static inline bool FIRST_Pointer(int tt) {
	return tt == Tok_ptr;
}

static inline bool FIRST_Function(int tt) {
	return tt == Tok_fun;
}

static inline bool FIRST_Register(int tt) {
	switch(tt){
	case Tok_s1:
	case Tok_ptr:
	case Tok_fun:
	case Tok_f4:
	case Tok_u2:
	case Tok_s2:
	case Tok_u4:
	case Tok_u8:
	case Tok_s8:
	case Tok_u1:
	case Tok_f8:
	case Tok_s4:
		return true;
	default: return false;
	}
}

static inline bool FIRST_number(int tt) {
	return tt == Tok_octal_integer || tt == Tok_hex_integer || tt == Tok_binary_integer || tt == Tok_real || tt == Tok_decimal_integer;
}

static inline bool FIRST_unsigned_int(int tt) {
	return tt == Tok_octal_integer || tt == Tok_hex_integer || tt == Tok_binary_integer || tt == Tok_decimal_integer;
}

void Parser::RunParser() {
	root = SynTree();
	errors.clear();
	next();
	Program(&root);
}

void Parser::next() {
	cur = la;
	la = scanner->next();
	while( la.d_type == Tok_Invalid ) {
		errors << Error(la.d_val, la.d_lineNr, la.d_colNr, la.d_sourcePath);
		la = scanner->next();
	}
}

Token Parser::peek(int off) {
	if( off == 1 )
		return la;
	else if( off == 0 )
		return cur;
	else
		return scanner->peek(off-1);
}

void Parser::invalid(const char* what) {
	errors << Error(QString("invalid %1").arg(what),la.d_lineNr, la.d_colNr, la.d_sourcePath);
}

bool Parser::expect(int tt, bool pkw, const char* where) {
	if( la.d_type == tt) { next(); return true; }
	else { errors << Error(QString("'%1' expected in %2").arg(tokenTypeString(tt)).arg(where),la.d_lineNr, la.d_colNr, la.d_sourcePath); return false; }
}

static inline void dummy() {}

	void Parser::addTerminal(SynTree* st) {
		SynTree* tmp = new SynTree( cur ); st->d_children.append(tmp);
	}
void Parser::Program(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Program, la); st->d_children.append(tmp); st = tmp; }
	while( FIRST_Section(la.d_type) ) {
		Section(st);
	}
}

void Parser::Section(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Section, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_code_section(la.d_type) ) {
		code_section(st);
	} else if( FIRST_init_code_section(la.d_type) ) {
		init_code_section(st);
	} else if( FIRST_data_section(la.d_type) ) {
		data_section(st);
	} else if( FIRST_init_data_section(la.d_type) ) {
		init_data_section(st);
	} else if( FIRST_const_section(la.d_type) ) {
		const_section(st);
	} else if( FIRST_type_section(la.d_type) ) {
		type_section(st);
	} else
		invalid("Section");
}

void Parser::code_section(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_code_section, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_dot_code, false, "code_section") ) addTerminal(st);
	if( expect(Tok_identifier, false, "code_section") ) addTerminal(st);
	while( la.d_type == Tok_dot_duplicable || la.d_type == Tok_dot_replaceable ) {
		if( la.d_type == Tok_dot_duplicable ) {
			if( expect(Tok_dot_duplicable, false, "code_section") ) addTerminal(st);
		} else if( la.d_type == Tok_dot_replaceable ) {
			if( expect(Tok_dot_replaceable, false, "code_section") ) addTerminal(st);
		} else
			invalid("code_section");
	}
	if( FIRST_loc(la.d_type) ) {
		loc(st);
	}
	if( FIRST_type(la.d_type) ) {
		type(st);
	}
	while( FIRST_code(la.d_type) || FIRST_sym_decl(la.d_type) || FIRST_break_decl(la.d_type) ) {
		if( FIRST_code(la.d_type) ) {
			code(st);
		} else if( FIRST_sym_decl(la.d_type) ) {
			sym_decl(st);
		} else if( FIRST_break_decl(la.d_type) ) {
			break_decl(st);
		} else
			invalid("code_section");
	}
}

void Parser::code(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_code, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_data_management(la.d_type) ) {
		data_management(st);
	} else if( FIRST_arithmetic(la.d_type) ) {
		arithmetic(st);
	} else if( FIRST_bit_manipulation(la.d_type) ) {
		bit_manipulation(st);
	} else if( FIRST_function_call(la.d_type) ) {
		function_call(st);
	} else if( FIRST_branching(la.d_type) ) {
		branching(st);
	} else if( FIRST_special(la.d_type) ) {
		special(st);
	} else if( FIRST_trap(la.d_type) ) {
		trap(st);
	} else if( FIRST_alias(la.d_type) ) {
		alias(st);
	} else if( FIRST_req(la.d_type) ) {
		req(st);
	} else
		invalid("code");
}

void Parser::init_code_section(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_init_code_section, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_dot_initcode, false, "init_code_section") ) addTerminal(st);
	if( expect(Tok_identifier, false, "init_code_section") ) addTerminal(st);
	while( la.d_type == Tok_dot_required || la.d_type == Tok_dot_duplicable ) {
		if( la.d_type == Tok_dot_required ) {
			if( expect(Tok_dot_required, false, "init_code_section") ) addTerminal(st);
		} else if( la.d_type == Tok_dot_duplicable ) {
			if( expect(Tok_dot_duplicable, false, "init_code_section") ) addTerminal(st);
		} else
			invalid("init_code_section");
	}
	while( FIRST_code(la.d_type) ) {
		code(st);
	}
}

void Parser::data_section(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_data_section, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_dot_data, false, "data_section") ) addTerminal(st);
	if( expect(Tok_identifier, false, "data_section") ) addTerminal(st);
	if( la.d_type == Tok_dot_alignment ) {
		if( expect(Tok_dot_alignment, false, "data_section") ) addTerminal(st);
		unsigned_int(st);
	}
	while( FIRST_alias(la.d_type) || FIRST_req(la.d_type) || FIRST_data_decl(la.d_type) ) {
		if( FIRST_alias(la.d_type) ) {
			alias(st);
		} else if( FIRST_req(la.d_type) ) {
			req(st);
		} else if( FIRST_data_decl(la.d_type) ) {
			data_decl(st);
		} else
			invalid("data_section");
	}
}

void Parser::init_data_section(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_init_data_section, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_dot_initdata, false, "init_data_section") ) addTerminal(st);
	if( expect(Tok_identifier, false, "init_data_section") ) addTerminal(st);
	while( FIRST_code(la.d_type) ) {
		code(st);
	}
}

void Parser::const_section(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_const_section, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_dot_const, false, "const_section") ) addTerminal(st);
	if( la.d_type == Tok_identifier ) {
		if( expect(Tok_identifier, false, "const_section") ) addTerminal(st);
	} else if( la.d_type == Tok_string ) {
		if( expect(Tok_string, false, "const_section") ) addTerminal(st);
	} else
		invalid("const_section");
	if( la.d_type == Tok_dot_duplicable || la.d_type == Tok_dot_alignment ) {
		if( la.d_type == Tok_dot_duplicable ) {
			if( expect(Tok_dot_duplicable, false, "const_section") ) addTerminal(st);
		} else if( la.d_type == Tok_dot_alignment ) {
			if( expect(Tok_dot_alignment, false, "const_section") ) addTerminal(st);
			unsigned_int(st);
		} else
			invalid("const_section");
	}
	while( FIRST_alias(la.d_type) || FIRST_req(la.d_type) || FIRST_def(la.d_type) ) {
		if( FIRST_alias(la.d_type) ) {
			alias(st);
		} else if( FIRST_req(la.d_type) ) {
			req(st);
		} else if( FIRST_def(la.d_type) ) {
			def(st);
		} else
			invalid("const_section");
	}
}

void Parser::type_section(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_type_section, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_dot_type, false, "type_section") ) addTerminal(st);
	if( expect(Tok_identifier, false, "type_section") ) addTerminal(st);
	while( FIRST_loc(la.d_type) || FIRST_type(la.d_type) ) {
		if( FIRST_loc(la.d_type) ) {
			loc(st);
		} else if( FIRST_type(la.d_type) ) {
			type(st);
		} else
			invalid("type_section");
	}
}

void Parser::data_management(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_data_management, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_mov ) {
		if( expect(Tok_mov, true, "data_management") ) addTerminal(st);
		RegMem(st);
		if( expect(Tok_Comma, false, "data_management") ) addTerminal(st);
		ImmRegAdrMem(st);
	} else if( la.d_type == Tok_conv ) {
		if( expect(Tok_conv, true, "data_management") ) addTerminal(st);
		RegMem(st);
		if( expect(Tok_Comma, false, "data_management") ) addTerminal(st);
		ImmRegAdrMem(st);
	} else if( la.d_type == Tok_copy ) {
		if( expect(Tok_copy, true, "data_management") ) addTerminal(st);
		Pointer(st);
		if( expect(Tok_Comma, false, "data_management") ) addTerminal(st);
		Pointer(st);
		if( expect(Tok_Comma, false, "data_management") ) addTerminal(st);
		ImmRegMem(st);
	} else if( la.d_type == Tok_fill ) {
		if( expect(Tok_fill, true, "data_management") ) addTerminal(st);
		Pointer(st);
		if( expect(Tok_Comma, false, "data_management") ) addTerminal(st);
		Pointer(st);
		if( expect(Tok_Comma, false, "data_management") ) addTerminal(st);
		ImmRegAdrMem(st);
	} else
		invalid("data_management");
}

void Parser::arithmetic(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_arithmetic, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_add ) {
		if( expect(Tok_add, true, "arithmetic") ) addTerminal(st);
		RegMem(st);
		if( expect(Tok_Comma, false, "arithmetic") ) addTerminal(st);
		ImmRegAdrMem(st);
		if( expect(Tok_Comma, false, "arithmetic") ) addTerminal(st);
		ImmRegAdrMem(st);
	} else if( la.d_type == Tok_sub ) {
		if( expect(Tok_sub, true, "arithmetic") ) addTerminal(st);
		RegMem(st);
		if( expect(Tok_Comma, false, "arithmetic") ) addTerminal(st);
		ImmRegAdrMem(st);
		if( expect(Tok_Comma, false, "arithmetic") ) addTerminal(st);
		ImmRegAdrMem(st);
	} else if( la.d_type == Tok_mul ) {
		if( expect(Tok_mul, true, "arithmetic") ) addTerminal(st);
		RegMem(st);
		if( expect(Tok_Comma, false, "arithmetic") ) addTerminal(st);
		ImmRegMem(st);
		if( expect(Tok_Comma, false, "arithmetic") ) addTerminal(st);
		ImmRegMem(st);
	} else if( la.d_type == Tok_div ) {
		if( expect(Tok_div, true, "arithmetic") ) addTerminal(st);
		RegMem(st);
		if( expect(Tok_Comma, false, "arithmetic") ) addTerminal(st);
		ImmRegMem(st);
		if( expect(Tok_Comma, false, "arithmetic") ) addTerminal(st);
		ImmRegMem(st);
	} else if( la.d_type == Tok_mod ) {
		if( expect(Tok_mod, true, "arithmetic") ) addTerminal(st);
		RegMem(st);
		if( expect(Tok_Comma, false, "arithmetic") ) addTerminal(st);
		ImmRegMem(st);
		if( expect(Tok_Comma, false, "arithmetic") ) addTerminal(st);
		ImmRegMem(st);
	} else if( la.d_type == Tok_neg ) {
		if( expect(Tok_neg, true, "arithmetic") ) addTerminal(st);
		RegMem(st);
		if( expect(Tok_Comma, false, "arithmetic") ) addTerminal(st);
		ImmRegMem(st);
	} else
		invalid("arithmetic");
}

void Parser::bit_manipulation(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_bit_manipulation, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_and ) {
		if( expect(Tok_and, true, "bit_manipulation") ) addTerminal(st);
		RegMem(st);
		if( expect(Tok_Comma, false, "bit_manipulation") ) addTerminal(st);
		ImmRegMem(st);
		if( expect(Tok_Comma, false, "bit_manipulation") ) addTerminal(st);
		ImmRegMem(st);
	} else if( la.d_type == Tok_or ) {
		if( expect(Tok_or, true, "bit_manipulation") ) addTerminal(st);
		RegMem(st);
		if( expect(Tok_Comma, false, "bit_manipulation") ) addTerminal(st);
		ImmRegMem(st);
		if( expect(Tok_Comma, false, "bit_manipulation") ) addTerminal(st);
		ImmRegMem(st);
	} else if( la.d_type == Tok_xor ) {
		if( expect(Tok_xor, true, "bit_manipulation") ) addTerminal(st);
		RegMem(st);
		if( expect(Tok_Comma, false, "bit_manipulation") ) addTerminal(st);
		ImmRegMem(st);
		if( expect(Tok_Comma, false, "bit_manipulation") ) addTerminal(st);
		ImmRegMem(st);
	} else if( la.d_type == Tok_not ) {
		if( expect(Tok_not, true, "bit_manipulation") ) addTerminal(st);
		RegMem(st);
		if( expect(Tok_Comma, false, "bit_manipulation") ) addTerminal(st);
		ImmRegMem(st);
	} else if( la.d_type == Tok_lsh ) {
		if( expect(Tok_lsh, true, "bit_manipulation") ) addTerminal(st);
		RegMem(st);
		if( expect(Tok_Comma, false, "bit_manipulation") ) addTerminal(st);
		ImmRegMem(st);
		if( expect(Tok_Comma, false, "bit_manipulation") ) addTerminal(st);
		ImmRegMem(st);
	} else if( la.d_type == Tok_rsh ) {
		if( expect(Tok_rsh, true, "bit_manipulation") ) addTerminal(st);
		RegMem(st);
		if( expect(Tok_Comma, false, "bit_manipulation") ) addTerminal(st);
		ImmRegMem(st);
		if( expect(Tok_Comma, false, "bit_manipulation") ) addTerminal(st);
		ImmRegMem(st);
	} else
		invalid("bit_manipulation");
}

void Parser::function_call(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_function_call, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_push ) {
		if( expect(Tok_push, true, "function_call") ) addTerminal(st);
		ImmRegAdrMem(st);
	} else if( la.d_type == Tok_pop ) {
		if( expect(Tok_pop, true, "function_call") ) addTerminal(st);
		RegMem(st);
	} else if( la.d_type == Tok_call ) {
		if( expect(Tok_call, true, "function_call") ) addTerminal(st);
		Function(st);
		if( expect(Tok_Comma, false, "function_call") ) addTerminal(st);
		Size(st);
	} else if( la.d_type == Tok_ret ) {
		if( expect(Tok_ret, true, "function_call") ) addTerminal(st);
	} else if( la.d_type == Tok_enter ) {
		if( expect(Tok_enter, true, "function_call") ) addTerminal(st);
		Size(st);
	} else if( la.d_type == Tok_leave ) {
		if( expect(Tok_leave, true, "function_call") ) addTerminal(st);
	} else
		invalid("function_call");
}

void Parser::branching(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_branching, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_br ) {
		if( expect(Tok_br, true, "branching") ) addTerminal(st);
		Offset(st);
	} else if( la.d_type == Tok_jump ) {
		if( expect(Tok_jump, true, "branching") ) addTerminal(st);
		Function(st);
	} else if( la.d_type == Tok_breq ) {
		if( expect(Tok_breq, true, "branching") ) addTerminal(st);
		Offset(st);
		if( expect(Tok_Comma, false, "branching") ) addTerminal(st);
		ImmRegAdrMem(st);
		if( expect(Tok_Comma, false, "branching") ) addTerminal(st);
		ImmRegAdrMem(st);
	} else if( la.d_type == Tok_brne ) {
		if( expect(Tok_brne, true, "branching") ) addTerminal(st);
		Offset(st);
		if( expect(Tok_Comma, false, "branching") ) addTerminal(st);
		ImmRegAdrMem(st);
		if( expect(Tok_Comma, false, "branching") ) addTerminal(st);
		ImmRegAdrMem(st);
	} else if( la.d_type == Tok_brlt ) {
		if( expect(Tok_brlt, true, "branching") ) addTerminal(st);
		Offset(st);
		if( expect(Tok_Comma, false, "branching") ) addTerminal(st);
		ImmRegAdrMem(st);
		if( expect(Tok_Comma, false, "branching") ) addTerminal(st);
		ImmRegAdrMem(st);
	} else if( la.d_type == Tok_brge ) {
		if( expect(Tok_brge, true, "branching") ) addTerminal(st);
		Offset(st);
		if( expect(Tok_Comma, false, "branching") ) addTerminal(st);
		ImmRegAdrMem(st);
		if( expect(Tok_Comma, false, "branching") ) addTerminal(st);
		ImmRegAdrMem(st);
	} else
		invalid("branching");
}

void Parser::special(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_special, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_nop ) {
		if( expect(Tok_nop, true, "special") ) addTerminal(st);
	} else if( la.d_type == Tok_fix ) {
		if( expect(Tok_fix, true, "special") ) addTerminal(st);
		Register(st);
	} else if( la.d_type == Tok_unfix ) {
		if( expect(Tok_unfix, true, "special") ) addTerminal(st);
		Register(st);
	} else
		invalid("special");
}

void Parser::loc(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_loc, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_loc, true, "loc") ) addTerminal(st);
	if( expect(Tok_string, false, "loc") ) addTerminal(st);
	if( expect(Tok_Comma, false, "loc") ) addTerminal(st);
	Size(st);
	if( expect(Tok_Comma, false, "loc") ) addTerminal(st);
	Size(st);
}

void Parser::alias(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_alias, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_alias, true, "alias") ) addTerminal(st);
	if( expect(Tok_string, false, "alias") ) addTerminal(st);
}

void Parser::req(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_req, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_req, true, "req") ) addTerminal(st);
	if( expect(Tok_string, false, "req") ) addTerminal(st);
}

void Parser::trap(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_trap, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_trap, true, "trap") ) addTerminal(st);
	Size(st);
}

void Parser::break_decl(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_break_decl, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_break, true, "break_decl") ) addTerminal(st);
	loc(st);
}

void Parser::Offset(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Offset, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_Plus ) {
		if( expect(Tok_Plus, false, "Offset") ) addTerminal(st);
	} else if( la.d_type == Tok_Minus ) {
		if( expect(Tok_Minus, false, "Offset") ) addTerminal(st);
	} else
		invalid("Offset");
	unsigned_int(st);
}

void Parser::Size(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Size, la); st->d_children.append(tmp); st = tmp; }
	unsigned_int(st);
}

void Parser::type(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_type, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_void ) {
		if( expect(Tok_void, true, "type") ) addTerminal(st);
	} else if( FIRST_typeref(la.d_type) ) {
		typeref(st);
	} else if( FIRST_array_decl(la.d_type) ) {
		array_decl(st);
	} else if( FIRST_rec_decl(la.d_type) ) {
		rec_decl(st);
	} else if( FIRST_ptr_decl(la.d_type) ) {
		ptr_decl(st);
	} else if( FIRST_ref_decl(la.d_type) ) {
		ref_decl(st);
	} else if( FIRST_func_decl(la.d_type) ) {
		func_decl(st);
	} else if( FIRST_enum_decl(la.d_type) ) {
		enum_decl(st);
	} else
		invalid("type");
}

void Parser::typeref(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_typeref, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_type, true, "typeref") ) addTerminal(st);
	if( la.d_type == Tok_string ) {
		if( expect(Tok_string, false, "typeref") ) addTerminal(st);
	} else if( FIRST_basic_type(la.d_type) ) {
		basic_type(st);
	} else
		invalid("typeref");
}

void Parser::rec_decl(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_rec_decl, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_rec, true, "rec_decl") ) addTerminal(st);
	Offset(st);
	if( expect(Tok_Comma, false, "rec_decl") ) addTerminal(st);
	Size(st);
	while( FIRST_field_decl(la.d_type) ) {
		field_decl(st);
	}
}

void Parser::field_decl(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_field_decl, la); st->d_children.append(tmp); st = tmp; }
	field(st);
	loc(st);
	type(st);
}

void Parser::field(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_field, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_field, true, "field") ) addTerminal(st);
	if( expect(Tok_string, false, "field") ) addTerminal(st);
	if( expect(Tok_Comma, false, "field") ) addTerminal(st);
	Size(st);
	if( expect(Tok_Comma, false, "field") ) addTerminal(st);
	basic_type(st);
	immediate_op(st);
}

void Parser::array_decl(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_array_decl, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_array, true, "array_decl") ) addTerminal(st);
	Size(st);
	if( expect(Tok_Comma, false, "array_decl") ) addTerminal(st);
	Size(st);
	type(st);
}

void Parser::ptr_decl(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ptr_decl, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_ptr, true, "ptr_decl") ) addTerminal(st);
	type(st);
}

void Parser::ref_decl(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ref_decl, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_ref, true, "ref_decl") ) addTerminal(st);
	type(st);
}

void Parser::enum_decl(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_enum_decl, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_enum, true, "enum_decl") ) addTerminal(st);
	Offset(st);
	typeref(st);
	while( FIRST_enum_elem(la.d_type) ) {
		enum_elem(st);
	}
}

void Parser::enum_elem(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_enum_elem, la); st->d_children.append(tmp); st = tmp; }
	value(st);
	loc(st);
}

void Parser::value(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_value, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_value, true, "value") ) addTerminal(st);
	if( expect(Tok_string, false, "value") ) addTerminal(st);
	if( expect(Tok_Comma, false, "value") ) addTerminal(st);
	basic_type(st);
	immediate_op(st);
}

void Parser::func_decl(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_func_decl, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_func, true, "func_decl") ) addTerminal(st);
	Offset(st);
	type(st);
	while( FIRST_type(la.d_type) ) {
		type(st);
	}
}

void Parser::basic_type(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_basic_type, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_s1 ) {
		if( expect(Tok_s1, true, "basic_type") ) addTerminal(st);
	} else if( la.d_type == Tok_s2 ) {
		if( expect(Tok_s2, true, "basic_type") ) addTerminal(st);
	} else if( la.d_type == Tok_s4 ) {
		if( expect(Tok_s4, true, "basic_type") ) addTerminal(st);
	} else if( la.d_type == Tok_s8 ) {
		if( expect(Tok_s8, true, "basic_type") ) addTerminal(st);
	} else if( la.d_type == Tok_u1 ) {
		if( expect(Tok_u1, true, "basic_type") ) addTerminal(st);
	} else if( la.d_type == Tok_u2 ) {
		if( expect(Tok_u2, true, "basic_type") ) addTerminal(st);
	} else if( la.d_type == Tok_u4 ) {
		if( expect(Tok_u4, true, "basic_type") ) addTerminal(st);
	} else if( la.d_type == Tok_u8 ) {
		if( expect(Tok_u8, true, "basic_type") ) addTerminal(st);
	} else if( la.d_type == Tok_f4 ) {
		if( expect(Tok_f4, true, "basic_type") ) addTerminal(st);
	} else if( la.d_type == Tok_f8 ) {
		if( expect(Tok_f8, true, "basic_type") ) addTerminal(st);
	} else if( la.d_type == Tok_ptr ) {
		if( expect(Tok_ptr, true, "basic_type") ) addTerminal(st);
	} else if( la.d_type == Tok_fun ) {
		if( expect(Tok_fun, true, "basic_type") ) addTerminal(st);
	} else
		invalid("basic_type");
}

void Parser::data_decl(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_data_decl, la); st->d_children.append(tmp); st = tmp; }
	loc(st);
	type(st);
	while( FIRST_def(la.d_type) || FIRST_res(la.d_type) ) {
		if( FIRST_def(la.d_type) ) {
			def(st);
		} else if( FIRST_res(la.d_type) ) {
			res(st);
		} else
			invalid("data_decl");
	}
}

void Parser::def(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_def, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_def, true, "def") ) addTerminal(st);
	ImmAdr(st);
}

void Parser::res(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_res, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_res, true, "res") ) addTerminal(st);
	Size(st);
}

void Parser::sym_decl(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_sym_decl, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_sym, true, "sym_decl") ) addTerminal(st);
	Offset(st);
	if( expect(Tok_Comma, false, "sym_decl") ) addTerminal(st);
	if( expect(Tok_string, false, "sym_decl") ) addTerminal(st);
	if( expect(Tok_Comma, false, "sym_decl") ) addTerminal(st);
	ImmRegMem(st);
	loc(st);
	type(st);
}

void Parser::register_(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_register_, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_dlr_0 ) {
		if( expect(Tok_dlr_0, false, "register_") ) addTerminal(st);
	} else if( la.d_type == Tok_dlr_1 ) {
		if( expect(Tok_dlr_1, false, "register_") ) addTerminal(st);
	} else if( la.d_type == Tok_dlr_2 ) {
		if( expect(Tok_dlr_2, false, "register_") ) addTerminal(st);
	} else if( la.d_type == Tok_dlr_3 ) {
		if( expect(Tok_dlr_3, false, "register_") ) addTerminal(st);
	} else if( la.d_type == Tok_dlr_4 ) {
		if( expect(Tok_dlr_4, false, "register_") ) addTerminal(st);
	} else if( la.d_type == Tok_dlr_5 ) {
		if( expect(Tok_dlr_5, false, "register_") ) addTerminal(st);
	} else if( la.d_type == Tok_dlr_6 ) {
		if( expect(Tok_dlr_6, false, "register_") ) addTerminal(st);
	} else if( la.d_type == Tok_dlr_7 ) {
		if( expect(Tok_dlr_7, false, "register_") ) addTerminal(st);
	} else if( la.d_type == Tok_dlr_res ) {
		if( expect(Tok_dlr_res, false, "register_") ) addTerminal(st);
	} else if( la.d_type == Tok_dlr_sp ) {
		if( expect(Tok_dlr_sp, false, "register_") ) addTerminal(st);
	} else if( la.d_type == Tok_dlr_fp ) {
		if( expect(Tok_dlr_fp, false, "register_") ) addTerminal(st);
	} else if( la.d_type == Tok_dlr_lnk ) {
		if( expect(Tok_dlr_lnk, false, "register_") ) addTerminal(st);
	} else
		invalid("register_");
}

void Parser::immediate_op(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_immediate_op, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_Plus || la.d_type == Tok_Minus ) {
		if( la.d_type == Tok_Plus ) {
			if( expect(Tok_Plus, false, "immediate_op") ) addTerminal(st);
		} else if( la.d_type == Tok_Minus ) {
			if( expect(Tok_Minus, false, "immediate_op") ) addTerminal(st);
		} else
			invalid("immediate_op");
	}
	number(st);
}

void Parser::register_op(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_register_op, la); st->d_children.append(tmp); st = tmp; }
	register_(st);
	if( la.d_type == Tok_Plus || la.d_type == Tok_Minus ) {
		if( la.d_type == Tok_Plus ) {
			if( expect(Tok_Plus, false, "register_op") ) addTerminal(st);
		} else if( la.d_type == Tok_Minus ) {
			if( expect(Tok_Minus, false, "register_op") ) addTerminal(st);
		} else
			invalid("register_op");
		number(st);
	}
}

void Parser::address_op(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_address_op, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_At, false, "address_op") ) addTerminal(st);
	if( la.d_type == Tok_identifier ) {
		if( expect(Tok_identifier, false, "address_op") ) addTerminal(st);
	} else if( la.d_type == Tok_string ) {
		if( expect(Tok_string, false, "address_op") ) addTerminal(st);
	} else
		invalid("address_op");
	if( ( ( peek(1).d_type == Tok_Minus || peek(1).d_type == Tok_Plus ) && ( peek(2).d_type == Tok_binary_integer || peek(2).d_type == Tok_decimal_integer || peek(2).d_type == Tok_hex_integer || peek(2).d_type == Tok_octal_integer || peek(2).d_type == Tok_real ) )  || la.d_type == Tok_Plus ) {
		if( ( ( peek(1).d_type == Tok_Minus || peek(1).d_type == Tok_Plus ) && ( peek(2).d_type == Tok_binary_integer || peek(2).d_type == Tok_decimal_integer || peek(2).d_type == Tok_hex_integer || peek(2).d_type == Tok_octal_integer || peek(2).d_type == Tok_real ) )  ) {
			if( la.d_type == Tok_Plus ) {
				if( expect(Tok_Plus, false, "address_op") ) addTerminal(st);
			} else if( la.d_type == Tok_Minus ) {
				if( expect(Tok_Minus, false, "address_op") ) addTerminal(st);
			} else
				invalid("address_op");
			number(st);
		} else if( la.d_type == Tok_Plus ) {
			if( expect(Tok_Plus, false, "address_op") ) addTerminal(st);
			register_(st);
			if( la.d_type == Tok_Plus || la.d_type == Tok_Minus ) {
				if( la.d_type == Tok_Plus ) {
					if( expect(Tok_Plus, false, "address_op") ) addTerminal(st);
				} else if( la.d_type == Tok_Minus ) {
					if( expect(Tok_Minus, false, "address_op") ) addTerminal(st);
				} else
					invalid("address_op");
				number(st);
			}
		} else
			invalid("address_op");
	}
}

void Parser::memory_op(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_memory_op, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_Lbrack, false, "memory_op") ) addTerminal(st);
	if( FIRST_number(la.d_type) ) {
		number(st);
	} else if( FIRST_register_(la.d_type) ) {
		register_(st);
		if( la.d_type == Tok_Plus || la.d_type == Tok_Minus ) {
			if( la.d_type == Tok_Plus ) {
				if( expect(Tok_Plus, false, "memory_op") ) addTerminal(st);
			} else if( la.d_type == Tok_Minus ) {
				if( expect(Tok_Minus, false, "memory_op") ) addTerminal(st);
			} else
				invalid("memory_op");
			number(st);
		}
	} else if( la.d_type == Tok_At ) {
		if( expect(Tok_At, false, "memory_op") ) addTerminal(st);
		if( la.d_type == Tok_identifier ) {
			if( expect(Tok_identifier, false, "memory_op") ) addTerminal(st);
		} else if( la.d_type == Tok_string ) {
			if( expect(Tok_string, false, "memory_op") ) addTerminal(st);
		} else
			invalid("memory_op");
		if( ( ( peek(1).d_type == Tok_Minus || peek(1).d_type == Tok_Plus ) && ( peek(2).d_type == Tok_binary_integer || peek(2).d_type == Tok_decimal_integer || peek(2).d_type == Tok_hex_integer || peek(2).d_type == Tok_octal_integer || peek(2).d_type == Tok_real ) )  || la.d_type == Tok_Plus ) {
			if( ( ( peek(1).d_type == Tok_Minus || peek(1).d_type == Tok_Plus ) && ( peek(2).d_type == Tok_binary_integer || peek(2).d_type == Tok_decimal_integer || peek(2).d_type == Tok_hex_integer || peek(2).d_type == Tok_octal_integer || peek(2).d_type == Tok_real ) )  ) {
				if( la.d_type == Tok_Plus ) {
					if( expect(Tok_Plus, false, "memory_op") ) addTerminal(st);
				} else if( la.d_type == Tok_Minus ) {
					if( expect(Tok_Minus, false, "memory_op") ) addTerminal(st);
				} else
					invalid("memory_op");
				number(st);
			} else if( la.d_type == Tok_Plus ) {
				if( expect(Tok_Plus, false, "memory_op") ) addTerminal(st);
				register_(st);
				if( la.d_type == Tok_Plus || la.d_type == Tok_Minus ) {
					if( la.d_type == Tok_Plus ) {
						if( expect(Tok_Plus, false, "memory_op") ) addTerminal(st);
					} else if( la.d_type == Tok_Minus ) {
						if( expect(Tok_Minus, false, "memory_op") ) addTerminal(st);
					} else
						invalid("memory_op");
					number(st);
				}
			} else
				invalid("memory_op");
		}
	} else
		invalid("memory_op");
	if( expect(Tok_Rbrack, false, "memory_op") ) addTerminal(st);
}

void Parser::ImmAdr(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ImmAdr, la); st->d_children.append(tmp); st = tmp; }
	basic_type(st);
	if( FIRST_immediate_op(la.d_type) ) {
		immediate_op(st);
	} else if( FIRST_address_op(la.d_type) ) {
		address_op(st);
	} else
		invalid("ImmAdr");
}

void Parser::RegMem(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_RegMem, la); st->d_children.append(tmp); st = tmp; }
	basic_type(st);
	if( FIRST_register_op(la.d_type) ) {
		register_op(st);
	} else if( FIRST_memory_op(la.d_type) ) {
		memory_op(st);
	} else
		invalid("RegMem");
}

void Parser::ImmRegMem(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ImmRegMem, la); st->d_children.append(tmp); st = tmp; }
	basic_type(st);
	if( FIRST_immediate_op(la.d_type) ) {
		immediate_op(st);
	} else if( FIRST_register_op(la.d_type) ) {
		register_op(st);
	} else if( FIRST_memory_op(la.d_type) ) {
		memory_op(st);
	} else
		invalid("ImmRegMem");
}

void Parser::ImmRegAdrMem(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ImmRegAdrMem, la); st->d_children.append(tmp); st = tmp; }
	basic_type(st);
	if( FIRST_immediate_op(la.d_type) ) {
		immediate_op(st);
	} else if( FIRST_register_op(la.d_type) ) {
		register_op(st);
	} else if( FIRST_address_op(la.d_type) ) {
		address_op(st);
	} else if( FIRST_memory_op(la.d_type) ) {
		memory_op(st);
	} else
		invalid("ImmRegAdrMem");
}

void Parser::Pointer(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Pointer, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_ptr, true, "Pointer") ) addTerminal(st);
	if( FIRST_immediate_op(la.d_type) ) {
		immediate_op(st);
	} else if( FIRST_register_op(la.d_type) ) {
		register_op(st);
	} else if( FIRST_address_op(la.d_type) ) {
		address_op(st);
	} else if( FIRST_memory_op(la.d_type) ) {
		memory_op(st);
	} else
		invalid("Pointer");
}

void Parser::Function(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Function, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_fun, true, "Function") ) addTerminal(st);
	if( FIRST_immediate_op(la.d_type) ) {
		immediate_op(st);
	} else if( FIRST_register_op(la.d_type) ) {
		register_op(st);
	} else if( FIRST_address_op(la.d_type) ) {
		address_op(st);
	} else if( FIRST_memory_op(la.d_type) ) {
		memory_op(st);
	} else
		invalid("Function");
}

void Parser::Register(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Register, la); st->d_children.append(tmp); st = tmp; }
	basic_type(st);
	register_(st);
}

void Parser::number(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_number, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_unsigned_int(la.d_type) ) {
		unsigned_int(st);
	} else if( la.d_type == Tok_real ) {
		if( expect(Tok_real, false, "number") ) addTerminal(st);
	} else
		invalid("number");
}

void Parser::unsigned_int(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_unsigned_int, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_decimal_integer ) {
		if( expect(Tok_decimal_integer, false, "unsigned_int") ) addTerminal(st);
	} else if( la.d_type == Tok_binary_integer ) {
		if( expect(Tok_binary_integer, false, "unsigned_int") ) addTerminal(st);
	} else if( la.d_type == Tok_octal_integer ) {
		if( expect(Tok_octal_integer, false, "unsigned_int") ) addTerminal(st);
	} else if( la.d_type == Tok_hex_integer ) {
		if( expect(Tok_hex_integer, false, "unsigned_int") ) addTerminal(st);
	} else
		invalid("unsigned_int");
}

